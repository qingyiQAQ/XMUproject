diff -urN -x .git -x .repo openharmony/drivers/hdf/frameworks/include/platform/i2c_if.h openharmony_100ask/drivers/hdf/frameworks/include/platform/i2c_if.h
--- openharmony/drivers/hdf/frameworks/include/platform/i2c_if.h	2020-10-31 00:28:40.967187251 +0800
+++ openharmony_100ask/drivers/hdf/frameworks/include/platform/i2c_if.h	2020-10-31 00:26:45.586078398 +0800
@@ -60,6 +60,16 @@
 #endif
 #endif /* __cplusplus */
 
+typedef struct {
+    unsigned short busNum;
+    unsigned short addr;
+} I2cConfig;
+
+typedef struct {
+    struct DevHandle *i2cHandle;
+    I2cConfig i2cCfg;
+} InputI2cClient;
+
 /**
  * @brief Defines the I2C transfer message used during custom transfers.
  *
@@ -159,6 +169,10 @@
  */
 int32_t I2cTransfer(struct DevHandle *handle, struct I2cMsg *msgs, int16_t count);
 
+int InputI2cRead(const InputI2cClient *client, unsigned int regAddr, unsigned int regLen, unsigned char *regData,
+	unsigned int dataLen);
+int InputI2cWrite(const InputI2cClient *client, unsigned char *writeData, unsigned int len);
+
 #ifdef __cplusplus
 #if __cplusplus
 }
diff -urN -x .git -x .repo openharmony/drivers/hdf/frameworks/support/platform/src/i2c_if.c openharmony_100ask/drivers/hdf/frameworks/support/platform/src/i2c_if.c
--- openharmony/drivers/hdf/frameworks/support/platform/src/i2c_if.c	2020-10-31 00:28:40.979186962 +0800
+++ openharmony_100ask/drivers/hdf/frameworks/support/platform/src/i2c_if.c	2020-10-31 00:26:45.590078292 +0800
@@ -42,6 +42,14 @@
 #define SERVICE_NAME_LEN 32
 #define I2C_BUS_MAX 8
 
+#define I2C_READ_MSG_NUM   2
+#define I2C_WRITE_MSG_NUM  1
+#define I2C_REG_BUF_LEN    4
+#define I2C_BYTE_MASK      0xFF
+#define I2C_BYTE_OFFSET    8
+
+
+
 static struct I2cCntlr *I2cCntlrGetByNumber(int16_t num)
 {
     struct I2cCntlr *cntlr = NULL;
@@ -102,3 +110,53 @@
 
     return I2cCntlrTransfer((struct I2cCntlr *)handle->object, msgs, count);
 }
+
+int InputI2cRead(const InputI2cClient *client, unsigned int regAddr, unsigned int regLen, unsigned char *regData,
+    unsigned int dataLen)
+{
+    int index = 0;
+    unsigned char regBuf[I2C_REG_BUF_LEN] = {0};
+    struct I2cMsg msg[I2C_READ_MSG_NUM];
+    (void)memset_s(msg, sizeof(msg), 0, sizeof(msg)); 
+
+    msg[0].addr = client->i2cCfg.addr;
+    msg[0].flags = 0;
+    msg[0].len = regLen;
+    msg[0].buf = regBuf;
+
+    if (regLen == 1) {
+        regBuf[index++] = regAddr & I2C_BYTE_MASK;
+    } else {
+        regBuf[index++] = (regAddr >> I2C_BYTE_OFFSET) & I2C_BYTE_MASK;
+        regBuf[index++] = regAddr & I2C_BYTE_MASK;
+    }
+
+    msg[1].addr = client->i2cCfg.addr;
+    msg[1].flags = I2C_FLAG_READ;
+    msg[1].len = dataLen;
+    msg[1].buf = regData;
+
+    if (I2cTransfer(client->i2cHandle, msg, I2C_READ_MSG_NUM) != I2C_READ_MSG_NUM) {
+        HDF_LOGE("%s: i2c read err", __func__);
+        return HDF_FAILURE;
+    }
+    return HDF_SUCCESS;
+}
+
+int InputI2cWrite(const InputI2cClient *client, unsigned char *writeData, unsigned int len)
+{
+    struct I2cMsg msg[I2C_WRITE_MSG_NUM];
+    (void)memset_s(msg, sizeof(msg), 0, sizeof(msg));
+
+    msg[0].addr = client->i2cCfg.addr;
+    msg[0].flags = 0;
+    msg[0].len = len;
+    msg[0].buf = writeData;
+
+    if (I2cTransfer(client->i2cHandle, msg, I2C_WRITE_MSG_NUM) != I2C_WRITE_MSG_NUM) {
+        HDF_LOGE("%s: i2c write err", __func__);
+        return HDF_FAILURE;
+    }
+    return HDF_SUCCESS;
+}
+
diff -urN -x .git -x .repo openharmony/drivers/hdf/lite/hdf_driver.mk openharmony_100ask/drivers/hdf/lite/hdf_driver.mk
--- openharmony/drivers/hdf/lite/hdf_driver.mk	2020-10-31 00:28:40.995186575 +0800
+++ openharmony_100ask/drivers/hdf/lite/hdf_driver.mk	2020-10-31 00:26:45.602077980 +0800
@@ -20,8 +20,14 @@
 endif
 
 ifeq ($(LOCAL_HCS_ROOT),)
+ifeq ($(LOSCFG_PLATFORM_IMX6ULL),y)
+LOCAL_HCS_ROOT := vendor/nxp
+else ifeq ($(LOSCFG_PLATFORM_STM32MP157), y)
+LOCAL_HCS_ROOT := vendor/st
+else
 LOCAL_HCS_ROOT := vendor/hisi/hi35xx
 endif
+endif
 
 HC_GEN := hc-gen
 BUILD_IN_HC_GEN := $(LITEOSTOPDIR)/../../prebuilts/build-tools/$(HCGEN_PATH)
diff -urN -x .git -x .repo openharmony/drivers/hdf/lite/hdf_lite.mk openharmony_100ask/drivers/hdf/lite/hdf_lite.mk
--- openharmony/drivers/hdf/lite/hdf_lite.mk	2020-10-31 00:28:40.995186575 +0800
+++ openharmony_100ask/drivers/hdf/lite/hdf_lite.mk	2020-10-31 00:26:45.630077250 +0800
@@ -36,7 +36,17 @@
 endif
 
 # vendor lib
+ifeq ($(findstring y, $(LOSCFG_PLATFORM_HI3518EV300)$(LOSCFG_PLATFORM_HI3516DV300)), y)
 include $(LITEOSTOPDIR)/../../vendor/huawei/hdf/hdf_vendor.mk
+endif
+
+ifeq ($(LOSCFG_PLATFORM_IMX6ULL), y)
+include $(LITEOSTOPDIR)/../../vendor/nxp/hdf/hdf_vendor.mk
+endif
+
+ifeq ($(LOSCFG_PLATFORM_STM32MP157), y)
+include $(LITEOSTOPDIR)/../../vendor/st/hdf/hdf_vendor.mk
+endif
 
     LITEOS_BASELIB += --no-whole-archive
 endif
diff -urN -x .git -x .repo openharmony/drivers/hdf/lite/manager/BUILD.gn openharmony_100ask/drivers/hdf/lite/manager/BUILD.gn
--- openharmony/drivers/hdf/lite/manager/BUILD.gn	2020-10-31 00:28:40.999186479 +0800
+++ openharmony_100ask/drivers/hdf/lite/manager/BUILD.gn	2020-10-31 00:26:45.666076312 +0800
@@ -55,8 +55,48 @@
     ]
 }
 
+executable("hello_test") {
+    sources = [
+        "//myapp/hello_test.c"
+    ]
+
+    include_dirs = [
+        "../adapter/syscall/include",
+        "../adapter/vnode/include","$HDF_FRAMEWORKS/ability/sbuf/include",
+        "$HDF_FRAMEWORKS/core/shared/include",
+        "$HDF_FRAMEWORKS/core/host/include",
+        "$HDF_FRAMEWORKS/core/master/include",
+        "$HDF_FRAMEWORKS/include/core",
+        "$HDF_FRAMEWORKS/include/utils",
+        "$HDF_FRAMEWORKS/utils/include",
+        "$HDF_FRAMEWORKS/include/osal",
+        "//third_party/bounds_checking_function/include",
+    ]
+
+    deps = [
+        "//drivers/hdf/lite/manager:hdf_core",
+        "//drivers/hdf/lite/adapter/osal/posix:hdf_posix_osal",
+    ]
+
+    public_deps = [
+        "//third_party/bounds_checking_function:libsec_shared",
+    ]
+    defines = [
+        "__USER__",
+    ]
+
+    cflags = [
+        "-Wall",
+        "-Wextra",
+        "-Werror",
+    ]
+}
+
+
+
 lite_component("hdf_manager") {
     features = [
         ":hdf_core",
+        ":hello_test",
     ]
 }
diff -urN -x .git -x .repo openharmony/drivers/hdf/lite/manager/src/lite_driver_loader.c openharmony_100ask/drivers/hdf/lite/manager/src/lite_driver_loader.c
--- openharmony/drivers/hdf/lite/manager/src/lite_driver_loader.c	2020-10-31 00:28:40.999186479 +0800
+++ openharmony_100ask/drivers/hdf/lite/manager/src/lite_driver_loader.c	2020-10-31 00:26:45.662076417 +0800
@@ -28,6 +28,7 @@
 
     for (int i = 0; i < count; i++) {
         struct HdfDriverEntry *driverEntry = (struct HdfDriverEntry *)(*addrBegin);
+		HDF_LOGE("cmp %s %s\n", deviceInfo->moduleName, driverEntry->moduleName);
         if (strcmp(deviceInfo->moduleName, driverEntry->moduleName) == 0) {
             return driverEntry;
         }
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/arch/arm/arm/src/startup/reset_vector_up.S openharmony_100ask/kernel/liteos_a/arch/arm/arm/src/startup/reset_vector_up.S
--- openharmony/kernel/liteos_a/arch/arm/arm/src/startup/reset_vector_up.S	2020-10-31 00:28:41.783167564 +0800
+++ openharmony_100ask/kernel/liteos_a/arch/arm/arm/src/startup/reset_vector_up.S	2020-10-31 00:26:50.001963534 +0800
@@ -113,11 +113,37 @@
     .global reset_vector
     .type   reset_vector,function
 reset_vector:
+#if defined(LOSCFG_PLATFORM_STM32MP157)
+	ldr sp, =0xc0000000 + 0x1000000
+	mov r0, #'S'
+	bl uart_putc_phy
+#endif
+#if 1
+	/*
+	 * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,
+	 * except if in HYP mode already
+	 */
+	mrs	r0, cpsr
+	and	r1, r0, #0x1f		@ mask mode bits
+	teq	r1, #0x1a		@ test for HYP mode
+	bicne	r0, r0, #0x1f		@ clear all mode bits
+	orrne	r0, r0, #0x13		@ set SVC mode
+	orr	r0, r0, #0xc0		@ disable FIQ and IRQ
+	msr	cpsr,r0
+
+	/*
+	 * If I-cache is enabled invalidate it 
+	 */
+	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
+	mcr     p15, 0, r0, c7, c10, 4	@ DSB
+	mcr     p15, 0, r0, c7, c5, 4	@ ISB
+
     /* do some early cpu setup: i/d cache disable, mmu disabled */
-    mrc     p15, 0, r0, c1, c0, 0
-    bic     r0, #(1<<12)
-    bic     r0, #(1<<2 | 1<<0)
-    mcr     p15, 0, r0, c1, c0, 0
+//    mrc     p15, 0, r0, c1, c0, 0
+//    bic     r0, #(1<<12)
+//    bic     r0, #(1<<2 | 1<<0)
+//    mcr     p15, 0, r0, c1, c0, 0
+#endif
 
     /* r11: delta of physical address and virtual address */
     adr     r11, pa_va_offset
@@ -129,7 +155,10 @@
     ldr     r5, =SYS_MEM_BASE                   /* r5: base of physical address */
     subs    r12, r4, r5                         /* r12: delta of load address and physical address */
     beq     reloc_img_to_bottom_done            /* if we load image at the bottom of physical address */
-
+#if defined(LOSCFG_PLATFORM_STM32MP157)
+	mov r0, #'R'
+	bl uart_putc_phy
+#endif
     /* we need to relocate image at the bottom of physical address */
     ldr     r7, =__exception_handlers           /* r7: base of linked address (or vm address) */
     ldr     r6, =__bss_start                    /* r6: end of linked address (or vm address) */
@@ -146,15 +175,26 @@
     sub     r11, r11, r12                       /* r11: eventual address offset */
 
 reloc_img_to_bottom_done:
+#if defined(LOSCFG_PLATFORM_STM32MP157)
+	mov r0, #'D'
+	bl uart_putc_phy
+#endif
     ldr     r4, =g_firstPageTable               /* r4: physical address of translation table and clear it */
     add     r4, r4, r11
     bl      page_table_clear
 
-    PAGE_TABLE_SET SYS_MEM_BASE, KERNEL_VMM_BASE, KERNEL_VMM_SIZE, MMU_DESCRIPTOR_KERNEL_L1_PTE_FLAGS
     PAGE_TABLE_SET SYS_MEM_BASE, UNCACHED_VMM_BASE, UNCACHED_VMM_SIZE, MMU_INITIAL_MAP_STRONGLY_ORDERED
+#if defined(LOSCFG_PLATFORM_IMX6ULL) || defined(LOSCFG_PLATFORM_STM32MP157)
+    PAGE_TABLE_SET DDR_RAMFS_ADDR, DDR_RAMFS_VBASE, DDR_RAMFS_SIZE, MMU_INITIAL_MAP_DEVICE
+    PAGE_TABLE_SET LCD_FB_BASE, LCD_FB_VBASE, LCD_FB_SIZE, MMU_INITIAL_MAP_DEVICE
+#endif
+    PAGE_TABLE_SET SYS_MEM_BASE, KERNEL_VMM_BASE, KERNEL_VMM_SIZE, MMU_DESCRIPTOR_KERNEL_L1_PTE_FLAGS
     PAGE_TABLE_SET PERIPH_PMM_BASE, PERIPH_DEVICE_BASE, PERIPH_DEVICE_SIZE, MMU_INITIAL_MAP_DEVICE
     PAGE_TABLE_SET PERIPH_PMM_BASE, PERIPH_CACHED_BASE, PERIPH_CACHED_SIZE, MMU_DESCRIPTOR_KERNEL_L1_PTE_FLAGS
     PAGE_TABLE_SET PERIPH_PMM_BASE, PERIPH_UNCACHED_BASE, PERIPH_UNCACHED_SIZE, MMU_INITIAL_MAP_STRONGLY_ORDERED
+#if defined(LOSCFG_PLATFORM_STM32MP157)
+    PAGE_TABLE_SET GIC_PHY_BASE, GIC_VIRT_BASE, GIC_VIRT_SIZE, MMU_INITIAL_MAP_DEVICE
+#endif
 
     orr     r8, r4, #MMU_TTBRx_FLAGS            /* r8 = r4 and set cacheable attributes on translation walk */
     ldr     r4, =g_mmuJumpPageTable             /* r4: jump pagetable vaddr */
@@ -174,7 +214,10 @@
     str     r12, [r4, r7, lsr #(20 - 2)]        /* jumpTable[vaIndex] = pt entry */
 
     bl      mmu_setup                           /* set up the mmu */
-
+#if defined(LOSCFG_PLATFORM_STM32MP157)
+    mov r0, #'M'
+    bl uart_putc_virt
+#endif
     /* get cpuid and keep it in r11 */
     mrc     p15, 0, r11, c0, c0, 5
     and     r11, r11, #MPIDR_CPUID_MASK
@@ -226,7 +269,8 @@
     mul    r2, r2, r11
     sub    r0, r0, r2
     mov    sp, r0
-
+    
+#ifndef  LOSCFG_PLATFORM_STM32MP157
     /* enable fpu+neon */
     MRC    p15, 0, r0, c1, c1, 2
     ORR    r0, r0, #0xC00
@@ -235,6 +279,7 @@
 
     LDR    r0, =(0xF << 20)
     MCR    p15, 0, r0, c1, c0, 2
+#endif    
 
     MOV    r3, #0x40000000
     VMSR   FPEXC, r3
@@ -266,6 +311,10 @@
     bl     GDB_START
     .word  0xe7ffdeff
 #endif
+#if defined(LOSCFG_PLATFORM_STM32MP157)
+	mov r0, 'm'
+	bl uart_putc_virt
+#endif
 
     bl     main
 
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/.config openharmony_100ask/kernel/liteos_a/.config
--- openharmony/kernel/liteos_a/.config	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/kernel/liteos_a/.config	2020-10-31 00:26:49.793968937 +0800
@@ -0,0 +1,161 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Huawei LiteOS Configuration
+#
+
+#
+# Compiler
+#
+# LOSCFG_COMPILER_HIMIX_32 is not set
+LOSCFG_COMPILER_CLANG_LLVM=y
+
+#
+# Platform
+#
+LOSCFG_PLATFORM="stm32mp157"
+# LOSCFG_PLATFORM_HI3516DV300 is not set
+# LOSCFG_PLATFORM_HI3518EV300 is not set
+LOSCFG_PLATFORM_STM32MP157=y
+# LOSCFG_PLATFORM_IMX6ULL is not set
+LOSCFG_PLATFORM_BSP_GIC_V2=y
+LOSCFG_ARCH_ARM=y
+LOSCFG_ARCH_ARM_AARCH32=y
+LOSCFG_ARCH_ARM_V7A=y
+LOSCFG_ARCH_ARM_VER="armv7-a"
+LOSCFG_ARCH_FPU_VFP_V4=y
+LOSCFG_ARCH_FPU_VFP_D32=y
+LOSCFG_ARCH_FPU_VFP_NEON=y
+LOSCFG_ARCH_FPU="neon-vfpv4"
+LOSCFG_ARCH_CORTEX_A7=y
+LOSCFG_ARCH_CPU="cortex-a7"
+
+#
+# Extra Configurations
+#
+# LOSCFG_ARCH_FPU_DISABLE is not set
+LOSCFG_IRQ_USE_STANDALONE_STACK=y
+LOSCFG_PLATFORM_ROOTFS=y
+
+#
+# Kernel
+#
+# LOSCFG_KERNEL_SMP is not set
+LOSCFG_KERNEL_EXTKERNEL=y
+LOSCFG_KERNEL_CPPSUPPORT=y
+LOSCFG_KERNEL_CPUP=y
+LOSCFG_CPUP_INCLUDE_IRQ=y
+LOSCFG_KERNEL_DYNLOAD=y
+LOSCFG_KERNEL_VDSO=y
+LOSCFG_KERNEL_TICKLESS=y
+# LOSCFG_KERNEL_TRACE is not set
+LOSCFG_KERNEL_LITEIPC=y
+LOSCFG_KERNEL_PIPE=y
+LOSCFG_BASE_CORE_HILOG=y
+
+#
+# Lib
+#
+LOSCFG_LIB_LIBC=y
+LOSCFG_LIB_ZLIB=y
+
+#
+# Compat
+#
+LOSCFG_COMPAT_POSIX=y
+LOSCFG_COMPAT_BSD=y
+
+#
+# FileSystem
+#
+LOSCFG_FS_VFS=y
+LOSCFG_FS_VFS_BLOCK_DEVICE=y
+LOSCFG_FILE_MODE=y
+LOSCFG_FS_FAT=y
+LOSCFG_FS_FAT_CACHE=y
+LOSCFG_FS_FAT_CACHE_SYNC_THREAD=y
+LOSCFG_FS_FAT_CHINESE=y
+LOSCFG_FS_FAT_VIRTUAL_PARTITION=y
+LOSCFG_FS_FAT_VOLUMES=16
+LOSCFG_FS_FAT_DISK=y
+LOSCFG_FS_RAMFS=y
+LOSCFG_FS_NFS=y
+LOSCFG_FS_PROC=y
+LOSCFG_FS_JFFS=y
+
+#
+# Net
+#
+LOSCFG_NET_LWIP_SACK=y
+LOSCFG_NET_LWIP_SACK_2_1=y
+
+#
+# Debug
+#
+# LOSCFG_COMPILE_DEBUG is not set
+LOSCFG_PLATFORM_ADAPT=y
+LOSCFG_ENABLE_OOM_LOOP_TASK=y
+LOSCFG_ENABLE_MAGICKEY=y
+# LOSCFG_THUMB is not set
+LOSCFG_DEBUG_VERSION=y
+# LOSCFG_DEBUG_KERNEL is not set
+LOSCFG_SHELL=y
+
+#
+# Functionality of Shell
+#
+LOSCFG_SHELL_LK=y
+LOSCFG_SHELL_DMESG=y
+# LOSCFG_SHELL_EXCINFO is not set
+LOSCFG_NET_LWIP_SACK_TFTP=y
+LOSCFG_NET_TELNET=y
+# LOSCFG_EXC_INTERACTION is not set
+LOSCFG_USER_INIT_DEBUG=y
+LOSCFG_SHELL_CMD_DEBUG=y
+# LOSCFG_MEM_DEBUG is not set
+LOSCFG_NULL_ADDRESS_PROTECT=y
+LOSCFG_DRIVERS_HDF_PLATFORM_UART=y
+# LOSCFG_PLATFORM_UART_WITHOUT_VFS is not set
+# LOSCFG_PLATFORM_NO_UART is not set
+
+#
+# Driver
+#
+LOSCFG_DRIVERS=y
+# LOSCFG_DRIVERS_USB is not set
+LOSCFG_DRIVERS_HDF=y
+LOSCFG_DRIVERS_HDF_PLATFORM=y
+LOSCFG_DRIVERS_HDF_PLATFORM_I2C=y
+# LOSCFG_DRIVERS_HDF_PLATFORM_SPI is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_GPIO is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_WATCHDOG is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_SDIO is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_RTC is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_HISI_SDK is not set
+# LOSCFG_DRIVERS_HDF_WIFI is not set
+# LOSCFG_DRIVERS_HDF_INPUT is not set
+# LOSCFG_DRIVERS_HDF_LCD is not set
+# LOSCFG_DRIVERS_HDF_USB is not set
+# LOSCFG_DRIVERS_NETDEV is not set
+LOSCFG_DRIVERS_MEM=y
+# LOSCFG_DRIVERS_MMC is not set
+LOSCFG_DRIVERS_MTD=y
+# LOSCFG_DRIVERS_MTD_SPI_NOR is not set
+# LOSCFG_DRIVERS_RANDOM is not set
+# LOSCFG_DRIVERS_VIDEO is not set
+LOSCFG_DRIVERS_HIEVENT=y
+
+#
+# Security
+#
+LOSCFG_SECURITY=y
+LOSCFG_SECURITY_CAPABILITY=y
+LOSCFG_SECURITY_VID=y
+# LOSCFG_SECURITY_BOOT is not set
+
+#
+# Stack Smashing Protector (SSP) Compiler Feature
+#
+# LOSCFG_CC_NO_STACKPROTECTOR is not set
+# LOSCFG_CC_STACKPROTECTOR is not set
+LOSCFG_CC_STACKPROTECTOR_STRONG=y
+# LOSCFG_CC_STACKPROTECTOR_ALL is not set
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/.config.old openharmony_100ask/kernel/liteos_a/.config.old
--- openharmony/kernel/liteos_a/.config.old	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/kernel/liteos_a/.config.old	2020-10-31 00:26:49.957964677 +0800
@@ -0,0 +1,160 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Huawei LiteOS Configuration
+#
+
+#
+# Compiler
+#
+# LOSCFG_COMPILER_HIMIX_32 is not set
+LOSCFG_COMPILER_CLANG_LLVM=y
+
+#
+# Platform
+#
+LOSCFG_PLATFORM="imx6ull"
+# LOSCFG_PLATFORM_HI3516DV300 is not set
+# LOSCFG_PLATFORM_HI3518EV300 is not set
+LOSCFG_PLATFORM_IMX6ULL=y
+LOSCFG_PLATFORM_BSP_GIC_V2=y
+LOSCFG_ARCH_ARM=y
+LOSCFG_ARCH_ARM_AARCH32=y
+LOSCFG_ARCH_ARM_V7A=y
+LOSCFG_ARCH_ARM_VER="armv7-a"
+LOSCFG_ARCH_FPU_VFP_V4=y
+LOSCFG_ARCH_FPU_VFP_D32=y
+LOSCFG_ARCH_FPU_VFP_NEON=y
+LOSCFG_ARCH_FPU="neon-vfpv4"
+LOSCFG_ARCH_CORTEX_A7=y
+LOSCFG_ARCH_CPU="cortex-a7"
+
+#
+# Extra Configurations
+#
+# LOSCFG_ARCH_FPU_DISABLE is not set
+LOSCFG_IRQ_USE_STANDALONE_STACK=y
+LOSCFG_PLATFORM_ROOTFS=y
+
+#
+# Kernel
+#
+# LOSCFG_KERNEL_SMP is not set
+LOSCFG_KERNEL_EXTKERNEL=y
+LOSCFG_KERNEL_CPPSUPPORT=y
+LOSCFG_KERNEL_CPUP=y
+LOSCFG_CPUP_INCLUDE_IRQ=y
+LOSCFG_KERNEL_DYNLOAD=y
+LOSCFG_KERNEL_VDSO=y
+LOSCFG_KERNEL_TICKLESS=y
+# LOSCFG_KERNEL_TRACE is not set
+LOSCFG_KERNEL_LITEIPC=y
+LOSCFG_KERNEL_PIPE=y
+LOSCFG_BASE_CORE_HILOG=y
+
+#
+# Lib
+#
+LOSCFG_LIB_LIBC=y
+LOSCFG_LIB_ZLIB=y
+
+#
+# Compat
+#
+LOSCFG_COMPAT_POSIX=y
+LOSCFG_COMPAT_BSD=y
+
+#
+# FileSystem
+#
+LOSCFG_FS_VFS=y
+LOSCFG_FS_VFS_BLOCK_DEVICE=y
+LOSCFG_FILE_MODE=y
+LOSCFG_FS_FAT=y
+LOSCFG_FS_FAT_CACHE=y
+LOSCFG_FS_FAT_CACHE_SYNC_THREAD=y
+LOSCFG_FS_FAT_CHINESE=y
+LOSCFG_FS_FAT_VIRTUAL_PARTITION=y
+LOSCFG_FS_FAT_VOLUMES=16
+LOSCFG_FS_FAT_DISK=y
+LOSCFG_FS_RAMFS=y
+LOSCFG_FS_NFS=y
+LOSCFG_FS_PROC=y
+LOSCFG_FS_JFFS=y
+
+#
+# Net
+#
+LOSCFG_NET_LWIP_SACK=y
+LOSCFG_NET_LWIP_SACK_2_1=y
+
+#
+# Debug
+#
+# LOSCFG_COMPILE_DEBUG is not set
+LOSCFG_PLATFORM_ADAPT=y
+LOSCFG_ENABLE_OOM_LOOP_TASK=y
+LOSCFG_ENABLE_MAGICKEY=y
+# LOSCFG_THUMB is not set
+LOSCFG_DEBUG_VERSION=y
+# LOSCFG_DEBUG_KERNEL is not set
+LOSCFG_SHELL=y
+
+#
+# Functionality of Shell
+#
+LOSCFG_SHELL_LK=y
+LOSCFG_SHELL_DMESG=y
+# LOSCFG_SHELL_EXCINFO is not set
+LOSCFG_NET_LWIP_SACK_TFTP=y
+LOSCFG_NET_TELNET=y
+# LOSCFG_EXC_INTERACTION is not set
+LOSCFG_USER_INIT_DEBUG=y
+LOSCFG_SHELL_CMD_DEBUG=y
+# LOSCFG_MEM_DEBUG is not set
+LOSCFG_NULL_ADDRESS_PROTECT=y
+LOSCFG_DRIVERS_HDF_PLATFORM_UART=y
+# LOSCFG_PLATFORM_UART_WITHOUT_VFS is not set
+# LOSCFG_PLATFORM_NO_UART is not set
+
+#
+# Driver
+#
+LOSCFG_DRIVERS=y
+# LOSCFG_DRIVERS_USB is not set
+LOSCFG_DRIVERS_HDF=y
+LOSCFG_DRIVERS_HDF_PLATFORM=y
+LOSCFG_DRIVERS_HDF_PLATFORM_I2C=y
+# LOSCFG_DRIVERS_HDF_PLATFORM_SPI is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_GPIO is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_WATCHDOG is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_SDIO is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_RTC is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_HISI_SDK is not set
+# LOSCFG_DRIVERS_HDF_WIFI is not set
+# LOSCFG_DRIVERS_HDF_INPUT is not set
+# LOSCFG_DRIVERS_HDF_LCD is not set
+# LOSCFG_DRIVERS_HDF_USB is not set
+# LOSCFG_DRIVERS_NETDEV is not set
+LOSCFG_DRIVERS_MEM=y
+# LOSCFG_DRIVERS_MMC is not set
+LOSCFG_DRIVERS_MTD=y
+# LOSCFG_DRIVERS_MTD_SPI_NOR is not set
+# LOSCFG_DRIVERS_RANDOM is not set
+LOSCFG_DRIVERS_VIDEO=y
+LOSCFG_DRIVERS_HIEVENT=y
+
+#
+# Security
+#
+LOSCFG_SECURITY=y
+LOSCFG_SECURITY_CAPABILITY=y
+LOSCFG_SECURITY_VID=y
+# LOSCFG_SECURITY_BOOT is not set
+
+#
+# Stack Smashing Protector (SSP) Compiler Feature
+#
+# LOSCFG_CC_NO_STACKPROTECTOR is not set
+# LOSCFG_CC_STACKPROTECTOR is not set
+LOSCFG_CC_STACKPROTECTOR_STRONG=y
+# LOSCFG_CC_STACKPROTECTOR_ALL is not set
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/fs/vfs/include/driver/mtd_dev.h openharmony_100ask/kernel/liteos_a/fs/vfs/include/driver/mtd_dev.h
--- openharmony/kernel/liteos_a/fs/vfs/include/driver/mtd_dev.h	2020-10-31 00:28:41.791167372 +0800
+++ openharmony_100ask/kernel/liteos_a/fs/vfs/include/driver/mtd_dev.h	2020-10-31 00:26:55.033833089 +0800
@@ -52,7 +52,7 @@
     UINT32 eraseSize;
 
     int (*erase)(struct MtdDev *mtd, UINT64 start, UINT64 len, UINT64 *failAddr);
-    int (*read)(struct MtdDev *mtd, UINT64 start, UINT64 len, const char *buf);
+    int (*read)(struct MtdDev *mtd, UINT64 start, UINT64 len, char *buf);
     int (*write)(struct MtdDev *mtd, UINT64 start, UINT64 len, const char *buf);
 };
 
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/include/config/auto.conf openharmony_100ask/kernel/liteos_a/include/config/auto.conf
--- openharmony/kernel/liteos_a/include/config/auto.conf	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/kernel/liteos_a/include/config/auto.conf	2020-10-31 00:26:49.965964469 +0800
@@ -0,0 +1,74 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Huawei LiteOS Configuration
+#
+LOSCFG_KERNEL_LITEIPC=y
+LOSCFG_SECURITY_CAPABILITY=y
+LOSCFG_NET_LWIP_SACK=y
+LOSCFG_DRIVERS_HDF_PLATFORM_I2C=y
+LOSCFG_NET_LWIP_SACK_TFTP=y
+LOSCFG_FS_FAT_VIRTUAL_PARTITION=y
+LOSCFG_FS_FAT_VOLUMES=16
+LOSCFG_SHELL_CMD_DEBUG=y
+LOSCFG_ENABLE_MAGICKEY=y
+LOSCFG_NULL_ADDRESS_PROTECT=y
+LOSCFG_DRIVERS=y
+LOSCFG_PLATFORM_ADAPT=y
+LOSCFG_KERNEL_PIPE=y
+LOSCFG_DRIVERS_MEM=y
+LOSCFG_CC_STACKPROTECTOR_STRONG=y
+LOSCFG_PLATFORM_STM32MP157=y
+LOSCFG_COMPILER_CLANG_LLVM=y
+LOSCFG_DRIVERS_HDF=y
+LOSCFG_BASE_CORE_HILOG=y
+LOSCFG_NET_TELNET=y
+LOSCFG_NET_LWIP_SACK_2_1=y
+LOSCFG_FS_VFS=y
+LOSCFG_KERNEL_DYNLOAD=y
+LOSCFG_COMPAT_POSIX=y
+LOSCFG_KERNEL_VDSO=y
+LOSCFG_DEBUG_VERSION=y
+LOSCFG_COMPAT_BSD=y
+LOSCFG_FILE_MODE=y
+LOSCFG_PLATFORM="stm32mp157"
+LOSCFG_PLATFORM_BSP_GIC_V2=y
+LOSCFG_PLATFORM_ROOTFS=y
+LOSCFG_KERNEL_CPPSUPPORT=y
+LOSCFG_ARCH_CORTEX_A7=y
+LOSCFG_DRIVERS_HDF_PLATFORM_UART=y
+LOSCFG_FS_FAT=y
+LOSCFG_FS_NFS=y
+LOSCFG_ARCH_ARM_VER="armv7-a"
+LOSCFG_FS_FAT_DISK=y
+LOSCFG_IRQ_USE_STANDALONE_STACK=y
+LOSCFG_ENABLE_OOM_LOOP_TASK=y
+LOSCFG_ARCH_ARM_AARCH32=y
+LOSCFG_KERNEL_EXTKERNEL=y
+LOSCFG_KERNEL_TICKLESS=y
+LOSCFG_DRIVERS_HDF_PLATFORM=y
+LOSCFG_FS_PROC=y
+LOSCFG_ARCH_CPU="cortex-a7"
+LOSCFG_ARCH_ARM_V7A=y
+LOSCFG_LIB_ZLIB=y
+LOSCFG_SECURITY_VID=y
+LOSCFG_ARCH_FPU="neon-vfpv4"
+LOSCFG_DRIVERS_MTD=y
+LOSCFG_ARCH_FPU_VFP_D32=y
+LOSCFG_USER_INIT_DEBUG=y
+LOSCFG_FS_FAT_CACHE_SYNC_THREAD=y
+LOSCFG_SHELL_LK=y
+LOSCFG_ARCH_ARM=y
+LOSCFG_FS_JFFS=y
+LOSCFG_DRIVERS_HIEVENT=y
+LOSCFG_ARCH_FPU_VFP_NEON=y
+LOSCFG_SHELL=y
+LOSCFG_CPUP_INCLUDE_IRQ=y
+LOSCFG_FS_FAT_CACHE=y
+LOSCFG_SHELL_DMESG=y
+LOSCFG_SECURITY=y
+LOSCFG_FS_VFS_BLOCK_DEVICE=y
+LOSCFG_FS_RAMFS=y
+LOSCFG_LIB_LIBC=y
+LOSCFG_FS_FAT_CHINESE=y
+LOSCFG_KERNEL_CPUP=y
+LOSCFG_ARCH_FPU_VFP_V4=y
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/include/config/auto.conf.cmd openharmony_100ask/kernel/liteos_a/include/config/auto.conf.cmd
--- openharmony/kernel/liteos_a/include/config/auto.conf.cmd	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/kernel/liteos_a/include/config/auto.conf.cmd	2020-10-31 00:26:49.969964365 +0800
@@ -0,0 +1,51 @@
+deps_config := \
+	../../kernel/liteos_a/security/Kconfig \
+	../../drivers/liteos/hievent/Kconfig \
+	../../drivers/liteos/video/Kconfig \
+	../../drivers/liteos/tzdriver/Kconfig \
+	../../drivers/liteos/random/Kconfig \
+	../../vendor/hisi/hi35xx/platform/mtd/spi_nor/Kconfig \
+	../../vendor/hisi/hi35xx/platform/mmc/Kconfig \
+	../../drivers/liteos/mem/Kconfig \
+	../../vendor/hisi/hi35xx/platform/hieth-sf/Kconfig \
+	../../drivers/hdf/lite/model/bus/usb/Kconfig \
+	../../vendor/huawei/hdf/display/driver/Kconfig \
+	../../vendor/huawei/hdf/input/driver/Kconfig \
+	../../vendor/huawei/hdf/wifi/driver/Kconfig \
+	../../vendor/hisi/hi35xx/platform/hisi_sdk/Kconfig \
+	../../vendor/hisi/hi35xx/platform/rtc/Kconfig \
+	../../vendor/hisi/hi35xx/platform/sdio/Kconfig \
+	../../vendor/hisi/hi35xx/platform/watchdog/Kconfig \
+	../../vendor/hisi/hi35xx/platform/gpio/Kconfig \
+	../../vendor/hisi/hi35xx/platform/spi/Kconfig \
+	../../vendor/hisi/hi35xx/platform/i2c/Kconfig \
+	../../vendor/hisi/hi35xx/platform/Kconfig \
+	../../vendor/huawei/hdf/Kconfig \
+	../../drivers/hdf/lite/Kconfig \
+	../../kernel/liteos_a/bsd/dev/usb/Kconfig \
+	../../vendor/hisi/hi35xx/platform/hiedmac/Kconfig \
+	../../vendor/hisi/hi35xx/platform/uart/Kconfig \
+	../../kernel/liteos_a/net/telnet/Kconfig \
+	../../kernel/liteos_a/shell/Kconfig \
+	../../kernel/liteos_a/net/Kconfig \
+	../../kernel/liteos_a/fs/jffs2/Kconfig \
+	../../kernel/liteos_a/fs/proc/Kconfig \
+	../../kernel/liteos_a/fs/nfs/Kconfig \
+	../../kernel/liteos_a/fs/ramfs/Kconfig \
+	../../kernel/liteos_a/fs/fat/Kconfig \
+	../../kernel/liteos_a/fs/vfs/Kconfig \
+	../../kernel/liteos_a/bsd/Kconfig \
+	../../kernel/liteos_a/compat/posix/Kconfig \
+	../../kernel/liteos_a/lib/Kconfig \
+	../../kernel/liteos_a/kernel/Kconfig \
+	../../kernel/liteos_a/kernel/common/Kconfig \
+	arch/arm/Kconfig \
+	../../kernel/liteos_a/arch/Kconfig \
+	../../kernel/liteos_a/platform/Kconfig \
+	/home/book/openharmony/kernel/liteos_a/Kconfig
+
+include/config/auto.conf: \
+	$(deps_config)
+
+
+$(deps_config): ;
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/include/config/tristate.conf openharmony_100ask/kernel/liteos_a/include/config/tristate.conf
--- openharmony/kernel/liteos_a/include/config/tristate.conf	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/kernel/liteos_a/include/config/tristate.conf	2020-10-31 00:26:49.969964365 +0800
@@ -0,0 +1,4 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Huawei LiteOS Configuration
+#
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/Kconfig openharmony_100ask/kernel/liteos_a/Kconfig
--- openharmony/kernel/liteos_a/Kconfig	2020-10-31 00:28:41.775167758 +0800
+++ openharmony_100ask/kernel/liteos_a/Kconfig	2020-10-31 00:26:49.969964365 +0800
@@ -42,11 +42,11 @@
 
 config COMPILER_HIMIX_32
     bool "arm-linux-ohoseabi"
-    depends on PLATFORM_HI3518EV300 || PLATFORM_HI3516DV300
+    depends on PLATFORM_HI3518EV300 || PLATFORM_HI3516DV300 || PLATFORM_IMX6ULL || PLATFORM_STM32MP157
 
 config COMPILER_CLANG_LLVM
     bool "clang-llvm"
-        depends on PLATFORM_HI3518EV300 || PLATFORM_HI3516DV300
+        depends on PLATFORM_HI3518EV300 || PLATFORM_HI3516DV300 || PLATFORM_IMX6ULL || PLATFORM_STM32MP157
 
 endchoice
 endmenu
@@ -274,7 +274,7 @@
 config NULL_ADDRESS_PROTECT
     bool "Enable NULL Address protect"
     default n
-    depends on (PLATFORM_HI3518EV200 || PLATFORM_HI3516CV300 || PLATFORM_HI3518EV300 || PLATFORM_HI3516DV300) && DEBUG_VERSION
+    depends on (PLATFORM_HI3518EV200 || PLATFORM_HI3516CV300 || PLATFORM_HI3518EV300 || PLATFORM_HI3516DV300 || PLATFORM_IMX6ULL || PLATFORM_STM32MP157) && DEBUG_VERSION
     help
       Answer Y to set mem address 0~1M prohibit to access, read or write will trigger exception.
 
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/kernel/base/include/los_vm_zone.h openharmony_100ask/kernel/liteos_a/kernel/base/include/los_vm_zone.h
--- openharmony/kernel/liteos_a/kernel/base/include/los_vm_zone.h	2020-10-31 00:28:41.795167274 +0800
+++ openharmony_100ask/kernel/liteos_a/kernel/base/include/los_vm_zone.h	2020-10-31 00:26:57.909758741 +0800
@@ -49,8 +49,20 @@
 #define KERNEL_ASPACE_BASE      KERNEL_VMM_BASE
 #define KERNEL_ASPACE_SIZE      KERNEL_VMM_SIZE
 
+#if defined LOSCFG_PLATFORM_IMX6ULL
+#define DDR_RAMFS_VBASE    (KERNEL_VMM_BASE + KERNEL_VMM_SIZE)
+#define LCD_FB_VBASE    (DDR_RAMFS_VBASE + DDR_RAMFS_SIZE)
+#define UNCACHED_VMM_BASE       (LCD_FB_VBASE + LCD_FB_SIZE)
+#define DDR_RAMFS_REAL_SIZE  (0xa00000)
+#elif defined LOSCFG_PLATFORM_STM32MP157
+#define DDR_RAMFS_VBASE    (KERNEL_VMM_BASE + KERNEL_VMM_SIZE)
+#define LCD_FB_VBASE    (DDR_RAMFS_VBASE + DDR_RAMFS_SIZE)
+#define UNCACHED_VMM_BASE       (LCD_FB_VBASE + LCD_FB_SIZE)
+#define DDR_RAMFS_REAL_SIZE  (0xa00000)
+#else
 /* Uncached vmm aspace */
 #define UNCACHED_VMM_BASE       (KERNEL_VMM_BASE + KERNEL_VMM_SIZE)
+#endif
 #define UNCACHED_VMM_SIZE       DDR_MEM_SIZE
 
 #define VMALLOC_START           (UNCACHED_VMM_BASE + UNCACHED_VMM_SIZE)
@@ -63,6 +75,10 @@
 #define PERIPH_UNCACHED_BASE    (PERIPH_CACHED_BASE + PERIPH_CACHED_SIZE)
 #define PERIPH_UNCACHED_SIZE    PERIPH_PMM_SIZE
 
+#define GIC_VIRT_BASE    (PERIPH_UNCACHED_BASE + PERIPH_UNCACHED_SIZE)
+#define GIC_VIRT_SIZE    GIC_PHY_SIZE
+
+
 #define IO_DEVICE_ADDR(paddr)        (paddr - PERIPH_PMM_BASE + PERIPH_DEVICE_BASE)
 #define IO_CACHED_ADDR(paddr)        (paddr - PERIPH_PMM_BASE + PERIPH_CACHED_BASE)
 #define IO_UNCACHED_ADDR(paddr)      (paddr - PERIPH_PMM_BASE + PERIPH_UNCACHED_BASE)
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/kernel/common/los_config.c openharmony_100ask/kernel/liteos_a/kernel/common/los_config.c
--- openharmony/kernel/liteos_a/kernel/common/los_config.c	2020-10-31 00:28:41.799167178 +0800
+++ openharmony_100ask/kernel/liteos_a/kernel/common/los_config.c	2020-10-31 00:27:01.217673412 +0800
@@ -254,6 +254,7 @@
 
 #ifdef LOSCFG_PLATFORM_UART_WITHOUT_VFS
 #ifdef LOSCFG_DRIVERS
+    extern void uart_init(void);
     uart_init();
 #endif
 #ifdef LOSCFG_SHELL
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/kernel/common/los_config.h openharmony_100ask/kernel/liteos_a/kernel/common/los_config.h
--- openharmony/kernel/liteos_a/kernel/common/los_config.h	2020-10-31 00:28:41.799167178 +0800
+++ openharmony_100ask/kernel/liteos_a/kernel/common/los_config.h	2020-10-31 00:27:01.221673309 +0800
@@ -40,7 +40,7 @@
 #include "los_tick.h"
 #include "los_vm_zone.h"
 #include "sys_config.h"
-#include "hisoc/clock.h"
+//#include "hisoc/clock.h"
 
 #ifdef __cplusplus
 #if __cplusplus
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/kernel/common/los_rootfs.c openharmony_100ask/kernel/liteos_a/kernel/common/los_rootfs.c
--- openharmony/kernel/liteos_a/kernel/common/los_rootfs.c	2020-10-31 00:28:41.799167178 +0800
+++ openharmony_100ask/kernel/liteos_a/kernel/common/los_rootfs.c	2020-10-31 00:27:01.233673000 +0800
@@ -197,6 +197,7 @@
     CHAR *tmp = NULL;
     const CHAR *bootargName = "bootargs=";
 
+    (void)ret;
     cmdLine = (CHAR *)malloc(COMMAND_LINE_SIZE);
     if (cmdLine == NULL) {
         PRINT_ERR("Malloc cmdLine space error!\n");
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/kernel/user/src/los_user_init.c openharmony_100ask/kernel/liteos_a/kernel/user/src/los_user_init.c
--- openharmony/kernel/liteos_a/kernel/user/src/los_user_init.c	2020-10-31 00:28:41.803167082 +0800
+++ openharmony_100ask/kernel/liteos_a/kernel/user/src/los_user_init.c	2020-10-31 00:27:01.289671557 +0800
@@ -36,6 +36,7 @@
 
 #ifdef LOSCFG_KERNEL_DYNLOAD
 LITE_USER_SEC_RODATA STATIC CHAR *g_initPath = "/bin/init";
+//LITE_USER_SEC_RODATA STATIC CHAR *g_initPath = "/bin/print_sleep";
 #endif
 
 LITE_USER_SEC_TEXT STATIC UINT32 sys_call3(UINT32 nbr, UINT32 parm1, UINT32 parm2, UINT32 parm3)
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/Makefile openharmony_100ask/kernel/liteos_a/Makefile
--- openharmony/kernel/liteos_a/Makefile	2020-10-31 00:28:41.775167758 +0800
+++ openharmony_100ask/kernel/liteos_a/Makefile	2020-10-31 00:26:49.817968313 +0800
@@ -59,6 +59,13 @@
 ifeq ($(LOSCFG_PLATFORM_HI3516DV300), y)
 FSTYPE = vfat
 endif
+ifeq ($(LOSCFG_PLATFORM_IMX6ULL), y)
+FSTYPE = jffs2
+endif
+ifeq ($(LOSCFG_PLATFORM_STM32MP157), y)
+FSTYPE = jffs2
+ROOTFS_SIZE = 0xA00000
+endif
 ROOTFS_DIR = $(OUT)/rootfs
 ROOTFS_ZIP = $(OUT)/rootfs.zip
 VERSION =
@@ -101,9 +108,17 @@
 ##### make lib #####
 $(__LIBS): $(OUT) $(CXX_INCLUDE)
 
+ifeq ($(LOSCFG_PLATFORM_IMX6ULL),y)
+BOARD_INCLUDE_DIR := $(LITEOSTOPDIR)/../../vendor/nxp/imx6ull/board
+else ifeq ($(LOSCFG_PLATFORM_STM32MP157), y)
+BOARD_INCLUDE_DIR := $(LITEOSTOPDIR)/../../vendor/st/stm32mp157/board
+else
+BOARD_INCLUDE_DIR := $(LITEOSTOPDIR)/../../vendor/hisi/hi35xx/$(LITEOS_PLATFORM)/config/board
+endif
+
 $(OUT): $(LITEOS_MENUCONFIG_H)
 	$(HIDE)mkdir -p $(OUT)/lib
-	$(HIDE)$(CC) -I$(LITEOS_PLATFORM_BASE)/include -I$(LITEOSTOPDIR)/../../vendor/hisi/hi35xx/$(LITEOS_PLATFORM)/config/board \
+	$(HIDE)$(CC) -I$(LITEOS_PLATFORM_BASE)/include -I$(BOARD_INCLUDE_DIR) \
 		-E $(LITEOS_PLATFORM_BASE)/board.ld.S \
 		-o $(LITEOS_PLATFORM_BASE)/board.ld -P
 
@@ -144,6 +159,10 @@
 	$(LD) $(LITEOS_LDFLAGS) $(LITEOS_TABLES_LDFLAGS) $(LITEOS_DYNLDFLAGS) -Map=$(OUT)/$@.map -o $(OUT)/$@ --start-group $(LITEOS_LIBDEP) --end-group
 #	$(SIZE) -t --common $(OUT)/lib/*.a >$(OUT)/$@.objsize
 	$(OBJCOPY) -O binary $(OUT)/$@ $(LITEOS_TARGET_DIR)/$@.bin
+ifeq ($(LOSCFG_PLATFORM_STM32MP157), y)
+	mkimage.stm32 -T stm32image -a 0xC0100000 -e 0xC0100000 -d $(LITEOS_TARGET_DIR)/$@.bin $(LITEOS_TARGET_DIR)/liteos.stm32
+	mkimage.stm32 -A arm -O linux -T kernel -C none -a 0xC0100000 -e 0xC0100000 -n liteos-a -d $(LITEOS_TARGET_DIR)/$@.bin $(LITEOS_TARGET_DIR)/liteos_with_uboot_header.bin
+endif
 	$(OBJDUMP) -t $(OUT)/$@ |sort >$(OUT)/$@.sym.sorted
 	$(OBJDUMP) -d $(OUT)/$@ >$(OUT)/$@.asm
 #	$(NM) -S --size-sort $(OUT)/$@ >$(OUT)/$@.size
@@ -171,7 +190,7 @@
 endif
 
 $(ROOTFS): $(ROOTFSDIR)
-	$(HIDE)$(shell $(LITEOSTOPDIR)/tools/scripts/make_rootfs/rootfsimg.sh $(ROOTFS_DIR) $(FSTYPE))
+	$(HIDE)$(shell $(LITEOSTOPDIR)/tools/scripts/make_rootfs/rootfsimg.sh $(ROOTFS_DIR) $(FSTYPE)  ${ROOTFS_SIZE})
 	$(HIDE)cd $(ROOTFS_DIR)/.. && zip -r $(ROOTFS_ZIP) $(ROOTFS)
 ifneq ($(OUT), $(LITEOS_TARGET_DIR))
 	$(HIDE)mv $(ROOTFS_DIR) $(LITEOS_TARGET_DIR)rootfs
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/platform/board.ld openharmony_100ask/kernel/liteos_a/platform/board.ld
--- openharmony/kernel/liteos_a/platform/board.ld	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/kernel/liteos_a/platform/board.ld	2020-10-31 00:27:01.301671248 +0800
@@ -0,0 +1,24 @@
+
+
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+
+MEMORY
+{
+    ram : ORIGIN = 0x40000000, LENGTH = 0x1C000000
+    sram : ORIGIN = 0x40000000, LENGTH = 0x1000
+    user_ram : ORIGIN = 0x1000000, LENGTH = 0x100000
+}
+SECTIONS
+{
+    /DISCARD/ : { *(.comment .note) }
+
+    .ram_vectors 0x40000000 : {
+        __ram_vectors_vma = .;
+        KEEP (*(.vectors))
+    } > ram
+    __ram_vectors_lma = LOADADDR(.ram_vectors);
+}
+
+USER_INIT_VM_START = 0x1000000;
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/platform/bsp.mk openharmony_100ask/kernel/liteos_a/platform/bsp.mk
--- openharmony/kernel/liteos_a/platform/bsp.mk	2020-10-31 00:28:41.807166985 +0800
+++ openharmony_100ask/kernel/liteos_a/platform/bsp.mk	2020-10-31 00:27:01.313670939 +0800
@@ -55,7 +55,14 @@
     UART_TYPE    := amba_pl011
     USB_TYPE     := usb3.0_hi3518ev300
     LITEOS_CMACRO_TEST += -DTEST3518EV300
-
+else ifeq ($(LOSCFG_PLATFORM_IMX6ULL), y)
+    HWI_TYPE     := arm/interrupt/gic
+    TIMER_TYPE   := arm/timer/arm_generic
+    HRTIMER_TYPE := imx6ull/hrtimer
+else ifeq ($(LOSCFG_PLATFORM_STM32MP157), y)
+    HWI_TYPE     := arm/interrupt/gic
+    TIMER_TYPE   := arm/timer/arm_generic
+    HRTIMER_TYPE := stm32mp157/hrtimer
 endif
 
 HWI_SRC     := hw/$(HWI_TYPE)
@@ -80,7 +87,12 @@
 
 ifeq ($(findstring y, $(LOSCFG_PLATFORM_HI3518EV300)$(LOSCFG_PLATFORM_HI3516DV300)), y)
     PLATFORM_INCLUDE += -I $(LITEOSTOPDIR)/../../vendor/hisi/hi35xx/$(LITEOS_PLATFORM)/config/board/include/hisoc
+else ifeq ($(LOSCFG_PLATFORM_IMX6ULL),y)
+    PLATFORM_INCLUDE += -I $(LITEOSTOPDIR)/../../vendor/nxp/imx6ull/board/include
+else ifeq ($(LOSCFG_PLATFORM_STM32MP157),y)
+    PLATFORM_INCLUDE += -I $(LITEOSTOPDIR)/../../vendor/st/stm32mp157/board/include
 endif
+
 #
 #-include $(LITEOSTOPDIR)/platform/bsp/board/$(LITEOS_PLATFORM)/board.mk
 #
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/platform/hw/arm/timer/arm_generic/arm_generic_timer.c openharmony_100ask/kernel/liteos_a/platform/hw/arm/timer/arm_generic/arm_generic_timer.c
--- openharmony/kernel/liteos_a/platform/hw/arm/timer/arm_generic/arm_generic_timer.c	2020-10-31 00:28:41.807166985 +0800
+++ openharmony_100ask/kernel/liteos_a/platform/hw/arm/timer/arm_generic/arm_generic_timer.c	2020-10-31 00:27:01.309671042 +0800
@@ -197,3 +197,6 @@
 
     HalIrqUnmask(OS_TICK_INT_NUM);
 }
+
+VOID HalClockIrqClear(VOID) {}
+
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/platform/include/menuconfig.h openharmony_100ask/kernel/liteos_a/platform/include/menuconfig.h
--- openharmony/kernel/liteos_a/platform/include/menuconfig.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/kernel/liteos_a/platform/include/menuconfig.h	2020-10-31 00:27:01.309671042 +0800
@@ -0,0 +1,76 @@
+/*
+ *
+ * Automatically generated file; DO NOT EDIT.
+ * Huawei LiteOS Configuration
+ *
+ */
+#define LOSCFG_KERNEL_LITEIPC 1
+#define LOSCFG_SECURITY_CAPABILITY 1
+#define LOSCFG_NET_LWIP_SACK 1
+#define LOSCFG_DRIVERS_HDF_PLATFORM_I2C 1
+#define LOSCFG_NET_LWIP_SACK_TFTP 1
+#define LOSCFG_FS_FAT_VIRTUAL_PARTITION 1
+#define LOSCFG_FS_FAT_VOLUMES 16
+#define LOSCFG_SHELL_CMD_DEBUG 1
+#define LOSCFG_ENABLE_MAGICKEY 1
+#define LOSCFG_NULL_ADDRESS_PROTECT 1
+#define LOSCFG_DRIVERS 1
+#define LOSCFG_PLATFORM_ADAPT 1
+#define LOSCFG_KERNEL_PIPE 1
+#define LOSCFG_DRIVERS_MEM 1
+#define LOSCFG_CC_STACKPROTECTOR_STRONG 1
+#define LOSCFG_PLATFORM_STM32MP157 1
+#define LOSCFG_COMPILER_CLANG_LLVM 1
+#define LOSCFG_DRIVERS_HDF 1
+#define LOSCFG_BASE_CORE_HILOG 1
+#define LOSCFG_NET_TELNET 1
+#define LOSCFG_NET_LWIP_SACK_2_1 1
+#define LOSCFG_FS_VFS 1
+#define LOSCFG_KERNEL_DYNLOAD 1
+#define LOSCFG_COMPAT_POSIX 1
+#define LOSCFG_KERNEL_VDSO 1
+#define LOSCFG_DEBUG_VERSION 1
+#define LOSCFG_COMPAT_BSD 1
+#define LOSCFG_FILE_MODE 1
+#define LOSCFG_PLATFORM "stm32mp157"
+#define LOSCFG_PLATFORM_BSP_GIC_V2 1
+#define LOSCFG_PLATFORM_ROOTFS 1
+#define LOSCFG_KERNEL_CPPSUPPORT 1
+#define LOSCFG_ARCH_CORTEX_A7 1
+#define LOSCFG_DRIVERS_HDF_PLATFORM_UART 1
+#define LOSCFG_FS_FAT 1
+#define LOSCFG_FS_NFS 1
+#define LOSCFG_ARCH_ARM_VER "armv7-a"
+#define LOSCFG_FS_FAT_DISK 1
+#define LOSCFG_IRQ_USE_STANDALONE_STACK 1
+#define LOSCFG_ENABLE_OOM_LOOP_TASK 1
+#define LOSCFG_ARCH_ARM_AARCH32 1
+#define LOSCFG_KERNEL_EXTKERNEL 1
+#define LOSCFG_KERNEL_TICKLESS 1
+#define LOSCFG_DRIVERS_HDF_PLATFORM 1
+#define LOSCFG_FS_PROC 1
+#define LOSCFG_ARCH_CPU "cortex-a7"
+#define LOSCFG_ARCH_ARM_V7A 1
+#define LOSCFG_LIB_ZLIB 1
+#define LOSCFG_SECURITY_VID 1
+#define LOSCFG_ARCH_FPU "neon-vfpv4"
+#define LOSCFG_DRIVERS_MTD 1
+#define LOSCFG_ARCH_FPU_VFP_D32 1
+#define LOSCFG_USER_INIT_DEBUG 1
+#define LOSCFG_FS_FAT_CACHE_SYNC_THREAD 1
+#define LOSCFG_SHELL_LK 1
+#define LOSCFG_ARCH_ARM 1
+#define LOSCFG_FS_JFFS 1
+#define LOSCFG_DRIVERS_HIEVENT 1
+#define LOSCFG_ARCH_FPU_VFP_NEON 1
+#define LOSCFG_SHELL 1
+#define LOSCFG_CPUP_INCLUDE_IRQ 1
+#define LOSCFG_FS_FAT_CACHE 1
+#define LOSCFG_SHELL_DMESG 1
+#define LOSCFG_SECURITY 1
+#define LOSCFG_FS_VFS_BLOCK_DEVICE 1
+#define LOSCFG_FS_RAMFS 1
+#define LOSCFG_LIB_LIBC 1
+#define LOSCFG_FS_FAT_CHINESE 1
+#define LOSCFG_KERNEL_CPUP 1
+#define LOSCFG_ARCH_FPU_VFP_V4 1
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/platform/Kconfig openharmony_100ask/kernel/liteos_a/platform/Kconfig
--- openharmony/kernel/liteos_a/platform/Kconfig	2020-10-31 00:28:41.807166985 +0800
+++ openharmony_100ask/kernel/liteos_a/platform/Kconfig	2020-10-31 00:27:01.313670939 +0800
@@ -2,6 +2,8 @@
     string
     default "hi3516dv300"     if PLATFORM_HI3516DV300
     default "hi3518ev300"     if PLATFORM_HI3518EV300
+    default "imx6ull"         if PLATFORM_IMX6ULL
+    default "stm32mp157"      if PLATFORM_STM32MP157 
 
 choice
     prompt "Board"
@@ -19,6 +21,14 @@
     bool "hi3518ev300"
     select ARCH_CORTEX_A7
 
+config PLATFORM_STM32MP157
+    bool "stm32mp157"
+    select ARCH_CORTEX_A7
+
+config PLATFORM_IMX6ULL
+    bool "imx6ull"
+    select ARCH_CORTEX_A7
+
 endchoice
 
 config TEE_ENABLE
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/platform/main.c openharmony_100ask/kernel/liteos_a/platform/main.c
--- openharmony/kernel/liteos_a/platform/main.c	2020-10-31 00:28:41.807166985 +0800
+++ openharmony_100ask/kernel/liteos_a/platform/main.c	2020-10-31 00:27:01.301671248 +0800
@@ -154,6 +154,8 @@
     OsSetMainTask();
     OsCurrTaskSet(OsGetMainTask());
 
+    PRINT_RELEASE("\n******************Main******************\n\n");
+
     /* set smp system counter freq */
 #if (LOSCFG_KERNEL_SMP == YES)
 #ifndef LOSCFG_TEE_ENABLE
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/platform/Makefile openharmony_100ask/kernel/liteos_a/platform/Makefile
--- openharmony/kernel/liteos_a/platform/Makefile	2020-10-31 00:28:41.807166985 +0800
+++ openharmony_100ask/kernel/liteos_a/platform/Makefile	2020-10-31 00:27:01.313670939 +0800
@@ -40,7 +40,7 @@
 LOCAL_INCLUDE += -I $(LITEOSTOPDIR)/compat/posix/src \
                  -I $(LITEOSTOPDIR)/bsd/dev/random
 
-ifeq ($(findstring y, $(LOSCFG_PLATFORM_HI3518EV300)$(LOSCFG_PLATFORM_HI3516DV300)), y)
+ifeq ($(findstring y, $(LOSCFG_PLATFORM_HI3518EV300)$(LOSCFG_PLATFORM_HI3516DV300)$(LOSCFG_PLATFORM_IMX6ULL)$(LOSCFG_PLATFORM_STM32MP157)), y)
 LOCAL_SRCS += $(wildcard ../kernel/common/*.c)
 LOCAL_SRCS := $(filter-out ../kernel/common/los_rootfs.c, $(LOCAL_SRCS))
 ifneq ($(LOSCFG_FS_VFS), y)
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/shell/full/src/base/shcmd.c openharmony_100ask/kernel/liteos_a/shell/full/src/base/shcmd.c
--- openharmony/kernel/liteos_a/shell/full/src/base/shcmd.c	2020-10-31 00:28:41.811166889 +0800
+++ openharmony_100ask/kernel/liteos_a/shell/full/src/base/shcmd.c	2020-10-31 00:26:50.329955021 +0800
@@ -38,7 +38,16 @@
 #include "securec.h"
 #include "los_mux.h"
 #include "los_memory.h"
+#ifdef LOSCFG_DRIVERS_HDF_PLATFORM_UART
+#if defined LOSCFG_PLATFORM_IMX6ULL
+#include "uart.h"
+#elif defined LOSCFG_PLATFORM_STM32MP157
+#include "uart.h"
+#else
 #include "hisoc/uart.h"
+#endif
+#endif
+
 
 #ifdef  __cplusplus
 #if  __cplusplus
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/shell/full/src/base/shmsg.c openharmony_100ask/kernel/liteos_a/shell/full/src/base/shmsg.c
--- openharmony/kernel/liteos_a/shell/full/src/base/shmsg.c	2020-10-31 00:28:41.811166889 +0800
+++ openharmony_100ask/kernel/liteos_a/shell/full/src/base/shmsg.c	2020-10-31 00:26:50.321955227 +0800
@@ -41,7 +41,16 @@
 #include "los_event.h"
 #include "los_list.h"
 #include "los_printf.h"
+#ifdef LOSCFG_DRIVERS_HDF_PLATFORM_UART
+#if defined LOSCFG_PLATFORM_IMX6ULL
+#include "uart.h"
+#elif defined LOSCFG_PLATFORM_STM32MP157
+#include "uart.h"
+#else
 #include "hisoc/uart.h"
+#endif
+#endif
+
 
 #ifdef LOSCFG_FS_VFS
 #include "console.h"
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/shell/full/src/base/show.c openharmony_100ask/kernel/liteos_a/shell/full/src/base/show.c
--- openharmony/kernel/liteos_a/shell/full/src/base/show.c	2020-10-31 00:28:41.811166889 +0800
+++ openharmony_100ask/kernel/liteos_a/shell/full/src/base/show.c	2020-10-31 00:26:50.321955227 +0800
@@ -35,8 +35,14 @@
 #include "console.h"
 #include "asm/hal_platform_ints.h"
 #ifdef LOSCFG_DRIVERS_HDF_PLATFORM_UART
+#if defined LOSCFG_PLATFORM_IMX6ULL
+#include "uart.h"
+#elif defined LOSCFG_PLATFORM_STM32MP157
+#include "uart.h"
+#else
 #include "hisoc/uart.h"
 #endif
+#endif
 
 #ifdef __cplusplus
 #if __cplusplus
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/shell/full/src/cmds/dmesg.c openharmony_100ask/kernel/liteos_a/shell/full/src/cmds/dmesg.c
--- openharmony/kernel/liteos_a/shell/full/src/cmds/dmesg.c	2020-10-31 00:28:41.811166889 +0800
+++ openharmony_100ask/kernel/liteos_a/shell/full/src/cmds/dmesg.c	2020-10-31 00:26:50.405953046 +0800
@@ -59,7 +59,15 @@
 #include "unistd.h"
 #include "stdlib.h"
 #include "los_task.h"
+#ifdef LOSCFG_DRIVERS_HDF_PLATFORM_UART
+#if defined LOSCFG_PLATFORM_IMX6ULL
+#include "uart.h"
+#elif defined LOSCFG_PLATFORM_STM32MP157
+#include "uart.h"
+#else
 #include "hisoc/uart.h"
+#endif
+#endif
 #include "inode/inode.h"
 
 #ifdef __cplusplus
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/tools/build/config/debug/hi3516dv300_clang.config openharmony_100ask/kernel/liteos_a/tools/build/config/debug/hi3516dv300_clang.config
--- openharmony/kernel/liteos_a/tools/build/config/debug/hi3516dv300_clang.config	2020-10-31 00:28:41.811166889 +0800
+++ openharmony_100ask/kernel/liteos_a/tools/build/config/debug/hi3516dv300_clang.config	2020-10-31 00:26:51.985912050 +0800
@@ -15,6 +15,8 @@
 LOSCFG_PLATFORM="hi3516dv300"
 LOSCFG_PLATFORM_HI3516DV300=y
 # LOSCFG_PLATFORM_HI3518EV300 is not set
+# LOSCFG_PLATFORM_STM32MP157 is not set
+# LOSCFG_PLATFORM_IMX6ULL is not set
 # LOSCFG_TEE_ENABLE is not set
 LOSCFG_PLATFORM_BSP_GIC_V2=y
 LOSCFG_ARCH_ARM=y
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/tools/build/config/debug/hi3518ev300_clang.config openharmony_100ask/kernel/liteos_a/tools/build/config/debug/hi3518ev300_clang.config
--- openharmony/kernel/liteos_a/tools/build/config/debug/hi3518ev300_clang.config	2020-10-31 00:28:41.811166889 +0800
+++ openharmony_100ask/kernel/liteos_a/tools/build/config/debug/hi3518ev300_clang.config	2020-10-31 00:26:52.253905099 +0800
@@ -15,6 +15,8 @@
 LOSCFG_PLATFORM="hi3518ev300"
 # LOSCFG_PLATFORM_HI3516DV300 is not set
 LOSCFG_PLATFORM_HI3518EV300=y
+# LOSCFG_PLATFORM_STM32MP157 is not set
+# LOSCFG_PLATFORM_IMX6ULL is not set
 LOSCFG_PLATFORM_BSP_GIC_V2=y
 LOSCFG_ARCH_ARM=y
 LOSCFG_ARCH_ARM_AARCH32=y
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/tools/build/config/debug/imx6ull_clang.config openharmony_100ask/kernel/liteos_a/tools/build/config/debug/imx6ull_clang.config
--- openharmony/kernel/liteos_a/tools/build/config/debug/imx6ull_clang.config	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/kernel/liteos_a/tools/build/config/debug/imx6ull_clang.config	2020-10-31 00:26:52.253905099 +0800
@@ -0,0 +1,161 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Huawei LiteOS Configuration
+#
+
+#
+# Compiler
+#
+# LOSCFG_COMPILER_HIMIX_32 is not set
+LOSCFG_COMPILER_CLANG_LLVM=y
+
+#
+# Platform
+#
+LOSCFG_PLATFORM="imx6ull"
+# LOSCFG_PLATFORM_HI3516DV300 is not set
+# LOSCFG_PLATFORM_HI3518EV300 is not set
+# LOSCFG_PLATFORM_STM32MP157 is not set
+LOSCFG_PLATFORM_IMX6ULL=y
+LOSCFG_PLATFORM_BSP_GIC_V2=y
+LOSCFG_ARCH_ARM=y
+LOSCFG_ARCH_ARM_AARCH32=y
+LOSCFG_ARCH_ARM_V7A=y
+LOSCFG_ARCH_ARM_VER="armv7-a"
+LOSCFG_ARCH_FPU_VFP_V4=y
+LOSCFG_ARCH_FPU_VFP_D32=y
+LOSCFG_ARCH_FPU_VFP_NEON=y
+LOSCFG_ARCH_FPU="neon-vfpv4"
+LOSCFG_ARCH_CORTEX_A7=y
+LOSCFG_ARCH_CPU="cortex-a7"
+
+#
+# Extra Configurations
+#
+# LOSCFG_ARCH_FPU_DISABLE is not set
+LOSCFG_IRQ_USE_STANDALONE_STACK=y
+LOSCFG_PLATFORM_ROOTFS=y
+
+#
+# Kernel
+#
+# LOSCFG_KERNEL_SMP is not set
+LOSCFG_KERNEL_EXTKERNEL=y
+LOSCFG_KERNEL_CPPSUPPORT=y
+LOSCFG_KERNEL_CPUP=y
+LOSCFG_CPUP_INCLUDE_IRQ=y
+LOSCFG_KERNEL_DYNLOAD=y
+LOSCFG_KERNEL_VDSO=y
+LOSCFG_KERNEL_TICKLESS=y
+# LOSCFG_KERNEL_TRACE is not set
+LOSCFG_KERNEL_LITEIPC=y
+LOSCFG_KERNEL_PIPE=y
+LOSCFG_BASE_CORE_HILOG=y
+
+#
+# Lib
+#
+LOSCFG_LIB_LIBC=y
+LOSCFG_LIB_ZLIB=y
+
+#
+# Compat
+#
+LOSCFG_COMPAT_POSIX=y
+LOSCFG_COMPAT_BSD=y
+
+#
+# FileSystem
+#
+LOSCFG_FS_VFS=y
+LOSCFG_FS_VFS_BLOCK_DEVICE=y
+LOSCFG_FILE_MODE=y
+LOSCFG_FS_FAT=y
+LOSCFG_FS_FAT_CACHE=y
+LOSCFG_FS_FAT_CACHE_SYNC_THREAD=y
+LOSCFG_FS_FAT_CHINESE=y
+LOSCFG_FS_FAT_VIRTUAL_PARTITION=y
+LOSCFG_FS_FAT_VOLUMES=16
+LOSCFG_FS_FAT_DISK=y
+LOSCFG_FS_RAMFS=y
+LOSCFG_FS_NFS=y
+LOSCFG_FS_PROC=y
+LOSCFG_FS_JFFS=y
+
+#
+# Net
+#
+LOSCFG_NET_LWIP_SACK=y
+LOSCFG_NET_LWIP_SACK_2_1=y
+
+#
+# Debug
+#
+# LOSCFG_COMPILE_DEBUG is not set
+LOSCFG_PLATFORM_ADAPT=y
+LOSCFG_ENABLE_OOM_LOOP_TASK=y
+LOSCFG_ENABLE_MAGICKEY=y
+# LOSCFG_THUMB is not set
+LOSCFG_DEBUG_VERSION=y
+# LOSCFG_DEBUG_KERNEL is not set
+LOSCFG_SHELL=y
+
+#
+# Functionality of Shell
+#
+LOSCFG_SHELL_LK=y
+LOSCFG_SHELL_DMESG=y
+# LOSCFG_SHELL_EXCINFO is not set
+LOSCFG_NET_LWIP_SACK_TFTP=y
+LOSCFG_NET_TELNET=y
+# LOSCFG_EXC_INTERACTION is not set
+LOSCFG_USER_INIT_DEBUG=y
+LOSCFG_SHELL_CMD_DEBUG=y
+# LOSCFG_MEM_DEBUG is not set
+LOSCFG_NULL_ADDRESS_PROTECT=y
+LOSCFG_DRIVERS_HDF_PLATFORM_UART=y
+# LOSCFG_PLATFORM_UART_WITHOUT_VFS is not set
+# LOSCFG_PLATFORM_NO_UART is not set
+
+#
+# Driver
+#
+LOSCFG_DRIVERS=y
+# LOSCFG_DRIVERS_USB is not set
+LOSCFG_DRIVERS_HDF=y
+LOSCFG_DRIVERS_HDF_PLATFORM=y
+LOSCFG_DRIVERS_HDF_PLATFORM_I2C=y
+# LOSCFG_DRIVERS_HDF_PLATFORM_SPI is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_GPIO is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_WATCHDOG is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_SDIO is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_RTC is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_HISI_SDK is not set
+# LOSCFG_DRIVERS_HDF_WIFI is not set
+# LOSCFG_DRIVERS_HDF_INPUT is not set
+# LOSCFG_DRIVERS_HDF_LCD is not set
+# LOSCFG_DRIVERS_HDF_USB is not set
+# LOSCFG_DRIVERS_NETDEV is not set
+LOSCFG_DRIVERS_MEM=y
+# LOSCFG_DRIVERS_MMC is not set
+LOSCFG_DRIVERS_MTD=y
+# LOSCFG_DRIVERS_MTD_SPI_NOR is not set
+# LOSCFG_DRIVERS_RANDOM is not set
+LOSCFG_DRIVERS_VIDEO=y
+LOSCFG_DRIVERS_HIEVENT=y
+
+#
+# Security
+#
+LOSCFG_SECURITY=y
+LOSCFG_SECURITY_CAPABILITY=y
+LOSCFG_SECURITY_VID=y
+# LOSCFG_SECURITY_BOOT is not set
+
+#
+# Stack Smashing Protector (SSP) Compiler Feature
+#
+# LOSCFG_CC_NO_STACKPROTECTOR is not set
+# LOSCFG_CC_STACKPROTECTOR is not set
+LOSCFG_CC_STACKPROTECTOR_STRONG=y
+# LOSCFG_CC_STACKPROTECTOR_ALL is not set
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/tools/build/config/debug/imx6ull.config openharmony_100ask/kernel/liteos_a/tools/build/config/debug/imx6ull.config
--- openharmony/kernel/liteos_a/tools/build/config/debug/imx6ull.config	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/kernel/liteos_a/tools/build/config/debug/imx6ull.config	2020-10-31 00:26:52.261904891 +0800
@@ -0,0 +1,160 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Huawei LiteOS Configuration
+#
+
+#
+# Compiler
+#
+LOSCFG_COMPILER_HIMIX_32=y
+#LOSCFG_COMPILER_CLANG_LLVM is not set
+
+#
+# Platform
+#
+LOSCFG_PLATFORM="imx6ull"
+# LOSCFG_PLATFORM_HI3516DV300 is not set
+# LOSCFG_PLATFORM_HI3518EV300 is not set
+LOSCFG_PLATFORM_IMX6ULL=y
+LOSCFG_PLATFORM_BSP_GIC_V2=y
+LOSCFG_ARCH_ARM=y
+LOSCFG_ARCH_ARM_AARCH32=y
+LOSCFG_ARCH_ARM_V7A=y
+LOSCFG_ARCH_ARM_VER="armv7-a"
+LOSCFG_ARCH_FPU_VFP_V4=y
+LOSCFG_ARCH_FPU_VFP_D32=y
+LOSCFG_ARCH_FPU_VFP_NEON=y
+LOSCFG_ARCH_FPU="neon-vfpv4"
+LOSCFG_ARCH_CORTEX_A7=y
+LOSCFG_ARCH_CPU="cortex-a7"
+
+#
+# Extra Configurations
+#
+# LOSCFG_ARCH_FPU_DISABLE is not set
+LOSCFG_IRQ_USE_STANDALONE_STACK=y
+LOSCFG_PLATFORM_ROOTFS=y
+
+#
+# Kernel
+#
+# LOSCFG_KERNEL_SMP is not set
+LOSCFG_KERNEL_EXTKERNEL=y
+LOSCFG_KERNEL_CPPSUPPORT=y
+LOSCFG_KERNEL_CPUP=y
+LOSCFG_CPUP_INCLUDE_IRQ=y
+LOSCFG_KERNEL_DYNLOAD=y
+LOSCFG_KERNEL_VDSO=y
+LOSCFG_KERNEL_TICKLESS=y
+# LOSCFG_KERNEL_TRACE is not set
+LOSCFG_KERNEL_LITEIPC=y
+LOSCFG_KERNEL_PIPE=y
+LOSCFG_BASE_CORE_HILOG=y
+
+#
+# Lib
+#
+LOSCFG_LIB_LIBC=y
+LOSCFG_LIB_ZLIB=y
+
+#
+# Compat
+#
+LOSCFG_COMPAT_POSIX=y
+LOSCFG_COMPAT_BSD=y
+
+#
+# FileSystem
+#
+LOSCFG_FS_VFS=y
+LOSCFG_FS_VFS_BLOCK_DEVICE=y
+LOSCFG_FILE_MODE=y
+LOSCFG_FS_FAT=y
+LOSCFG_FS_FAT_CACHE=y
+LOSCFG_FS_FAT_CACHE_SYNC_THREAD=y
+LOSCFG_FS_FAT_CHINESE=y
+LOSCFG_FS_FAT_VIRTUAL_PARTITION=y
+LOSCFG_FS_FAT_VOLUMES=16
+LOSCFG_FS_FAT_DISK=y
+LOSCFG_FS_RAMFS=y
+LOSCFG_FS_NFS=y
+LOSCFG_FS_PROC=y
+LOSCFG_FS_JFFS=y
+
+#
+# Net
+#
+LOSCFG_NET_LWIP_SACK=y
+LOSCFG_NET_LWIP_SACK_2_1=y
+
+#
+# Debug
+#
+# LOSCFG_COMPILE_DEBUG is not set
+LOSCFG_PLATFORM_ADAPT=y
+LOSCFG_ENABLE_OOM_LOOP_TASK=y
+LOSCFG_ENABLE_MAGICKEY=y
+# LOSCFG_THUMB is not set
+LOSCFG_DEBUG_VERSION=y
+# LOSCFG_DEBUG_KERNEL is not set
+LOSCFG_SHELL=y
+
+#
+# Functionality of Shell
+#
+LOSCFG_SHELL_LK=y
+LOSCFG_SHELL_DMESG=y
+# LOSCFG_SHELL_EXCINFO is not set
+LOSCFG_NET_LWIP_SACK_TFTP=y
+LOSCFG_NET_TELNET=y
+# LOSCFG_EXC_INTERACTION is not set
+LOSCFG_USER_INIT_DEBUG=y
+LOSCFG_SHELL_CMD_DEBUG=y
+# LOSCFG_MEM_DEBUG is not set
+LOSCFG_NULL_ADDRESS_PROTECT=y
+LOSCFG_DRIVERS_HDF_PLATFORM_UART=y
+# LOSCFG_PLATFORM_UART_WITHOUT_VFS is not set
+# LOSCFG_PLATFORM_NO_UART is not set
+
+#
+# Driver
+#
+LOSCFG_DRIVERS=y
+# LOSCFG_DRIVERS_USB is not set
+LOSCFG_DRIVERS_HDF=y
+LOSCFG_DRIVERS_HDF_PLATFORM=y
+LOSCFG_DRIVERS_HDF_PLATFORM_I2C=y
+# LOSCFG_DRIVERS_HDF_PLATFORM_SPI is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_GPIO is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_WATCHDOG is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_SDIO is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_RTC is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_HISI_SDK is not set
+# LOSCFG_DRIVERS_HDF_WIFI is not set
+# LOSCFG_DRIVERS_HDF_INPUT is not set
+# LOSCFG_DRIVERS_HDF_LCD is not set
+# LOSCFG_DRIVERS_HDF_USB is not set
+# LOSCFG_DRIVERS_NETDEV is not set
+LOSCFG_DRIVERS_MEM=y
+# LOSCFG_DRIVERS_MMC is not set
+LOSCFG_DRIVERS_MTD=y
+# LOSCFG_DRIVERS_MTD_SPI_NOR is not set
+# LOSCFG_DRIVERS_RANDOM is not set
+LOSCFG_DRIVERS_VIDEO=y
+LOSCFG_DRIVERS_HIEVENT=y
+
+#
+# Security
+#
+LOSCFG_SECURITY=y
+LOSCFG_SECURITY_CAPABILITY=y
+LOSCFG_SECURITY_VID=y
+# LOSCFG_SECURITY_BOOT is not set
+
+#
+# Stack Smashing Protector (SSP) Compiler Feature
+#
+# LOSCFG_CC_NO_STACKPROTECTOR is not set
+# LOSCFG_CC_STACKPROTECTOR is not set
+LOSCFG_CC_STACKPROTECTOR_STRONG=y
+# LOSCFG_CC_STACKPROTECTOR_ALL is not set
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/tools/build/config/debug/stm32mp157_clang.config openharmony_100ask/kernel/liteos_a/tools/build/config/debug/stm32mp157_clang.config
--- openharmony/kernel/liteos_a/tools/build/config/debug/stm32mp157_clang.config	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/kernel/liteos_a/tools/build/config/debug/stm32mp157_clang.config	2020-10-31 00:26:52.265904789 +0800
@@ -0,0 +1,161 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Huawei LiteOS Configuration
+#
+
+#
+# Compiler
+#
+# LOSCFG_COMPILER_HIMIX_32 is not set
+LOSCFG_COMPILER_CLANG_LLVM=y
+
+#
+# Platform
+#
+LOSCFG_PLATFORM="stm32mp157"
+# LOSCFG_PLATFORM_HI3516DV300 is not set
+# LOSCFG_PLATFORM_HI3518EV300 is not set
+LOSCFG_PLATFORM_STM32MP157=y
+# LOSCFG_PLATFORM_IMX6ULL is not set
+LOSCFG_PLATFORM_BSP_GIC_V2=y
+LOSCFG_ARCH_ARM=y
+LOSCFG_ARCH_ARM_AARCH32=y
+LOSCFG_ARCH_ARM_V7A=y
+LOSCFG_ARCH_ARM_VER="armv7-a"
+LOSCFG_ARCH_FPU_VFP_V4=y
+LOSCFG_ARCH_FPU_VFP_D32=y
+LOSCFG_ARCH_FPU_VFP_NEON=y
+LOSCFG_ARCH_FPU="neon-vfpv4"
+LOSCFG_ARCH_CORTEX_A7=y
+LOSCFG_ARCH_CPU="cortex-a7"
+
+#
+# Extra Configurations
+#
+# LOSCFG_ARCH_FPU_DISABLE is not set
+LOSCFG_IRQ_USE_STANDALONE_STACK=y
+LOSCFG_PLATFORM_ROOTFS=y
+
+#
+# Kernel
+#
+# LOSCFG_KERNEL_SMP is not set
+LOSCFG_KERNEL_EXTKERNEL=y
+LOSCFG_KERNEL_CPPSUPPORT=y
+LOSCFG_KERNEL_CPUP=y
+LOSCFG_CPUP_INCLUDE_IRQ=y
+LOSCFG_KERNEL_DYNLOAD=y
+LOSCFG_KERNEL_VDSO=y
+LOSCFG_KERNEL_TICKLESS=y
+# LOSCFG_KERNEL_TRACE is not set
+LOSCFG_KERNEL_LITEIPC=y
+LOSCFG_KERNEL_PIPE=y
+LOSCFG_BASE_CORE_HILOG=y
+
+#
+# Lib
+#
+LOSCFG_LIB_LIBC=y
+LOSCFG_LIB_ZLIB=y
+
+#
+# Compat
+#
+LOSCFG_COMPAT_POSIX=y
+LOSCFG_COMPAT_BSD=y
+
+#
+# FileSystem
+#
+LOSCFG_FS_VFS=y
+LOSCFG_FS_VFS_BLOCK_DEVICE=y
+LOSCFG_FILE_MODE=y
+LOSCFG_FS_FAT=y
+LOSCFG_FS_FAT_CACHE=y
+LOSCFG_FS_FAT_CACHE_SYNC_THREAD=y
+LOSCFG_FS_FAT_CHINESE=y
+LOSCFG_FS_FAT_VIRTUAL_PARTITION=y
+LOSCFG_FS_FAT_VOLUMES=16
+LOSCFG_FS_FAT_DISK=y
+LOSCFG_FS_RAMFS=y
+LOSCFG_FS_NFS=y
+LOSCFG_FS_PROC=y
+LOSCFG_FS_JFFS=y
+
+#
+# Net
+#
+LOSCFG_NET_LWIP_SACK=y
+LOSCFG_NET_LWIP_SACK_2_1=y
+
+#
+# Debug
+#
+# LOSCFG_COMPILE_DEBUG is not set
+LOSCFG_PLATFORM_ADAPT=y
+LOSCFG_ENABLE_OOM_LOOP_TASK=y
+LOSCFG_ENABLE_MAGICKEY=y
+# LOSCFG_THUMB is not set
+LOSCFG_DEBUG_VERSION=y
+# LOSCFG_DEBUG_KERNEL is not set
+LOSCFG_SHELL=y
+
+#
+# Functionality of Shell
+#
+LOSCFG_SHELL_LK=y
+LOSCFG_SHELL_DMESG=y
+# LOSCFG_SHELL_EXCINFO is not set
+LOSCFG_NET_LWIP_SACK_TFTP=y
+LOSCFG_NET_TELNET=y
+# LOSCFG_EXC_INTERACTION is not set
+LOSCFG_USER_INIT_DEBUG=y
+LOSCFG_SHELL_CMD_DEBUG=y
+# LOSCFG_MEM_DEBUG is not set
+LOSCFG_NULL_ADDRESS_PROTECT=y
+LOSCFG_DRIVERS_HDF_PLATFORM_UART=y
+# LOSCFG_PLATFORM_UART_WITHOUT_VFS is not set
+# LOSCFG_PLATFORM_NO_UART is not set
+
+#
+# Driver
+#
+LOSCFG_DRIVERS=y
+# LOSCFG_DRIVERS_USB is not set
+LOSCFG_DRIVERS_HDF=y
+LOSCFG_DRIVERS_HDF_PLATFORM=y
+LOSCFG_DRIVERS_HDF_PLATFORM_I2C=y
+# LOSCFG_DRIVERS_HDF_PLATFORM_SPI is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_GPIO is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_WATCHDOG is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_SDIO is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_RTC is not set
+# LOSCFG_DRIVERS_HDF_PLATFORM_HISI_SDK is not set
+# LOSCFG_DRIVERS_HDF_WIFI is not set
+# LOSCFG_DRIVERS_HDF_INPUT is not set
+# LOSCFG_DRIVERS_HDF_LCD is not set
+# LOSCFG_DRIVERS_HDF_USB is not set
+# LOSCFG_DRIVERS_NETDEV is not set
+LOSCFG_DRIVERS_MEM=y
+# LOSCFG_DRIVERS_MMC is not set
+LOSCFG_DRIVERS_MTD=y
+# LOSCFG_DRIVERS_MTD_SPI_NOR is not set
+# LOSCFG_DRIVERS_RANDOM is not set
+# LOSCFG_DRIVERS_VIDEO is not set
+LOSCFG_DRIVERS_HIEVENT=y
+
+#
+# Security
+#
+LOSCFG_SECURITY=y
+LOSCFG_SECURITY_CAPABILITY=y
+LOSCFG_SECURITY_VID=y
+# LOSCFG_SECURITY_BOOT is not set
+
+#
+# Stack Smashing Protector (SSP) Compiler Feature
+#
+# LOSCFG_CC_NO_STACKPROTECTOR is not set
+# LOSCFG_CC_STACKPROTECTOR is not set
+LOSCFG_CC_STACKPROTECTOR_STRONG=y
+# LOSCFG_CC_STACKPROTECTOR_ALL is not set
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/tools/build/config/hi3516dv300_clang_release.config openharmony_100ask/kernel/liteos_a/tools/build/config/hi3516dv300_clang_release.config
--- openharmony/kernel/liteos_a/tools/build/config/hi3516dv300_clang_release.config	2020-10-31 00:28:41.811166889 +0800
+++ openharmony_100ask/kernel/liteos_a/tools/build/config/hi3516dv300_clang_release.config	2020-10-31 00:26:51.813916509 +0800
@@ -15,6 +15,7 @@
 LOSCFG_PLATFORM="hi3516dv300"
 LOSCFG_PLATFORM_HI3516DV300=y
 # LOSCFG_PLATFORM_HI3518EV300 is not set
+# LOSCFG_PLATFORM_IMX6ULL is not set
 # LOSCFG_TEE_ENABLE is not set
 LOSCFG_PLATFORM_BSP_GIC_V2=y
 LOSCFG_ARCH_ARM=y
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/tools/build/config/hi3518ev300_clang_release.config openharmony_100ask/kernel/liteos_a/tools/build/config/hi3518ev300_clang_release.config
--- openharmony/kernel/liteos_a/tools/build/config/hi3518ev300_clang_release.config	2020-10-31 00:28:41.811166889 +0800
+++ openharmony_100ask/kernel/liteos_a/tools/build/config/hi3518ev300_clang_release.config	2020-10-31 00:26:51.345928650 +0800
@@ -15,6 +15,7 @@
 LOSCFG_PLATFORM="hi3518ev300"
 # LOSCFG_PLATFORM_HI3516DV300 is not set
 LOSCFG_PLATFORM_HI3518EV300=y
+# LOSCFG_PLATFORM_IMX6ULL is not set
 LOSCFG_PLATFORM_BSP_GIC_V2=y
 LOSCFG_ARCH_ARM=y
 LOSCFG_ARCH_ARM_AARCH32=y
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/tools/build/config/imx6ull_clang_release.config openharmony_100ask/kernel/liteos_a/tools/build/config/imx6ull_clang_release.config
--- openharmony/kernel/liteos_a/tools/build/config/imx6ull_clang_release.config	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/kernel/liteos_a/tools/build/config/imx6ull_clang_release.config	2020-10-31 00:26:51.697919522 +0800
@@ -0,0 +1,166 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Huawei LiteOS Configuration
+#
+
+#
+# Compiler
+#
+# LOSCFG_COMPILER_HIMIX_32 is not set
+LOSCFG_COMPILER_CLANG_LLVM=y
+
+#
+# Platform
+#
+LOSCFG_PLATFORM="imx6ull"
+# LOSCFG_PLATFORM_HI3516DV300 is not set
+LOSCFG_PLATFORM_HI3518EV300=y
+LOSCFG_PLATFORM_BSP_GIC_V2=y
+LOSCFG_ARCH_ARM=y
+LOSCFG_ARCH_ARM_AARCH32=y
+LOSCFG_ARCH_ARM_V7A=y
+LOSCFG_ARCH_ARM_VER="armv7-a"
+LOSCFG_ARCH_FPU_VFP_V4=y
+LOSCFG_ARCH_FPU_VFP_D32=y
+LOSCFG_ARCH_FPU_VFP_NEON=y
+LOSCFG_ARCH_FPU="neon-vfpv4"
+LOSCFG_ARCH_CORTEX_A7=y
+LOSCFG_ARCH_CPU="cortex-a7"
+
+#
+# Extra Configurations
+#
+# LOSCFG_ARCH_FPU_DISABLE is not set
+LOSCFG_IRQ_USE_STANDALONE_STACK=y
+LOSCFG_PLATFORM_ROOTFS=y
+
+#
+# Kernel
+#
+# LOSCFG_KERNEL_SMP is not set
+LOSCFG_KERNEL_EXTKERNEL=y
+LOSCFG_KERNEL_CPPSUPPORT=y
+LOSCFG_KERNEL_CPUP=y
+LOSCFG_CPUP_INCLUDE_IRQ=y
+LOSCFG_KERNEL_DYNLOAD=y
+LOSCFG_ASLR=y
+LOSCFG_KERNEL_VDSO=y
+LOSCFG_KERNEL_TICKLESS=y
+# LOSCFG_KERNEL_TRACE is not set
+LOSCFG_KERNEL_LITEIPC=y
+LOSCFG_KERNEL_PIPE=y
+LOSCFG_BASE_CORE_HILOG=y
+
+#
+# Lib
+#
+LOSCFG_LIB_LIBC=y
+LOSCFG_LIB_ZLIB=y
+
+#
+# Compat
+#
+LOSCFG_COMPAT_POSIX=y
+LOSCFG_COMPAT_BSD=y
+
+#
+# FileSystem
+#
+LOSCFG_FS_VFS=y
+LOSCFG_FS_VFS_BLOCK_DEVICE=y
+LOSCFG_FILE_MODE=y
+LOSCFG_FS_FAT=y
+LOSCFG_FS_FAT_CACHE=y
+LOSCFG_FS_FAT_CACHE_SYNC_THREAD=y
+LOSCFG_FS_FAT_CHINESE=y
+LOSCFG_FS_FAT_VIRTUAL_PARTITION=y
+LOSCFG_FS_FAT_VOLUMES=16
+LOSCFG_FS_FAT_DISK=y
+LOSCFG_FS_RAMFS=y
+LOSCFG_FS_NFS=y
+LOSCFG_FS_PROC=y
+LOSCFG_FS_JFFS=y
+
+#
+# Net
+#
+LOSCFG_NET_LWIP_SACK=y
+LOSCFG_NET_LWIP_SACK_2_1=y
+
+#
+# Debug
+#
+# LOSCFG_COMPILE_DEBUG is not set
+LOSCFG_PLATFORM_ADAPT=y
+LOSCFG_ENABLE_OOM_LOOP_TASK=y
+LOSCFG_ENABLE_MAGICKEY=y
+# LOSCFG_THUMB is not set
+# LOSCFG_DEBUG_VERSION is not set
+LOSCFG_DRIVERS_HDF_PLATFORM_UART=y
+# LOSCFG_PLATFORM_UART_WITHOUT_VFS is not set
+# LOSCFG_PLATFORM_NO_UART is not set
+
+#
+# Driver
+#
+LOSCFG_DRIVERS=y
+LOSCFG_DRIVERS_USB=y
+LOSCFG_DRIVERS_USB_HOST_DRIVER=y
+# LOSCFG_DRIVERS_USB_HOST_EHCI is not set
+LOSCFG_DRIVERS_USB_HOST_XHCI=y
+LOSCFG_DRIVERS_USB_DEVICE_CLASS_DRIVERS=y
+
+#
+# USB Device Class Drivers
+#
+LOSCFG_DRIVERS_USB_MASS_STORAGE=y
+LOSCFG_DRIVERS_USB_RNDIS_HOST=y
+LOSCFG_DRIVERS_USB_4G_MODEM=y
+LOSCFG_DRIVERS_USB_SERIAL=y
+LOSCFG_DRIVERS_USB_ETHERNET=y
+LOSCFG_DRIVERS_USB_WIRELESS=y
+LOSCFG_DRIVERS_USB_HID_CLASS=y
+LOSCFG_DRIVERS_HDF=y
+LOSCFG_DRIVERS_HDF_PLATFORM=y
+LOSCFG_DRIVERS_HDF_PLATFORM_I2C=y
+LOSCFG_DRIVERS_HDF_PLATFORM_SPI=y
+LOSCFG_DRIVERS_HDF_PLATFORM_GPIO=y
+LOSCFG_DRIVERS_HDF_PLATFORM_WATCHDOG=y
+LOSCFG_DRIVERS_HDF_PLATFORM_SDIO=y
+LOSCFG_DRIVERS_HDF_PLATFORM_RTC=y
+LOSCFG_DRIVERS_HDF_PLATFORM_HISI_SDK=y
+LOSCFG_DRIVERS_HDF_WIFI=y
+LOSCFG_DRIVERS_HI3881=y
+# LOSCFG_DRIVERS_HDF_INPUT is not set
+# LOSCFG_DRIVERS_HDF_LCD is not set
+LOSCFG_DRIVERS_HDF_USB=y
+LOSCFG_DRIVERS_NETDEV=y
+LOSCFG_DRIVERS_HIETH_SF=y
+LOSCFG_DRIVERS_MEM=y
+LOSCFG_DRIVERS_MMC=y
+# LOSCFG_DRIVERS_SD_DETECT_BY_SW is not set
+LOSCFG_DRIVERS_SD=y
+# LOSCFG_DRIVERS_EMMC is not set
+LOSCFG_DRIVERS_MTD=y
+LOSCFG_DRIVERS_MTD_SPI_NOR=y
+LOSCFG_DRIVERS_MTD_SPI_NOR_HIFMC100=y
+LOSCFG_DRIVERS_RANDOM=y
+LOSCFG_HW_RANDOM_ENABLE=y
+LOSCFG_DRIVERS_VIDEO=y
+LOSCFG_DRIVERS_HIEVENT=y
+
+#
+# Security
+#
+LOSCFG_SECURITY=y
+LOSCFG_SECURITY_CAPABILITY=y
+LOSCFG_SECURITY_VID=y
+# LOSCFG_SECURITY_BOOT is not set
+
+#
+# Stack Smashing Protector (SSP) Compiler Feature
+#
+# LOSCFG_CC_NO_STACKPROTECTOR is not set
+# LOSCFG_CC_STACKPROTECTOR is not set
+LOSCFG_CC_STACKPROTECTOR_STRONG=y
+# LOSCFG_CC_STACKPROTECTOR_ALL is not set
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/tools/build/config/imx6ull_debug_shell.config openharmony_100ask/kernel/liteos_a/tools/build/config/imx6ull_debug_shell.config
--- openharmony/kernel/liteos_a/tools/build/config/imx6ull_debug_shell.config	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/kernel/liteos_a/tools/build/config/imx6ull_debug_shell.config	2020-10-31 00:26:51.833915991 +0800
@@ -0,0 +1,183 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Huawei LiteOS Configuration
+#
+
+#
+# Compiler
+#
+LOSCFG_COMPILER_HIMIX_32=y
+# LOSCFG_COMPILER_CLANG_LLVM is not set
+
+#
+# Platform
+#
+LOSCFG_PLATFORM="imx6ull"
+# LOSCFG_PLATFORM_HI3516DV300 is not set
+LOSCFG_PLATFORM_HI3518EV300=y
+LOSCFG_PLATFORM_BSP_GIC_V2=y
+LOSCFG_ARCH_ARM=y
+LOSCFG_ARCH_ARM_AARCH32=y
+LOSCFG_ARCH_ARM_V7A=y
+LOSCFG_ARCH_ARM_VER="armv7-a"
+LOSCFG_ARCH_FPU_VFP_V4=y
+LOSCFG_ARCH_FPU_VFP_D32=y
+LOSCFG_ARCH_FPU_VFP_NEON=y
+LOSCFG_ARCH_FPU="neon-vfpv4"
+LOSCFG_ARCH_CORTEX_A7=y
+LOSCFG_ARCH_CPU="cortex-a7"
+
+#
+# Extra Configurations
+#
+# LOSCFG_ARCH_FPU_DISABLE is not set
+LOSCFG_IRQ_USE_STANDALONE_STACK=y
+LOSCFG_PLATFORM_ROOTFS=y
+
+#
+# Kernel
+#
+# LOSCFG_KERNEL_SMP is not set
+LOSCFG_KERNEL_EXTKERNEL=y
+LOSCFG_KERNEL_CPPSUPPORT=y
+LOSCFG_KERNEL_CPUP=y
+LOSCFG_CPUP_INCLUDE_IRQ=y
+LOSCFG_KERNEL_DYNLOAD=y
+LOSCFG_ASLR=y
+LOSCFG_KERNEL_VDSO=y
+LOSCFG_KERNEL_TICKLESS=y
+# LOSCFG_KERNEL_TRACE is not set
+LOSCFG_KERNEL_LITEIPC=y
+LOSCFG_KERNEL_PIPE=y
+LOSCFG_BASE_CORE_HILOG=y
+
+#
+# Lib
+#
+LOSCFG_LIB_LIBC=y
+LOSCFG_LIB_ZLIB=y
+
+#
+# Compat
+#
+LOSCFG_COMPAT_POSIX=y
+LOSCFG_COMPAT_BSD=y
+
+#
+# FileSystem
+#
+LOSCFG_FS_VFS=y
+LOSCFG_FS_VFS_BLOCK_DEVICE=y
+LOSCFG_FILE_MODE=y
+LOSCFG_FS_FAT=y
+LOSCFG_FS_FAT_CACHE=y
+LOSCFG_FS_FAT_CACHE_SYNC_THREAD=y
+LOSCFG_FS_FAT_CHINESE=y
+LOSCFG_FS_FAT_VIRTUAL_PARTITION=y
+LOSCFG_FS_FAT_VOLUMES=16
+LOSCFG_FS_FAT_DISK=y
+LOSCFG_FS_RAMFS=y
+LOSCFG_FS_NFS=y
+LOSCFG_FS_PROC=y
+LOSCFG_FS_JFFS=y
+
+#
+# Net
+#
+LOSCFG_NET_LWIP_SACK=y
+LOSCFG_NET_LWIP_SACK_2_1=y
+
+#
+# Debug
+#
+# LOSCFG_COMPILE_DEBUG is not set
+LOSCFG_PLATFORM_ADAPT=y
+LOSCFG_ENABLE_OOM_LOOP_TASK=y
+LOSCFG_ENABLE_MAGICKEY=y
+# LOSCFG_THUMB is not set
+LOSCFG_DEBUG_VERSION=y
+# LOSCFG_DEBUG_KERNEL is not set
+LOSCFG_SHELL=y
+
+#
+# Functionality of Shell
+#
+LOSCFG_SHELL_LK=y
+LOSCFG_SHELL_DMESG=y
+# LOSCFG_SHELL_EXCINFO is not set
+LOSCFG_NET_LWIP_SACK_TFTP=y
+LOSCFG_NET_TELNET=y
+# LOSCFG_EXC_INTERACTION is not set
+# LOSCFG_USER_INIT_DEBUG is not set
+LOSCFG_SHELL_CMD_DEBUG=y
+# LOSCFG_USB_DEBUG is not set
+# LOSCFG_MEM_DEBUG is not set
+LOSCFG_NULL_ADDRESS_PROTECT=y
+LOSCFG_DRIVERS_HDF_PLATFORM_UART=y
+# LOSCFG_PLATFORM_UART_WITHOUT_VFS is not set
+# LOSCFG_PLATFORM_NO_UART is not set
+
+#
+# Driver
+#
+LOSCFG_DRIVERS=y
+LOSCFG_DRIVERS_USB=y
+LOSCFG_DRIVERS_USB_HOST_DRIVER=y
+# LOSCFG_DRIVERS_USB_HOST_EHCI is not set
+LOSCFG_DRIVERS_USB_HOST_XHCI=y
+LOSCFG_DRIVERS_USB_DEVICE_CLASS_DRIVERS=y
+
+#
+# USB Device Class Drivers
+#
+LOSCFG_DRIVERS_USB_MASS_STORAGE=y
+LOSCFG_DRIVERS_USB_RNDIS_HOST=y
+LOSCFG_DRIVERS_USB_4G_MODEM=y
+LOSCFG_DRIVERS_USB_SERIAL=y
+LOSCFG_DRIVERS_USB_ETHERNET=y
+LOSCFG_DRIVERS_USB_WIRELESS=y
+LOSCFG_DRIVERS_USB_HID_CLASS=y
+LOSCFG_DRIVERS_HDF=y
+LOSCFG_DRIVERS_HDF_PLATFORM=y
+LOSCFG_DRIVERS_HDF_PLATFORM_I2C=y
+LOSCFG_DRIVERS_HDF_PLATFORM_SPI=y
+LOSCFG_DRIVERS_HDF_PLATFORM_GPIO=y
+LOSCFG_DRIVERS_HDF_PLATFORM_WATCHDOG=y
+LOSCFG_DRIVERS_HDF_PLATFORM_SDIO=y
+LOSCFG_DRIVERS_HDF_PLATFORM_RTC=y
+LOSCFG_DRIVERS_HDF_PLATFORM_HISI_SDK=y
+LOSCFG_DRIVERS_HDF_WIFI=y
+LOSCFG_DRIVERS_HI3881=y
+# LOSCFG_DRIVERS_HDF_INPUT is not set
+# LOSCFG_DRIVERS_HDF_LCD is not set
+LOSCFG_DRIVERS_HDF_USB=y
+LOSCFG_DRIVERS_NETDEV=y
+LOSCFG_DRIVERS_HIETH_SF=y
+LOSCFG_DRIVERS_MEM=y
+LOSCFG_DRIVERS_MMC=y
+# LOSCFG_DRIVERS_SD_DETECT_BY_SW is not set
+LOSCFG_DRIVERS_SD=y
+# LOSCFG_DRIVERS_EMMC is not set
+LOSCFG_DRIVERS_MTD=y
+LOSCFG_DRIVERS_MTD_SPI_NOR=y
+LOSCFG_DRIVERS_MTD_SPI_NOR_HIFMC100=y
+LOSCFG_DRIVERS_RANDOM=y
+LOSCFG_HW_RANDOM_ENABLE=y
+LOSCFG_DRIVERS_VIDEO=y
+LOSCFG_DRIVERS_HIEVENT=y
+
+#
+# Security
+#
+LOSCFG_SECURITY=y
+LOSCFG_SECURITY_CAPABILITY=y
+LOSCFG_SECURITY_VID=y
+# LOSCFG_SECURITY_BOOT is not set
+
+#
+# Stack Smashing Protector (SSP) Compiler Feature
+#
+# LOSCFG_CC_NO_STACKPROTECTOR is not set
+# LOSCFG_CC_STACKPROTECTOR is not set
+LOSCFG_CC_STACKPROTECTOR_STRONG=y
+# LOSCFG_CC_STACKPROTECTOR_ALL is not set
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/tools/build/config/imx6ull_release.config openharmony_100ask/kernel/liteos_a/tools/build/config/imx6ull_release.config
--- openharmony/kernel/liteos_a/tools/build/config/imx6ull_release.config	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/kernel/liteos_a/tools/build/config/imx6ull_release.config	2020-10-31 00:26:51.933913400 +0800
@@ -0,0 +1,166 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Huawei LiteOS Configuration
+#
+
+#
+# Compiler
+#
+LOSCFG_COMPILER_HIMIX_32=y
+# LOSCFG_COMPILER_CLANG_LLVM is not set
+
+#
+# Platform
+#
+LOSCFG_PLATFORM="imx6ull"
+# LOSCFG_PLATFORM_HI3516DV300 is not set
+LOSCFG_PLATFORM_HI3518EV300=y
+LOSCFG_PLATFORM_BSP_GIC_V2=y
+LOSCFG_ARCH_ARM=y
+LOSCFG_ARCH_ARM_AARCH32=y
+LOSCFG_ARCH_ARM_V7A=y
+LOSCFG_ARCH_ARM_VER="armv7-a"
+LOSCFG_ARCH_FPU_VFP_V4=y
+LOSCFG_ARCH_FPU_VFP_D32=y
+LOSCFG_ARCH_FPU_VFP_NEON=y
+LOSCFG_ARCH_FPU="neon-vfpv4"
+LOSCFG_ARCH_CORTEX_A7=y
+LOSCFG_ARCH_CPU="cortex-a7"
+
+#
+# Extra Configurations
+#
+# LOSCFG_ARCH_FPU_DISABLE is not set
+LOSCFG_IRQ_USE_STANDALONE_STACK=y
+LOSCFG_PLATFORM_ROOTFS=y
+
+#
+# Kernel
+#
+# LOSCFG_KERNEL_SMP is not set
+LOSCFG_KERNEL_EXTKERNEL=y
+LOSCFG_KERNEL_CPPSUPPORT=y
+LOSCFG_KERNEL_CPUP=y
+LOSCFG_CPUP_INCLUDE_IRQ=y
+LOSCFG_KERNEL_DYNLOAD=y
+LOSCFG_ASLR=y
+LOSCFG_KERNEL_VDSO=y
+LOSCFG_KERNEL_TICKLESS=y
+# LOSCFG_KERNEL_TRACE is not set
+LOSCFG_KERNEL_LITEIPC=y
+LOSCFG_KERNEL_PIPE=y
+LOSCFG_BASE_CORE_HILOG=y
+
+#
+# Lib
+#
+LOSCFG_LIB_LIBC=y
+LOSCFG_LIB_ZLIB=y
+
+#
+# Compat
+#
+LOSCFG_COMPAT_POSIX=y
+LOSCFG_COMPAT_BSD=y
+
+#
+# FileSystem
+#
+LOSCFG_FS_VFS=y
+LOSCFG_FS_VFS_BLOCK_DEVICE=y
+LOSCFG_FILE_MODE=y
+LOSCFG_FS_FAT=y
+LOSCFG_FS_FAT_CACHE=y
+LOSCFG_FS_FAT_CACHE_SYNC_THREAD=y
+LOSCFG_FS_FAT_CHINESE=y
+LOSCFG_FS_FAT_VIRTUAL_PARTITION=y
+LOSCFG_FS_FAT_VOLUMES=16
+LOSCFG_FS_FAT_DISK=y
+LOSCFG_FS_RAMFS=y
+LOSCFG_FS_NFS=y
+LOSCFG_FS_PROC=y
+LOSCFG_FS_JFFS=y
+
+#
+# Net
+#
+LOSCFG_NET_LWIP_SACK=y
+LOSCFG_NET_LWIP_SACK_2_1=y
+
+#
+# Debug
+#
+# LOSCFG_COMPILE_DEBUG is not set
+LOSCFG_PLATFORM_ADAPT=y
+LOSCFG_ENABLE_OOM_LOOP_TASK=y
+# LOSCFG_ENABLE_MAGICKEY is not set
+# LOSCFG_THUMB is not set
+# LOSCFG_DEBUG_VERSION is not set
+LOSCFG_DRIVERS_HDF_PLATFORM_UART=y
+# LOSCFG_PLATFORM_UART_WITHOUT_VFS is not set
+# LOSCFG_PLATFORM_NO_UART is not set
+
+#
+# Driver
+#
+LOSCFG_DRIVERS=y
+LOSCFG_DRIVERS_USB=y
+LOSCFG_DRIVERS_USB_HOST_DRIVER=y
+# LOSCFG_DRIVERS_USB_HOST_EHCI is not set
+LOSCFG_DRIVERS_USB_HOST_XHCI=y
+LOSCFG_DRIVERS_USB_DEVICE_CLASS_DRIVERS=y
+
+#
+# USB Device Class Drivers
+#
+LOSCFG_DRIVERS_USB_MASS_STORAGE=y
+LOSCFG_DRIVERS_USB_RNDIS_HOST=y
+LOSCFG_DRIVERS_USB_4G_MODEM=y
+LOSCFG_DRIVERS_USB_SERIAL=y
+LOSCFG_DRIVERS_USB_ETHERNET=y
+LOSCFG_DRIVERS_USB_WIRELESS=y
+LOSCFG_DRIVERS_USB_HID_CLASS=y
+LOSCFG_DRIVERS_HDF=y
+LOSCFG_DRIVERS_HDF_PLATFORM=y
+LOSCFG_DRIVERS_HDF_PLATFORM_I2C=y
+LOSCFG_DRIVERS_HDF_PLATFORM_SPI=y
+LOSCFG_DRIVERS_HDF_PLATFORM_GPIO=y
+LOSCFG_DRIVERS_HDF_PLATFORM_WATCHDOG=y
+LOSCFG_DRIVERS_HDF_PLATFORM_SDIO=y
+LOSCFG_DRIVERS_HDF_PLATFORM_RTC=y
+LOSCFG_DRIVERS_HDF_PLATFORM_HISI_SDK=y
+LOSCFG_DRIVERS_HDF_WIFI=y
+LOSCFG_DRIVERS_HI3881=y
+# LOSCFG_DRIVERS_HDF_INPUT is not set
+# LOSCFG_DRIVERS_HDF_LCD is not set
+LOSCFG_DRIVERS_HDF_USB=y
+LOSCFG_DRIVERS_NETDEV=y
+LOSCFG_DRIVERS_HIETH_SF=y
+LOSCFG_DRIVERS_MEM=y
+LOSCFG_DRIVERS_MMC=y
+# LOSCFG_DRIVERS_SD_DETECT_BY_SW is not set
+LOSCFG_DRIVERS_SD=y
+# LOSCFG_DRIVERS_EMMC is not set
+LOSCFG_DRIVERS_MTD=y
+LOSCFG_DRIVERS_MTD_SPI_NOR=y
+LOSCFG_DRIVERS_MTD_SPI_NOR_HIFMC100=y
+LOSCFG_DRIVERS_RANDOM=y
+LOSCFG_HW_RANDOM_ENABLE=y
+LOSCFG_DRIVERS_VIDEO=y
+LOSCFG_DRIVERS_HIEVENT=y
+
+#
+# Security
+#
+LOSCFG_SECURITY=y
+LOSCFG_SECURITY_CAPABILITY=y
+LOSCFG_SECURITY_VID=y
+# LOSCFG_SECURITY_BOOT is not set
+
+#
+# Stack Smashing Protector (SSP) Compiler Feature
+#
+# LOSCFG_CC_NO_STACKPROTECTOR is not set
+# LOSCFG_CC_STACKPROTECTOR is not set
+LOSCFG_CC_STACKPROTECTOR_STRONG=y
+# LOSCFG_CC_STACKPROTECTOR_ALL is not set
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/tools/build/mk/liteos_tables_ldflags.mk openharmony_100ask/kernel/liteos_a/tools/build/mk/liteos_tables_ldflags.mk
--- openharmony/kernel/liteos_a/tools/build/mk/liteos_tables_ldflags.mk	2020-10-31 00:28:41.811166889 +0800
+++ openharmony_100ask/kernel/liteos_a/tools/build/mk/liteos_tables_ldflags.mk	2020-10-31 00:26:52.277904476 +0800
@@ -58,7 +58,7 @@
     -uwatch_shellcmd \
     -udeadlock_shellcmd \
     -ukill_shellcmd \
-    -upmm_shellcmd
+    -upmm_shellcmd 
 
 
 ####Net command####
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/tools/build/mk/los_config.mk openharmony_100ask/kernel/liteos_a/tools/build/mk/los_config.mk
--- openharmony/kernel/liteos_a/tools/build/mk/los_config.mk	2020-10-31 00:28:41.811166889 +0800
+++ openharmony_100ask/kernel/liteos_a/tools/build/mk/los_config.mk	2020-10-31 00:26:52.273904581 +0800
@@ -163,8 +163,18 @@
 LIB_SUBDIRS       += kernel/base
 LITEOS_KERNEL_INCLUDE   := -I $(LITEOSTOPDIR)/kernel/include
 
+ifeq ($(LITEOS_PLATFORM),imx6ull)
+include $(LITEOSTOPDIR)/../../vendor/nxp/imx6ull/imx6ull.mk
+endif
+
+ifeq ($(LITEOS_PLATFORM),stm32mp157)
+include $(LITEOSTOPDIR)/../../vendor/st/stm32mp157/stm32mp157.mk
+endif
+
+ifeq ($(findstring y, $(LOSCFG_PLATFORM_HI3518EV300)$(LOSCFG_PLATFORM_HI3516DV300)), y)
 LITEOS_BASELIB += -lhi35xx_bsp
 LIB_SUBDIRS += $(LITEOSTOPDIR)/../../vendor/hisi/hi35xx/$(LITEOS_PLATFORM)/config/board/
+endif
 
 ifeq ($(LOSCFG_KERNEL_CPUP), y)
     LITEOS_BASELIB   += -lcpup
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/tools/scripts/make_rootfs/rootfsimg.sh openharmony_100ask/kernel/liteos_a/tools/scripts/make_rootfs/rootfsimg.sh
--- openharmony/kernel/liteos_a/tools/scripts/make_rootfs/rootfsimg.sh	2020-10-31 00:28:41.851165924 +0800
+++ openharmony_100ask/kernel/liteos_a/tools/scripts/make_rootfs/rootfsimg.sh	2020-10-31 00:26:54.069858044 +0800
@@ -33,6 +33,7 @@
 system=$(uname -s)
 ROOTFS_DIR=$1
 FSTYPE=$2
+ROOTFS_SIZE=$3
 ROOTFS_IMG=${ROOTFS_DIR}".img"
 JFFS2_TOOL=$(dirname $(readlink -f "$0"))/../../fsimage/mkfs.jffs2
 WIN_JFFS2_TOOL=$(dirname $(readlink -f "$0"))/../../fsimage/win-x86/mkfs.jffs2.exe
@@ -48,7 +49,10 @@
         ${WIN_JFFS2_TOOL} -q -o ${ROOTFS_IMG} -d ${ROOTFS_DIR} --pagesize=4096
     else
         chmod +x ${JFFS2_TOOL}
-        ${JFFS2_TOOL} -q -o ${ROOTFS_IMG} -d ${ROOTFS_DIR} --pagesize=4096
+        echo ${JFFS2_TOOL} -q -o ${ROOTFS_IMG} -d ${ROOTFS_DIR} --pagesize=4096 --pad=${ROOTFS_SIZE}
+        ${JFFS2_TOOL} -q -o ${ROOTFS_IMG} -d ${ROOTFS_DIR} --pagesize=4096 --pad=${ROOTFS_SIZE}
+	cp ${ROOTFS_IMG} ${ROOTFS_DIR}".jffs2"
+	cp ${ROOTFS_IMG} ${ROOTFS_DIR}".jffs2.bin"
     fi
 elif [ "${FSTYPE}" = "vfat" ]; then
     if [ "${system}" != "Linux" ] ; then
diff -urN -x .git -x .repo openharmony/kernel/liteos_a/tools/scripts/make_rootfs/rootfs.sh openharmony_100ask/kernel/liteos_a/tools/scripts/make_rootfs/rootfs.sh
--- openharmony/kernel/liteos_a/tools/scripts/make_rootfs/rootfs.sh	2020-10-31 00:28:41.851165924 +0800
+++ openharmony_100ask/kernel/liteos_a/tools/scripts/make_rootfs/rootfs.sh	2020-10-31 00:26:54.121856696 +0800
@@ -36,4 +36,4 @@
 FSTYPE=$4
 CUR_DIR=$(dirname $(readlink -f "$0"))
 . ${CUR_DIR}/rootfsdir.sh ${BIN_DIR} ${LIB_DIR} ${ROOTFS_DIR}
-. ${CUR_DIR}/rootfsimg.sh ${ROOTFS_DIR} ${FSTYPE}
\ No newline at end of file
+. ${CUR_DIR}/rootfsimg.sh ${ROOTFS_DIR} ${FSTYPE} ${ROOTFS_SIZE}
diff -urN -x .git -x .repo openharmony/myapp/hello_test.c openharmony_100ask/myapp/hello_test.c
--- openharmony/myapp/hello_test.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/myapp/hello_test.c	2020-10-31 00:27:41.724644103 +0800
@@ -0,0 +1,78 @@
+#include "hdf_log.h"
+#include "osal_mem.h"
+#include "hdf_io_service_if.h"
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+
+
+int main(int argc, char **argv)
+{
+
+	if (argc != 2)
+	{
+		printf("Usage: %s <service | /dev/hello>\n", argv[0]);
+		return -1;
+	}
+
+	if (strcmp(argv[1], "service") == 0)
+	{
+		char *serviceName = "hello_service";
+		int ret;	
+		int val;
+		
+	    struct HdfIoService *service = HdfIoServiceBind(serviceName, 0);
+	    if (service == NULL) {
+	        printf("Failed to get service %s", serviceName);
+	        return 0;
+	    }
+
+	    struct HdfSBuf *data = HdfSBufObtainDefaultSize();
+	    if (data == NULL) {
+	        printf("Failed to obtain data");
+	        return HDF_FAILURE;
+	    }
+
+	    struct HdfSBuf *reply = HdfSBufObtainDefaultSize();
+	    if (reply == NULL) {
+	        printf("Failed to obtain replay");
+	        return HDF_FAILURE;
+	    }
+
+
+	    ret = service->dispatcher->Dispatch(&service->object, 0, data, reply);
+	    if (ret != HDF_SUCCESS) {
+	        printf("Failed to send service call");
+	    }
+
+		ret = HdfSbufReadInt32(reply, &val);
+		printf("read val from %s: 0x%x\n", serviceName, val);
+		
+	    HdfSBufRecycle(data);
+	    HdfSBufRecycle(reply);
+		return ret;
+	}
+	else
+	{
+		int fd = open(argv[1], O_RDWR);
+		int val;
+		int ret;
+		
+		if (fd < 0) {
+			printf("can not open %s\n", argv[1]);
+			return -1;
+		}
+
+		ret = read(fd, &val, 4);
+		if (ret != 4) {
+			printf("can not read %s, ret = %d\n", argv[1], ret);
+			return -1;
+		}
+
+		printf("read val from device %s: 0x%x\n", argv[1], val);
+		return 0;
+	}
+}
+
diff -urN -x .git -x .repo openharmony/third_party/musl/kernel/src/include/features.h openharmony_100ask/third_party/musl/kernel/src/include/features.h
--- openharmony/third_party/musl/kernel/src/include/features.h	2020-10-31 00:28:45.235084381 +0800
+++ openharmony_100ask/third_party/musl/kernel/src/include/features.h	2020-10-31 00:27:09.761453928 +0800
@@ -4,8 +4,10 @@
 #include "../../include/features.h"
 
 #define hidden __attribute__((__visibility__("hidden")))
+#ifndef weak_alias
 #define weak_alias(old, new) \
     extern __typeof(old) new __attribute__((__weak__, __alias__(#old)))
+#endif
 #define strong_alias(old, new) \
     extern __typeof(old) new __attribute__((__alias__(#old)))
 
diff -urN -x .git -x .repo openharmony/vendor/nxp/hdf/hdf_vendor.mk openharmony_100ask/vendor/nxp/hdf/hdf_vendor.mk
--- openharmony/vendor/nxp/hdf/hdf_vendor.mk	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/hdf/hdf_vendor.mk	2020-10-31 00:27:40.752668470 +0800
@@ -0,0 +1,35 @@
+# Copyright (c) 2020 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+    LITEOS_BASELIB += -lhdf_config
+    LIB_SUBDIRS += $(LITEOS_SOURCE_ROOT)/vendor/nxp/$(LITEOS_PLATFORM)/config
+
+
+VENDOR_HDF_DRIVERS_ROOT := $(LITEOSTOPDIR)/../../vendor/nxp/hdf
+
+ifeq ($(LOSCFG_PLATFORM_IMX6ULL), y)
+LIB_SUBDIRS             += $(IMX6ULL_BASE_DIR)/driver/imx6ull-i2c
+LITEOS_BASELIB  += -limx6ull-i2c
+endif
+
+LIB_SUBDIRS             += $(IMX6ULL_BASE_DIR)/driver/touch
+LITEOS_BASELIB  += -ltouch
+
+
+LIB_SUBDIRS             += $(IMX6ULL_BASE_DIR)/driver/hello
+LITEOS_BASELIB  += -lhello
+
+# lib path
+LITEOS_LD_PATH += -L$(VENDOR_HDF_DRIVERS_ROOT)/libs/$(LITEOS_PLATFORM)
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/board/board.c openharmony_100ask/vendor/nxp/imx6ull/board/board.c
--- openharmony/vendor/nxp/imx6ull/board/board.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/board/board.c	2020-10-31 00:27:40.752668470 +0800
@@ -0,0 +1,113 @@
+#include "los_base.h"
+#include "los_config.h"
+#include "los_process_pri.h"
+#include "lwip/init.h"
+#include "lwip/tcpip.h"
+#include "sys/mount.h"
+#include "mtd_partition.h"
+#include "console.h"
+
+UINT32 OsRandomStackGuard(VOID)
+{
+    return 0;
+}
+
+static void imx6ull_mount_rootfs()
+{
+#if 1	
+    dprintf("register parition ...\n");
+    if (add_mtd_partition("spinor", 0, 0x4000000, 0))
+    {
+        PRINT_ERR("add_mtd_partition fail\n");
+    }
+    
+    dprintf("mount /dev/spinorblk0 / ...\n");
+    //if (mount("/dev/spinorblk0", "/", "jffs2", MS_RDONLY, NULL))
+    if (mount("/dev/spinorblk0", "/", "jffs2", 0, NULL))
+    {
+        PRINT_ERR("mount failed\n");
+    }
+#else
+    dprintf("mount /dev/ramdisk / ...\n");
+    //if (mount("/dev/spinorblk0", "/", "jffs2", MS_RDONLY, NULL))
+    if (mount("/dev/ramdisk", "/", "vfat", 0, NULL))
+    {
+        PRINT_ERR("mount failed\n");
+    }
+#endif
+}
+
+static void imx6ull_driver_init()
+{
+#if 0	
+	extern int my_ramdisk_init(void);
+    if (my_ramdisk_init())
+    {
+        PRINT_ERR("my_ramdisk_init failed\n");
+    }
+
+#else	
+    extern int spinor_init(void);
+    dprintf("spinor_init init ...\n");
+    if (!spinor_init())
+    {
+        PRINT_ERR("spinor_init failed\n");
+    }
+#endif
+
+#ifdef LOSCFG_DRIVERS_VIDEO
+    dprintf("imx6ull_fb_init init ...\n");
+	extern int imx6ull_fb_init(void);
+    if (imx6ull_fb_init())
+    {
+        PRINT_ERR("imx6ull_fb_init failed\n");
+    }
+#endif	
+
+}
+
+
+void SystemInit()
+{
+#ifdef LOSCFG_FS_PROC
+    dprintf("proc fs init ...\n");
+    extern void ProcFsInit(void);
+    ProcFsInit();
+#endif
+
+#ifdef LOSCFG_DRIVERS_MEM
+    dprintf("mem dev init ...\n");
+    extern int mem_dev_register(void);
+    mem_dev_register();
+#endif
+    imx6ull_driver_init();
+    imx6ull_mount_rootfs();
+
+#ifdef LOSCFG_DRIVERS_HDF
+	    extern int DeviceManagerStart(void);
+		PRINT_RELEASE("DeviceManagerStart start ...\n");	
+		if (DeviceManagerStart()) {
+			PRINT_ERR("No drivers need load by hdf manager!");
+		}
+		dprintf("DeviceManagerStart end ...\n");
+#endif
+
+    extern int uart_dev_init(void);
+    uart_dev_init();
+
+    if (virtual_serial_init("/dev/uartdev-0") != 0)
+    {
+        PRINT_ERR("virtual_serial_init failed");
+    }
+
+    if (system_console_init(SERIAL) != 0)
+    {
+        PRINT_ERR("system_console_init failed\n");
+    }
+
+    if (OsUserInitProcess())
+    {
+        PRINT_ERR("Create user init process faialed!\n");
+    }
+}
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/board/bsd_board.c openharmony_100ask/vendor/nxp/imx6ull/board/bsd_board.c
--- openharmony/vendor/nxp/imx6ull/board/bsd_board.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/board/bsd_board.c	2020-10-31 00:27:40.752668470 +0800
@@ -0,0 +1,83 @@
+#include "asm/platform.h"
+#include "sys/bus.h"
+#include "uart_dev.h"
+//#include "imx6ull_uart.h"
+
+#include "los_hw_pri.h"
+
+
+
+#define UART_IOMEM_COUNT 0xBC
+
+/**************************************************/
+/*        UART Device                      */
+/**************************************************/
+//#if LOSCFG_DRIVERS_UART
+
+#define BAUD_RATE_LOW 9600
+#define BAUD_RATE_HIGH 115200
+
+void dma_cache_clean(UINTPTR start, UINTPTR end)
+{
+    arm_clean_cache_range(start, end);
+}
+void dma_cache_inv(UINTPTR start, UINTPTR end)
+{
+    arm_inv_cache_range(start, end);
+}
+
+static struct uart_driver_data uart0_dw_driver = { /*lint !e121 !e129 !e10 -esym(528, uart0_pl011_driver)*/
+    .num             = 0,
+    .baudrate        = BAUD_RATE_HIGH,
+    .attr.fifo_rx_en = 1,
+    .attr.fifo_tx_en = 1,
+//    .flags           = UART_FLG_RD_BLOCK,
+};
+static struct uart_softc uart0_softc = { /*lint !e10 !e129*/
+    .udd = &uart0_dw_driver,
+};
+
+#define UART_ADD_DEVICE(dev, unit) \
+    do { \
+        dev = device_add_child(nexus, "uart", unit); \
+        if (dev != NULL) { \
+            device_set_softc(dev, &uart ## unit ## _softc); \
+        } \
+    } while (0)
+
+// callback never be null pointer
+static void uart_add_device(add_res_callback_t callback)
+{
+    device_t uart_dev;
+    UART_ADD_DEVICE(uart_dev, 0);
+    callback("uart", SYS_RES_MEMORY, 0, UART0_REG_PBASE,
+        UART0_REG_PBASE + UART_IOMEM_COUNT, UART_IOMEM_COUNT);
+    callback("uart", SYS_RES_IRQ, 0, NUM_HAL_INTERRUPT_UART0,
+        NUM_HAL_INTERRUPT_UART0, 1);
+
+}
+//#endif
+
+//#if defined (LOSCFG_DRIVERS_MTD_SPI_NOR_SUNXI)
+static void imx6ull_spinor_resource_init(add_res_callback_t callback)
+{
+    device_add_child(nexus, "sunxi_spi", 0);
+    callback("sunxi_spi", SYS_RES_MEMORY, 0, FMC_REG_PBASE, FMC_REG_PBASE + FMC_REG_OFFSIZE, FMC_REG_OFFSIZE);
+    //callback("sunxi_spi", SYS_RES_MEMORY, 1, FMC_MEM_PBASE, FMC_MEM_PBASE + FMC_MEM_OFFSIZE, FMC_MEM_OFFSIZE);
+}
+//#endif
+
+void machine_resource_init(add_res_callback_t callback)
+{
+    if (callback == NULL) {
+        return;
+    }
+
+//#if LOSCFG_DRIVERS_UART
+    uart_add_device(callback);
+//#endif
+
+//#if defined (LOSCFG_DRIVERS_MTD_SPI_NOR_SUNXI)
+    imx6ull_spinor_resource_init(callback);
+//#endif
+}
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/board/include/asm/hal_platform_ints.h openharmony_100ask/vendor/nxp/imx6ull/board/include/asm/hal_platform_ints.h
--- openharmony/vendor/nxp/imx6ull/board/include/asm/hal_platform_ints.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/board/include/asm/hal_platform_ints.h	2020-10-31 00:27:40.752668470 +0800
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef PLATFORM_HAL_PLATFORM_INTS_H
+#define PLATFORM_HAL_PLATFORM_INTS_H
+
+#include"los_typedef.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+/**
+ * Maximum number of supported hardware devices that generate hardware interrupts.
+ * The maximum number of hardware devices that generate hardware interrupts is 128.
+ */
+#define OS_HWI_MAX_NUM                  160
+
+/**
+ * Maximum interrupt number.
+ */
+
+#define OS_HWI_MAX                      ((OS_HWI_MAX_NUM) - 1)
+
+/**
+ * Minimum interrupt number.
+ */
+
+#define OS_HWI_MIN                      0
+
+/**
+ * Maximum usable interrupt number.
+ */
+
+#define OS_USER_HWI_MAX                 OS_HWI_MAX
+
+/**
+ * Minimum usable interrupt number.
+ */
+
+#define OS_USER_HWI_MIN                 OS_HWI_MIN
+
+#define NUM_HAL_INTERRUPT_CNTPSIRQ      29
+#define NUM_HAL_INTERRUPT_CNTPNSIRQ     30
+#define OS_TICK_INT_NUM                 NUM_HAL_INTERRUPT_CNTPSIRQ // use secure physical timer for now
+
+#define NUM_HAL_INTERRUPT_TIMER0        37
+#define NUM_HAL_INTERRUPT_TIMER1        37
+#define NUM_HAL_INTERRUPT_TIMER2        38
+#define NUM_HAL_INTERRUPT_TIMER3        38
+
+#define NUM_HAL_INTERRUPT_UART0         58
+#define NUM_HAL_INTERRUPT_UART1         40
+#define NUM_HAL_INTERRUPT_UART2         41
+
+#define NUM_HAL_INTERRUPT_GPIO0         48
+#define NUM_HAL_INTERRUPT_GPIO1         49
+#define NUM_HAL_INTERRUPT_GPIO2         50
+#define NUM_HAL_INTERRUPT_GPIO3         51
+#define NUM_HAL_INTERRUPT_GPIO4         52
+#define NUM_HAL_INTERRUPT_GPIO5         53
+#define NUM_HAL_INTERRUPT_GPIO6         54
+#define NUM_HAL_INTERRUPT_GPIO7         55
+#define NUM_HAL_INTERRUPT_GPIO8         56
+#define NUM_HAL_INTERRUPT_GPIO9         57
+
+#define NUM_HAL_INTERRUPT_SDIO          62
+#define NUM_HAL_INTERRUPT_SDIO1         63
+
+#define NUM_HAL_INTERRUPT_FMC           64
+#define NUM_HAL_INTERRUPT_ETH           65
+
+#define NUM_HAL_INTERRUPT_DMAC          70
+#define NUM_HAL_INTERRUPT_USB_XHCI      71
+#define NUM_HAL_INTERRUPT_USB_DEV       71
+
+#define NUM_HAL_INTERRUPT_TIMER         NUM_HAL_INTERRUPT_TIMER0
+#define NUM_HAL_INTERRUPT_HRTIMER       NUM_HAL_INTERRUPT_TIMER3
+
+#define NUM_HAL_INTERRUPT_NONE          -1
+
+#define NUM_HAL_ISR_MIN                 OS_HWI_MIN
+#define NUM_HAL_ISR_MAX                 1020
+#define NUM_HAL_ISR_COUNT               (NUM_HAL_ISR_MAX - NUM_HAL_ISR_MIN + 1)
+
+#define IO_ADDRESS(x)       (x)
+
+#define HAL_READ_UINT8(addr, data)  READ_UINT8(data, addr)
+
+#define HAL_WRITE_UINT8(addr, data) WRITE_UINT8(data, addr)
+
+#define HAL_READ_UINT32(addr, data) READ_UINT32(data, addr)
+
+#define HAL_WRITE_UINT32(addr, data) WRITE_UINT32(data, addr)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+#endif // PLATFORM_HAL_PLATFORM_INTS_H
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/board/include/asm/platform.h openharmony_100ask/vendor/nxp/imx6ull/board/include/asm/platform.h
--- openharmony/vendor/nxp/imx6ull/board/include/asm/platform.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/board/include/asm/platform.h	2020-10-31 00:27:40.752668470 +0800
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __ASM_PLATFORM_H__
+#define __ASM_PLATFORM_H__
+
+#include "menuconfig.h"
+#include "los_bitmap.h"
+#include "asm/hal_platform_ints.h"
+//#include "hisoc/timer.h"
+//#include "hisoc/uart.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+/*------------------------------------------------
+ * GIC reg base address
+ *------------------------------------------------*/
+#define GIC_BASE_ADDR             IO_DEVICE_ADDR(0x00a00000) // IO_DEVICE_ADDR(0x10300000)
+#define GICD_OFFSET               0x1000     /* interrupt distributor offset */
+#define GICC_OFFSET               0x2000     /* CPU interface register offset */
+
+#define FMC_MEM_PBASE             0x14000000
+#define FMC_MEM_OFFSIZE           0x8
+#define FMC_REG_PBASE             0x10000000
+#define FMC_REG_OFFSIZE           0xdc
+
+#define PERIPH_REG_BASE           IO_DEVICE_ADDR(0x12000000)
+#define IO_CTL_REG_VBASE          IO_DEVICE_ADDR(0x10F00000)
+
+#define SDIO0_REG_PBASE           0x10010000
+#define SDIO1_REG_PBASE           0x10020000
+#define MMC_REG_OFFSIZE           0x600
+
+#define ETH_REG_PBASE             0x10040000
+#define ETH_REG_BASE              IO_DEVICE_ADDR(0x10040000)
+#define ETH_REG_OFFSIZE           0x2000
+#define DMAC_REG_BASE             IO_DEVICE_ADDR(0x100b0000)
+#define IO_MUX_REG_BASE           IO_DEVICE_ADDR(0x100c0000)
+
+#define IO_CTL_REG_BASE           IO_DEVICE_ADDR(0x10FF0000)
+
+#define GPIO_REG_BASE             IO_DEVICE_ADDR(0x120b0000)
+#define GPIO0_REG_BASE            (GPIO_REG_BASE + 0x0000)
+#define GPIO1_REG_BASE            (GPIO_REG_BASE + 0x1000)
+#define GPIO2_REG_BASE            (GPIO_REG_BASE + 0x2000)
+#define GPIO3_REG_BASE            (GPIO_REG_BASE + 0x3000)
+#define GPIO4_REG_BASE            (GPIO_REG_BASE + 0x4000)
+#define GPIO5_REG_BASE            (GPIO_REG_BASE + 0x5000)
+#define GPIO6_REG_BASE            (GPIO_REG_BASE + 0x6000)
+#define GPIO7_REG_BASE            (GPIO_REG_BASE + 0x7000)
+#define GPIO8_REG_BASE            (GPIO_REG_BASE + 0x8000)
+#define GPIO9_REG_BASE            (GPIO_REG_BASE + 0x9000)
+
+#define SPI0_REG_BASE             IO_DEVICE_ADDR(0x12070000)
+#define SPI1_REG_BASE             IO_DEVICE_ADDR(0x12071000)
+
+#define I2C0_REG_PBASE            0x12060000
+#define I2C1_REG_PBASE            0x12061000
+#define I2C2_REG_PBASE            0x12062000
+#define I2C0_REG_BASE             IO_DEVICE_ADDR(0x12060000)
+#define I2C1_REG_BASE             IO_DEVICE_ADDR(0x12061000)
+#define I2C2_REG_BASE             IO_DEVICE_ADDR(0x12062000)
+
+#define UART0_REG_PBASE           0x02020000
+ 
+#define UART0_REG_BASE            IO_DEVICE_ADDR(UART0_REG_PBASE)
+#define UART1_REG_BASE            IO_DEVICE_ADDR(0x12041000)
+#define UART2_REG_BASE            IO_DEVICE_ADDR(0x12042000)
+
+//#define UART0_REG_PBASE           0x12040000
+#define UART1_REG_PBASE           0x12041000
+#define UART2_REG_PBASE           0x12042000
+
+#if (CONSOLE_UART == UART0)
+    #define UART_BASE             UART0_REG_BASE
+    #define UART0_INT_NUM    NUM_HAL_INTERRUPT_UART0
+#elif (CONSOLE_UART == UART1)
+    #define UART_BASE             UART1_REG_BASE
+    #define UART0_INT_NUM    NUM_HAL_INTERRUPT_UART1
+#elif (CONSOLE_UART == UART2)
+    #define UART_BASE             UART2_REG_BASE
+    #define UART0_INT_NUM    NUM_HAL_INTERRUPT_UART2
+#endif
+
+#define MISC_REG_BASE             IO_DEVICE_ADDR(0x12028000)
+#define SYS_CTRL_REG_BASE         IO_DEVICE_ADDR(0x12020000)
+#define CRG_REG_BASE              IO_DEVICE_ADDR(0x12010000)
+
+#define TIMER0_ENABLE             BIT(16)
+#define TIMER1_ENABLE             BIT(17)
+#define TIMER2_ENABLE             BIT(18)
+#define TIMER3_ENABLE             BIT(19)
+
+#define TIMER0_REG_BASE           IO_DEVICE_ADDR(0x12000000)
+#define TIMER1_REG_BASE           IO_DEVICE_ADDR(0x12000020)
+#define TIMER2_REG_BASE           IO_DEVICE_ADDR(0x12001000)
+#define TIMER3_REG_BASE           IO_DEVICE_ADDR(0x12001020)
+
+#define TIMER_TICK_REG_BASE       TIMER0_REG_BASE   /* timer for tick */
+#define TIMER_TICK_ENABLE         TIMER0_ENABLE
+#define TIMER_TIME_REG_BASE       TIMER1_REG_BASE   /* timer for time */
+#define TIMER_TIME_ENABLE         TIMER1_ENABLE
+#define HRTIMER_TIMER_REG_BASE    TIMER3_REG_BASE /* timer for hrtimer */
+#define HRTIMER_TIMER_ENABLE      TIMER3_ENABLE
+
+#define DDR_MEM_BASE              0x40000000
+#define CACHE_ALIGNED_SIZE        64
+
+#define write_reg_bit(value, offset, addr) ({ \
+        unsigned long t, mask; \
+        mask = 1 << (offset); \
+        t = GET_UINT32(addr); \
+        t &= ~mask;            \
+        t |= (value << (offset)) & mask; \
+        WRITE_UINT32(t, addr);   \
+    })
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/board/include/board.h openharmony_100ask/vendor/nxp/imx6ull/board/include/board.h
--- openharmony/vendor/nxp/imx6ull/board/include/board.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/board/include/board.h	2020-10-31 00:27:40.752668470 +0800
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __BOARD_CONFIG_H__
+#define __BOARD_CONFIG_H__
+
+#include "menuconfig.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+/* physical memory base and size */
+#define DDR_MEM_ADDR            0x80000000
+#define DDR_MEM_SIZE            0x18000000   /* reseved 128M for ramfs and framebuffer */
+
+#define DDR_RAMFS_ADDR (DDR_MEM_ADDR + DDR_MEM_SIZE)
+#define DDR_RAMFS_SIZE 0x7C00000  /* 64+60M */
+
+#define LCD_FB_BASE    (DDR_RAMFS_ADDR + DDR_RAMFS_SIZE)
+#define LCD_FB_SIZE    0x400000  /* 4M */
+
+/* Peripheral register address base and size */
+#define PERIPH_PMM_BASE         0x00a00000
+#define PERIPH_PMM_SIZE         0x02300000
+
+#define KERNEL_VADDR_BASE       0x40000000
+#define KERNEL_VADDR_SIZE       DDR_MEM_SIZE
+
+#define SYS_MEM_BASE            DDR_MEM_ADDR
+#define SYS_MEM_SIZE_DEFAULT    0x2000000
+#define SYS_MEM_END             (SYS_MEM_BASE + SYS_MEM_SIZE_DEFAULT)
+
+#define EXC_INTERACT_MEM_SIZE        0x100000
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/board/include/clock.h openharmony_100ask/vendor/nxp/imx6ull/board/include/clock.h
--- openharmony/vendor/nxp/imx6ull/board/include/clock.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/board/include/clock.h	2020-10-31 00:27:40.752668470 +0800
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __HISOC_CLOCK_H__
+#define __HISOC_CLOCK_H__
+
+#include "asm/platform.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define    PERI_CRG12        (CRG_REG_BASE + 0x30)
+
+/*-----------------------------------------------------------------------
+ * cpu_init configuration
+ * if bit[13:12] = 1b, AXI = 200M
+ *----------------------------------------------------------------------*/
+/*lint -e160 */
+#define get_bus_clk() 50000000
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/board/include/platform_config.h openharmony_100ask/vendor/nxp/imx6ull/board/include/platform_config.h
--- openharmony/vendor/nxp/imx6ull/board/include/platform_config.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/board/include/platform_config.h	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __PLATFORM_CONFIG_H__
+#define __PLATFORM_CONFIG_H__
+
+#include "clock.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define LOSCFG_PLATFORM_HWI_LIMIT       96
+#define OS_SYS_CLOCK                    50000000
+#define LOSCFG_BASE_CORE_TICK_HW_TIME   YES
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/board/include/reset_shell.h openharmony_100ask/vendor/nxp/imx6ull/board/include/reset_shell.h
--- openharmony/vendor/nxp/imx6ull/board/include/reset_shell.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/board/include/reset_shell.h	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _RESET_SHELL_H
+#define _RESET_SHELL_H
+#include "los_task.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+
+typedef VOID* (*STORAGE_HOOK_FUNC)(VOID*);
+
+typedef struct tagHookFuncNode {
+    STORAGE_HOOK_FUNC  pHandler;
+    VOID *pParam;
+    struct tagHookFuncNode *pNext;
+}Hook_Func_Node;
+
+extern Hook_Func_Node *g_hook_func_node;
+
+UINT32 osReHookFuncAdd(STORAGE_HOOK_FUNC handler, VOID *param);
+UINT32 osReHookFuncDel(STORAGE_HOOK_FUNC handler);
+VOID osReHookFuncHandle(VOID);
+extern void cmd_reset(void);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/board/include/spinor.h openharmony_100ask/vendor/nxp/imx6ull/board/include/spinor.h
--- openharmony/vendor/nxp/imx6ull/board/include/spinor.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/board/include/spinor.h	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __HISOC_SPINOR_H__
+#define __HISOC_SPINOR_H__
+
+#include "asm/platform.h"
+#include "asm/io.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define PERI_CRG48                (CRG_REG_BASE + 0x00C0)
+#define PERI_CRG48_RST            (1 << 0)
+#define PERI_CRG48_CLKEN            (1 << 1)
+#define PERI_CRG48_CLK_24M            (0 << 2)
+#define PERI_CRG48_CLK_75M            ((0 << 3) | (1 << 2))
+#define PERI_CRG48_CLK_125M            ((1 << 2) | (1 << 3))
+
+#define SFC_ADDR_MODE_REG            (0x8C)
+#define SFC_ADDR_MODE_MASK            (0x80)
+#define SFC_CLSEL_MASK                (0xC)
+#define SFC_PERI_CLKDIV1_SHIFT            (28)
+#define SFC_PERI_CLKDIV1_MASK            (0xF)
+
+/*****************************************************************************/
+#undef GET_SFC_ADDR_MODE
+#define GET_SFC_ADDR_MODE ({ \
+    int start_up_mode = 0; \
+    start_up_mode = readl(IO_ADDRESS(SYS_CTRL_REG_BASE + SFC_ADDR_MODE_REG)); \
+    start_up_mode &= SFC_ADDR_MODE_MASK; \
+    start_up_mode; })
+
+/*****************************************************************************/
+static inline void hisfc350_set_system_clock(unsigned clock, int clk_en)
+{
+    unsigned int regval = readl(PERI_CRG48);
+
+    regval = regval & (~SFC_CLSEL_MASK);
+
+    if (clock) {
+        regval &= ~SFC_CLSEL_MASK;
+        regval |= clock & SFC_CLSEL_MASK;
+    } else {
+        regval &= ~SFC_CLSEL_MASK;
+        regval |= PERI_CRG48_CLK_24M; /* Default Clock */
+    }
+
+    if (clk_en)
+        regval |= PERI_CRG48_CLKEN;
+
+    if (regval != readl(PERI_CRG48))
+        writel(regval, (PERI_CRG48));
+}
+
+/*****************************************************************************/
+static inline void hisfc350_get_best_clock(unsigned int *clock)
+{
+    int ix;
+    int clk_reg;
+
+#define CLK_2X(_clk)    (((_clk) + 1) >> 1)
+    unsigned int sysclk[] = {
+        CLK_2X(24),    PERI_CRG48_CLK_24M,
+        CLK_2X(75),    PERI_CRG48_CLK_75M,
+        CLK_2X(125),    PERI_CRG48_CLK_125M,
+        0, 0,
+    };
+#undef CLK_2X
+
+    clk_reg = PERI_CRG48_CLK_24M;
+    for (ix = 0; sysclk[ix]; ix += 2) {
+        if (*clock < sysclk[ix])
+            break;
+        clk_reg = sysclk[ix + 1];
+    }
+
+    *clock = clk_reg;
+}
+
+/*****************************************************************************/
+#ifdef CONFIG_HISFC350_SHOW_CYCLE_TIMING
+static inline char * hisfc350_get_clock_str(unsigned int clk_reg)
+{
+    static char buffer[40];
+
+    /* calculate reference PERI_CLKDIV1[31:28] */
+    SFC_PR(BT_DBG, "clk_reg=0x%0x.\n", clk_reg);
+    clk_reg = 216 / ((clk_reg >> SFC_PERI_CLKDIV1_SHIFT)
+                & SFC_PERI_CLKDIV1_MASK);
+    (VOID)sprintf_s(buffer, sizeof(buffer), "%dM", clk_reg);
+
+    return buffer;
+}
+#endif /* CONFIG_PERI_SHOW_CYCLE_TIMING */
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+
+#endif
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/board/include/uart.h openharmony_100ask/vendor/nxp/imx6ull/board/include/uart.h
--- openharmony/vendor/nxp/imx6ull/board/include/uart.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/board/include/uart.h	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,129 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef __HISOC_UART_H__
+#define __HISOC_UART_H__
+
+#include "asm/platform.h"
+#include "los_typedef.h"
+#include "los_base.h"
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define CONFIG_UART0_BAUDRATE   115200
+#define CONFIG_UART_CLK_INPUT   (24000000) // 24M or 6M
+
+#define UART0                   0
+#define UART1                   1
+#define UART2                   2
+
+#define UART0_ENABLE  1
+#define UART1_ENABLE  1
+#define UART2_ENABLE  1
+
+#define UART0_DMA_RX_PERI       4
+#define UART1_DMA_RX_PERI       6
+#define UART2_DMA_RX_PERI       8
+
+#define uart_pin_mux_cfg(uart_num) ({ \
+        if (UART0 == uart_num) {} \
+        else if (UART1 == uart_num) { \
+        WRITE_UINT16(0x01, IO_MUX_REG_BASE + 0x07C); \
+        WRITE_UINT16(0x01, IO_MUX_REG_BASE + 0x084); \
+        } \
+        else if (UART2 == uart_num) { \
+        WRITE_UINT16(0x01, IO_MUX_REG_BASE + 0x088); \
+        WRITE_UINT16(0x01, IO_MUX_REG_BASE + 0x08C); \
+        } \
+        else if (UART3 ==uart_num) { \
+        WRITE_UINT16(0x02, IO_MUX_REG_BASE + 0x078); \
+        WRITE_UINT16(0x02, IO_MUX_REG_BASE + 0x080); \
+        } \
+        })
+#define  uart_clk_cfg(uart_num, flag)  ({ \
+        unsigned int tmp = 0; \
+        tmp = GET_UINT32(CRG_REG_BASE + 0x0198); \
+        if (flag) \
+            tmp |= (1<<(uart_num + 24)); \
+        else \
+            tmp &= ~(1<<(uart_num + 24)); \
+        WRITE_UINT32(tmp, CRG_REG_BASE + 0x0198); \
+        })
+#define  get_uart_dma_peri(uart_num) ({ \
+        unsigned int peri_num = -1; \
+        if (UART0 == uart_num) \
+        peri_num = UART0_DMA_RX_PERI; \
+        else if (UART1 == uart_num) \
+        peri_num = UART1_DMA_RX_PERI; \
+        else if (UART2 == uart_num) \
+        peri_num = UART2_DMA_RX_PERI; \
+        else if (UART3 == uart_num) \
+        peri_num = UART3_DMA_RX_PERI; \
+        peri_num; \
+        })
+
+
+#define TTYS0                               "/dev/ttyS0"
+
+#define CONSOLE_UART                        UART0
+
+#define CONSOLE_UART_BAUDRATE               115200
+#define UART_NUM    4
+#if (CONSOLE_UART == UART0)
+    #define TTY_DEVICE                "/dev/uartdev-0"
+    #define UART_REG_BASE             UART0_REG_BASE
+    #define NUM_HAL_INTERRUPT_UART    NUM_HAL_INTERRUPT_UART0
+#elif (CONSOLE_UART == UART1)
+    #define TTY_DEVICE                "/dev/uartdev-1"
+    #define UART_REG_BASE             UART1_REG_BASE
+    #define NUM_HAL_INTERRUPT_UART    NUM_HAL_INTERRUPT_UART1
+#elif (CONSOLE_UART == UART2)
+    #define TTY_DEVICE                "/dev/uartdev-2"
+    #define UART_REG_BASE             UART2_REG_BASE
+    #define NUM_HAL_INTERRUPT_UART    NUM_HAL_INTERRUPT_UART2
+#endif
+
+#ifdef LOSCFG_PLATFORM_HISI_AMP
+#undef TTY_DEVICE
+#define TTY_DEVICE                "/dev/virt-tty"
+#endif
+
+typedef struct {
+    UINT32 base;
+    INT32 msec_timeout;
+    int isr_vector;
+} channel_data_t;
+
+extern void uart_init(void);
+extern void uart_interrupt_unmask(void);
+extern int uart_hwiCreate(void);
+extern UINT8 uart_getc(void);
+extern char uart_fputc(char c, void *f);
+
+extern UINT32 UartPutsReg(UINTPTR base, const CHAR *s, UINT32 len, BOOL isLock);
+extern VOID UartPuts(const CHAR *s, UINT32 len, BOOL isLock);
+
+#define UART_WITHOUT_LOCK 0
+#define UART_WITH_LOCK    1
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/board/Makefile openharmony_100ask/vendor/nxp/imx6ull/board/Makefile
--- openharmony/vendor/nxp/imx6ull/board/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/board/Makefile	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,9 @@
+include $(LITEOSTOPDIR)/config.mk
+
+MODULE_NAME := $(notdir $(shell pwd))
+
+LOCAL_SRCS :=  board.c bsd_board.c
+
+LOCAL_FLAGS :=  -I$(LITEOSTOPDIR)/../../vendor/nxp/imx6ull/driver/imx6ull-uart
+
+include $(MODULE)
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/config/device_info/device_info.hcs openharmony_100ask/vendor/nxp/imx6ull/config/device_info/device_info.hcs
--- openharmony/vendor/nxp/imx6ull/config/device_info/device_info.hcs	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/config/device_info/device_info.hcs	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,60 @@
+ root {
+    device_info {
+        match_attr = "hdf_manager";
+        template host {
+            hostName = "";
+            priority = 100;
+            template device{
+                template deviceNode {
+                    policy = 0;
+                    priority = 100;
+                    preload = 0;
+                    permission = 0664;
+                    moduleName = "";
+                    serviceName = "";
+                    deviceMatchAttr = "";
+                }
+            }
+        }
+        platform :: host {
+            hostName = "platform_host";
+            priority = 50;
+
+           device_hello :: device {
+                device0 :: deviceNode {
+                    policy = 2;
+                    priority = 50;
+                    permission = 0644;
+                    moduleName = "HDF_PLATFORM_HELLO";
+                    serviceName = "hello_service";
+                }
+            }
+
+            device_i2c :: device {
+                device0 :: deviceNode {
+                    policy = 1;
+                    priority = 50;
+                    permission = 0644;
+                    moduleName = "HDF_PLATFORM_I2C";
+                    serviceName = "HDF_PLATFORM_I2C_0";
+                    deviceMatchAttr = "nxp_imx6ull_i2c_0";
+                }
+            }
+           device_touchscreen :: device {
+                device0 :: deviceNode {
+                    policy = 2;
+                    priority = 100;
+                    preload = 0;
+                    permission = 0666;
+                    moduleName = "HDF_TOUCHSCREEN";
+                    serviceName = "HDF_TOUCHSCREEN";
+                }
+            }
+
+        }
+        storage :: host {
+        }
+        media :: host {
+        }
+    }
+}
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/config/hdf.hcs openharmony_100ask/vendor/nxp/imx6ull/config/hdf.hcs
--- openharmony/vendor/nxp/imx6ull/config/hdf.hcs	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/config/hdf.hcs	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,6 @@
+#include "device_info/device_info.hcs"
+#include "i2c/i2c_config.hcs"
+
+root {
+    module = "hisilicon,hi35xx_chip";
+}
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/config/i2c/i2c_config.hcs openharmony_100ask/vendor/nxp/imx6ull/config/i2c/i2c_config.hcs
--- openharmony/vendor/nxp/imx6ull/config/i2c/i2c_config.hcs	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/config/i2c/i2c_config.hcs	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,21 @@
+root {
+    platfrom {
+        i2c_config {
+            template i2c_controller {
+                bus = 0;
+                match_attr = "";
+                reg_pbase = 0x021A4000;
+                reg_size = 0xd1;
+                irq = 0;
+                freq = 400000;
+                clk = 50000000;
+            }
+
+            controller_0x021A4000 :: i2c_controller {
+                bus = 0;
+                match_attr = "nxp_imx6ull_i2c_0";
+            }
+
+        }
+    }
+}
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/config/Makefile openharmony_100ask/vendor/nxp/imx6ull/config/Makefile
--- openharmony/vendor/nxp/imx6ull/config/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/config/Makefile	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,9 @@
+# Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
+
+include $(LITEOSTOPDIR)/../../drivers/hdf/lite/lite.mk
+
+MODULE_NAME := hdf_config
+
+LOCAL_PLATFORM_HCS_SRC := hdf.hcs
+
+include $(HDF_DRIVER)
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/hello/hello_drv.c openharmony_100ask/vendor/nxp/imx6ull/driver/hello/hello_drv.c
--- openharmony/vendor/nxp/imx6ull/driver/hello/hello_drv.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/hello/hello_drv.c	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,124 @@
+
+
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: ft6236 touch driver implement.
+ * Author: zhaihaipeng
+ * Create: 2020-07-25
+ */
+
+#include <stdlib.h>
+#include <asm/io.h>
+#include <fs/fs.h>
+#include <fs_poll_pri.h>
+#include <los_queue.h>
+#include <poll.h>
+#include <user_copy.h>
+#include <securec.h>
+#include "gpio_if.h"
+#include "hdf_device_desc.h"
+#include "hdf_log.h"
+#include "osal_irq.h"
+#include "osal_mem.h"
+#include "osal_time.h"
+
+
+static int g_hello_val = 0x12345678;
+
+
+static int hello_open(FAR struct file *filep)
+{
+    HDF_LOGI("%s: called", __func__);
+    if (filep == NULL) {
+        HDF_LOGE("%s: fliep is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    return HDF_SUCCESS;
+}
+
+static int hello_close(FAR struct file *filep)
+{
+    HDF_LOGI("%s: called", __func__);
+
+    if (filep == NULL) {
+        HDF_LOGE("%s: fliep is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    return HDF_SUCCESS;
+}
+
+static ssize_t hello_read(FAR struct file *filep, FAR char *buffer, size_t buflen)
+{
+	if (buflen == 4) {
+		LOS_ArchCopyToUser(buffer, &g_hello_val, 4);
+		return 4;
+	}
+	return 0;
+}
+
+static const struct file_operations_vfs g_helloDevOps = {
+    .open   = hello_open,
+    .close  = hello_close,
+    .read   = hello_read,
+    .write  = NULL,
+    .seek   = NULL,
+    .ioctl  = NULL,
+    .mmap   = NULL,
+    .unlink = NULL,
+};
+
+
+int32_t hello_dispatch(struct HdfDeviceIoClient *client, int cmdId, struct HdfSBuf *data, struct HdfSBuf *reply)
+{
+    (void)client;
+    (void)cmdId;
+    if (data == NULL || reply == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_FAILURE;
+    }
+
+	if (!HdfSbufWriteInt32(reply, g_hello_val))
+	{
+        HDF_LOGE("%s: reply int32 fail", __func__);
+	}
+	
+    return HDF_SUCCESS;
+}
+
+int32_t hello_bind(struct HdfDeviceObject *object)
+{
+    if (object == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    static struct IDeviceIoService service = {
+        .object = {0},
+        .Dispatch = hello_dispatch,
+    };
+    object->service = &service;
+    return HDF_SUCCESS;
+}
+
+int hello_init(struct HdfDeviceObject *object)
+{
+    (void)object;
+    HDF_LOGI("%s: enter", __func__);
+    int ret = register_driver("/dev/hello", &g_helloDevOps, 0666, NULL);
+    if (ret != 0) {
+        HDF_LOGE("%s: register hello dev failed, ret %d", __func__, ret);
+        return HDF_FAILURE;
+    }
+    HDF_LOGI("%s: exit succ", __func__);
+    return HDF_SUCCESS;
+
+}
+
+struct HdfDriverEntry g_HelloDevEntry = {
+    .moduleVersion = 1,
+    .moduleName = "HDF_PLATFORM_HELLO",
+    .Bind = hello_bind,
+    .Init = hello_init,
+};
+
+HDF_INIT(g_HelloDevEntry);
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/hello/Makefile openharmony_100ask/vendor/nxp/imx6ull/driver/hello/Makefile
--- openharmony/vendor/nxp/imx6ull/driver/hello/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/hello/Makefile	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,17 @@
+include $(LITEOSTOPDIR)/config.mk
+include $(LITEOSTOPDIR)/../../drivers/hdf/lite/lite.mk
+
+MODULE_NAME := $(notdir $(shell pwd))
+
+LOCAL_SRCS :=  hello_drv.c
+
+LOCAL_FLAGS :=  -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/osal \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/core \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/ability/sbuf/include \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/utils/include \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/lite/include/host
+
+LOCAL_CFLAGS += -fstack-protector-strong
+
+include $(HDF_DRIVER)
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcd.c openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcd.c
--- openharmony/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcd.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcd.c	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,87 @@
+/****************************************************************************
+ * boards/arm/am335x/beaglebone-black/src/am335x_lcd.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <stdint.h>
+#include <assert.h>
+#include <errno.h>
+#include <debug.h>
+
+#include "fb.h"
+
+#include "imx6ull_lcdc.h"
+#include "imx6ull_lcd.h"
+
+
+static lcd_params lcd_7_0_params = {
+	.name = "lcd_7.0",
+	.pins_pol = {
+		.de    = INVERT,	/* normal: 低电平表示使能输出 */
+		.vclk  = INVERT,	/* normal: 在上升降沿获取数据*/
+		.hsync = NORMAL,    /* normal: 低脉冲*/
+		.vsync = NORMAL, 	/* normal: 低脉冲*/
+	},
+	.time_seq = {
+		/* 垂直方向 */
+		.tvp=	3, /* vysnc脉冲宽度 */
+		.tvb=	20,  /* 上边黑框, Vertical Back porch */
+		.tvf=	12,  /* 下边黑框, Vertical Front porch */
+
+		/* 水平方向 */
+		.thp=	20, /* hsync脉冲宽度 */
+		.thb=	140,  /* 左边黑框, Horizontal Back porch */
+		.thf=	160,  /* 右边黑框, Horizontal Front porch */
+
+		.vclk=	51,  /* MHz */
+	},
+	.xres = 1024,
+	.yres = 600,
+	.bpp  = 16,       
+	.fb_base = LCD_FB_BASE,
+	.fb_vbase = LCD_FB_VBASE,
+};
+
+
+int up_fbinitialize(int display)
+{
+	PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+	Imx6ull_lcd_controller_init(&lcd_7_0_params);
+	PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+	return 0;
+}
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcdc.c openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcdc.c
--- openharmony/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcdc.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcdc.c	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,581 @@
+/****************************************************************************
+ * arch/arm/src/imx6/imx6ull_lcdc.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * This driver derives from the LPC54xx LCD driver but also includes
+ * information from the FreeBSD AM335x LCD driver which was released under
+ * a two-clause BSD license:
+ *
+ *   Copyright 2013 Oleksandr Tymoshenko <gonzo@freebsd.org>
+ *   All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+
+#include <stdint.h>
+#include <string.h>
+#include <semaphore.h>
+#include <errno.h>
+#include <debug.h>
+//#include <nuttx/nx/nxglib.h>
+
+#include "fb.h"
+
+#include "imx6ull_lcdc.h"
+#include "imx6ull_lcd.h"
+
+typedef uint16_t nxgl_mxpixel_t;
+
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+
+void imx6ull_lcdclear(nxgl_mxpixel_t color);
+
+/* Get information about the video controller configuration and the
+ * configuration of each color plane.
+ */
+
+static int getvideoinfo(FAR struct fb_vtable_s *vtable,
+             FAR struct fb_videoinfo_s *vinfo);
+static int getplaneinfo(FAR struct fb_vtable_s *vtable, int planeno,
+             FAR struct fb_planeinfo_s *pinfo);
+static int getoverlayinfo(struct fb_vtable_s *vtable, int overlayno,  struct fb_overlayinfo_s *oinfo);
+
+static ssize_t fb_mmap(struct fb_vtable_s *vtable, LosVmMapRegion *region);
+
+/* The following is provided only if the video hardware supports RGB color
+ * mapping
+ */
+
+#ifdef CONFIG_FB_CMAP
+static int imx6ull_getcmap(FAR struct fb_vtable_s *vtable,
+             FAR struct fb_cmap_s *cmap);
+static int imx6ull_putcmap(FAR struct fb_vtable_s *vtable,
+             FAR const struct fb_cmap_s *cmap);
+#endif
+
+static int fb_open(struct fb_vtable_s *vtable)
+{
+	return 0;
+}
+
+static int fb_ioctl(struct fb_vtable_s *vtable, int cmd, unsigned long arg)
+{
+	
+	//PRINT_RELEASE("%s %s %d. cmd = 0x%x\n", __FILE__, __FUNCTION__, __LINE__, cmd);
+	return 0;
+}
+
+
+/* The framebuffer object -- There is no private state information in this
+ * framebuffer driver.
+ */
+
+struct fb_vtable_s g_fbinterface =
+{
+  .getvideoinfo  = getvideoinfo,
+  .getplaneinfo  = getplaneinfo,
+  .getoverlayinfo = getoverlayinfo,
+  .fb_mmap = fb_mmap,
+  .fb_ioctl = fb_ioctl,
+  .fb_open  = fb_open,
+#ifdef CONFIG_FB_CMAP
+  .getcmap       = imx6ull_getcmap,
+  .putcmap       = imx6ull_putcmap,
+#endif
+};
+
+
+static p_lcd_params g_lcd_params;
+
+
+static ssize_t fb_mmap(struct fb_vtable_s *vtable, LosVmMapRegion *region)
+{
+	VADDR_T vaddr = region->range.base;
+	LosVmSpace *space = LOS_SpaceGet(vaddr);
+	size_t size;
+	uint32_t flag;
+	size_t fblen  = (g_lcd_params->xres * g_lcd_params->bpp + 7) >> 3; 		
+	fblen *= g_lcd_params->yres;
+	
+		
+    size = region->range.size;
+    if (size == 0 || (size & ~PAGE_MASK) || size > fblen || region->pgOff != 0) 
+	{
+        return -EINVAL;
+    }
+
+    flag = region->regionFlags;
+    flag &= (~VM_MAP_REGION_FLAG_CACHED);
+    flag |= VM_MAP_REGION_FLAG_UNCACHED;
+
+    if (LOS_ArchMmuMap(&space->archMmu, vaddr, g_lcd_params->fb_base, size >> PAGE_SHIFT, flag) <= 0)
+	{
+        return -EAGAIN;
+    }
+
+    return 0;
+}
+
+
+/****************************************************************************
+ * Name: getvideoinfo
+ ****************************************************************************/
+static unsigned char fake_gram[64];
+
+static int getvideoinfo(struct fb_vtable_s *vtable, struct fb_videoinfo_s *vinfo)
+{
+        vinfo->nplanes = 1;
+        return 0;
+}
+
+static int getplaneinfo(struct fb_vtable_s *vtable, int planeno, struct fb_planeinfo_s *pinfo)
+{
+        pinfo->fbmem = fake_gram;
+        pinfo->fblen = 64;
+        pinfo->bpp = 16;
+        return 0;
+}
+
+static int getoverlayinfo(struct fb_vtable_s *vtable, int overlayno,  struct fb_overlayinfo_s *oinfo)
+{
+        oinfo->fbmem = fake_gram;
+        oinfo->fblen = 64;
+        return 0;
+}
+/****************************************************************************
+ * Name: imx6ull_getcmap
+ ****************************************************************************/
+
+#ifdef CONFIG_FB_CMAP
+static int imx6ull_getcmap(FAR struct fb_vtable_s *vtable,
+                          FAR struct fb_cmap_s *cmap)
+{
+  return -ENOSYS;
+}
+#endif
+
+/****************************************************************************
+ * Name: imx6ull_putcmap
+ ****************************************************************************/
+
+#ifdef CONFIG_FB_CMAP
+static int imx6ull_putcmap(FAR struct fb_vtable_s *vtable,
+                          FAR const struct fb_cmap_s *cmap)
+{
+  return -ENOSYS;
+}
+#endif
+
+
+/*LCD控制器基地址*/
+#define LCD_CONTROLLER_BASE 		IO_DEVICE_ADDR(0x21C8000) 
+
+/*时钟相关基地址*/
+#define CCM_BASE                    IO_DEVICE_ADDR(0x20C4000)
+#define CCM_ANALOG_BASE             IO_DEVICE_ADDR(0x20C8000)
+
+/*LCD管脚复用相关基地址*/
+#define SW_MUX_PART_LCD_BASE		IO_DEVICE_ADDR(0x20E0104)
+
+/*LCD管脚硬件属性相关基地址*/
+#define SW_PAD_PART_LCD_BASE		IO_DEVICE_ADDR(0x20E0390)
+
+#define SW_MUX			  (SW_MUX_CTL_Type*)SW_MUX_PART_LCD_BASE
+#define SW_PAD            (SW_PAD_CTL_Type*)SW_PAD_PART_LCD_BASE
+#define CCM               ((CCM_Type *)CCM_BASE)
+#define CCM_ANALOG        ((CCM_ANALOG_Type *)CCM_ANALOG_BASE)
+#define LCDIF             ((LCDIF_Type *)LCD_CONTROLLER_BASE)
+
+
+
+/*背光GPIO相关寄存器*/
+static volatile unsigned int* GPIO1_IO08_PAD =  (volatile unsigned int*)IO_DEVICE_ADDR(0x20E0308);  /*背光引脚硬件属性地址*/; 
+static volatile unsigned int* GPIO1_GDIR     =   (volatile unsigned int*)IO_DEVICE_ADDR(0x209C000);
+static volatile unsigned int* GPIO1_DR        =   (volatile unsigned int*)IO_DEVICE_ADDR(0x209C004); 
+
+static void imx6ull_delay(volatile int d)
+{
+	while (d--);
+}
+
+static void Imx6ull_lcd_controller_enable(void)
+{	
+	LCDIF->CTRL |= 1<<0; /* 使能6ULL的LCD控制器 */
+}
+static void Imx6ull_lcd_controller_disable(void)
+{
+	LCDIF->CTRL &= ~(1<<0); /* 关闭6ULL的LCD控制器 */
+}
+
+static void Imx6ull_lcd_io_init(void)
+{
+	unsigned int* p_tmp;
+	unsigned int i = 0 ;
+
+	p_tmp = (unsigned int*)(SW_MUX);
+	for(i = 0 ; i < 29 ; i++)		       /*共29个信号需要复用设置*/
+	{
+		*p_tmp = 0;		   /*29个寄存器设置为0表示LCD复用功能*/
+		p_tmp++;
+	}	
+	/*LCD引脚硬件属性关键bit
+     * [16]     :   0  : 施密特特性关闭  
+	 * [15:14]  :   0  : 内部上拉22K电阻（默认）
+	 * [13]     :   0  : Keeper
+	 * [12]     :   0  : 关闭KEEP
+	 * [11]     :   0  : 关闭开漏输出
+	 * [7:6]    :   2  : 输出频率100Mhz
+	 * [5:3]    :   7  : 驱动能力为R0/7 
+	 * [0]      :   1  : 适用于高频信号
+	 */
+	
+    p_tmp = (unsigned int*)(SW_PAD);
+	for(i = 0 ; i < 29 ; i++)	
+	{
+		*p_tmp = 0;
+		*p_tmp |= 0xB9;
+		 p_tmp++;
+	}
+
+	/* 背光GPIO初始化 */
+
+	
+	*GPIO1_IO08_PAD     = 0xB9  ;							/*背光引脚硬件属性设置*/
+
+    *GPIO1_GDIR        |= (1<<8);                             /*背光GPIO设置为输出模式*/
+
+	*GPIO1_DR          |= (1<<8);                             /*背光默认关闭*/
+
+
+}
+
+
+void Imx6ull_lcd_controller_init(p_lcd_params plcdparams)
+{	
+     int bpp_mode;
+
+	 g_lcd_params = plcdparams;
+	 
+	 //PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+	 Imx6ull_lcd_io_init();  /*LCD控制器占据的GPIO引脚初始化*/
+	 //PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+
+	 /* 时钟计算公式如下
+	  * Video PLL output frequency(PLL5)= Fref * (DIV_SELECT + NUM/DENOM)
+	  * PLL5_MAIN_CLK                    = PLL5 / POST_DIV_SELECT / VIDEO_DIV
+	  * LCDIF1_CLK_ROOT                  = PLL5_MAIN_CLK /LCDIF1_PRED / LCDIF1_PODF
+      * 
+      * 输出LCDIF1_CLK_ROOT七寸屏：51.2Mhz
+      * DIV_SELECT             = 32 （寄存器相应位设置为32）
+      * NUM                    = 0  （寄存器相应位设置为0）
+      * DENOM                  = 0  （寄存器相应位设置为0）
+      * POST_DIV_SELECT        = 1  （寄存器相应位设置为2）
+      * VIDEO_DIV              = 1  （寄存器相应位设置为0）
+      * LCDIF1_PRED			   = 3  （寄存器相应位设置为2）
+      * LCDIF1_PODF            = 5  （寄存器相应位设置为4）
+      *
+	  */ 
+	  
+	 /*
+	  *为方便使用 ，不使用小数分频器
+	  *NUM	   = 0
+	  *DENOM = 0
+	  *公式简化为：
+	  * Video PLL output frequency(PLL5)= Fref * DIV_SELECT
+	  * PLL5_MAIN_CLK                    = PLL5 / POST_DIV_SELECT / VIDEO_DIV
+	  * LCDIF1_CLK_ROOT                  = PLL5_MAIN_CLK /LCDIF1_PRED / LCDIF1_PODF
+	  */
+	  CCM_ANALOG->PLL_VIDEO_NUM   = 0; 	 
+	  CCM_ANALOG->PLL_VIDEO_DENOM = 0;	 
+
+	  
+	 /* 初始化寄存器：CCM_ANALOG_PLL_VIDEOn
+	  * [20:19 ] :  2  : 不分频  
+	  * [15:14]  :  0  : PLL5的时钟源为外部24Mhz晶振，默认为零无需设置
+	  * [13]	 :  1  : 使能VIDEO PLL时钟
+	  * [6:0]	 : 32  : 倍频值（DIV_SELECT）
+	  *公式简化为：
+	  * Video PLL output frequency(PLL5)= 24Mhz * 32  = 768Mhz
+	  * PLL5_MAIN_CLK                    = 768Mhz   / POST_DIV_SELECT / 1
+	  * LCDIF1_CLK_ROOT                  = PLL5_MAIN_CLK /LCDIF1_PRED / LCDIF1_PODF
+	  */
+		 CCM_ANALOG->PLL_VIDEO =  (2 << 19) | (1 << 13) | (32<< 0); 
+	 
+	 /* 初始化寄存器：CCM_ANALOG_MISC2n
+	  * [31:30 ] :  0  : 不分频  
+	  *公式简化为：
+	  * Video PLL output frequency(PLL5)= 24Mhz * 32  = 768Mhz
+	  * PLL5_MAIN_CLK                    = 768Mhz   / 1 / 1
+	  * LCDIF1_CLK_ROOT                  = 768Mhz /LCDIF1_PRED / LCDIF1_PODF 
+	  * 默认已为零，不需设置
+	  * CCM_ANALOG->MISC2 &= ~(3 << 30);
+	  */
+	  
+	 /*
+	  *初始化寄存器：CCM_CSCDR2
+      * [17:15] :	2  : PLL5_MAIN_CLK为驱动时钟源  
+      * [12:14] :	2  : 分频系数为3
+      * [11-9 ] :	0  : 时钟源选择LCDIF1_PRED分频后的时钟
+      *公式简化为：
+	  * Video PLL output frequency(PLL5)= 24Mhz * 32  = 768Mhz
+	  * PLL5_MAIN_CLK                    = 768Mhz   / 1 / 1
+	  * LCDIF1_CLK_ROOT                  = 768Mhz /3 / LCDIF1_PODF 
+	  */
+		 CCM->CSCDR2 &= ~(7 << 15); 	   
+		 CCM->CSCDR2 |=  (2 << 15);  
+		 
+		 CCM->CSCDR2 &= ~(7 << 12); 	 
+		 CCM->CSCDR2 |=  (2 << 12); 						 
+	 
+		 CCM->CSCDR2 &= ~(7 << 9);
+
+	 /*
+	  *初始化寄存器：CCM_CBCMR
+	  *[25:23] :  4  :分频系数LCDIF1_PODF设置为5  
+	  *公式简化为：
+	  * Video PLL output frequency(PLL5)= 24Mhz * 32  = 768Mhz
+	  * PLL5_MAIN_CLK                    = 768Mhz   / 1 / 1
+	  * LCDIF1_CLK_ROOT                  = 768Mhz /3 / 5  
+	  *
+	  *最终得到F1_CLK_ROOT     =51.2Mhz
+	  * 
+	  */
+		 CCM->CBCMR &= ~(7 << 23);					 
+		 CCM->CBCMR |=	4 << 23;	/*[25:23] :4 : 表示5分频*/
+
+   	  /* 重新设置时钟后，需要软复位LCD控制器，让LCD控制器像素时钟同步*/
+		 LCDIF->CTRL  = 1<<31;   
+
+	  /*软复位需要花费好几个时钟周期，这里需要一些时间等待*/
+	  imx6ull_delay(100);
+
+	  /*同步像素时钟结束*/
+		LCDIF->CTRL  = 0<<31; /* 取消复位 */
+
+
+	/*LCD控制寄存器初始化*/
+		
+	/* 
+     * 初始化LCD控制器的CTRL寄存器
+     * [19]       :  1      : DOTCLK和DVI modes需要设置为1 
+     * [17]       :  1      : 设置为1工作在DOTCLK模式
+     * [15:14]    : 00      : 输入数据不交换（小端模式）默认就为0，不需设置
+     * [13:12]    : 00      : CSC数据不交换（小端模式）默认就为0，不需设置
+     * [11:10]    : 11		: 数据总线为24bit
+     * [9:8]    根据显示屏资源文件bpp来设置：8位0x1 ， 16位0x0 ，24位0x3
+     * [5]        :  1      : 设置elcdif工作在主机模式
+     * [1]        :  0      : 24位数据均是有效数据，默认就为0，不需设置
+	 */
+     bpp_mode = plcdparams->bpp == 8  ? 0x1 :(plcdparams->bpp == 16 ? 0x0 : 0x3);  /* 0x3: 24bpp or 32bpp */
+     
+	 LCDIF->CTRL |= (1 << 19) | (1 << 17) |(3 << 10) | (bpp_mode << 8) | (1 << 5) ;
+
+     /* [3]当bpp为16时，数据格式为ARGB555*/
+	 if(plcdparams->bpp == 16)
+	 {
+	 	LCDIF->CTRL |= 1<<3;
+	 }
+	 /*
+      * 设置ELCDIF的寄存器CTRL1
+      * 根据bpp设置，bpp为24或32才设置
+      * [19:16]  : 111  :表示ARGB传输格式模式下，传输24位无压缩数据，A通道不用传输）
+	  */	
+	 if(plcdparams->bpp == 24 || plcdparams->bpp == 32)
+	 {		
+	 		LCDIF->CTRL1 &= ~(0xf << 16); 
+		 	LCDIF->CTRL1 |=  (0x7 << 16); 
+	 }
+	 	
+	  /*
+      * 设置ELCDIF的寄存器TRANSFER_COUNT寄存器
+      * [31:16]  : 垂直方向上的像素个数  
+      * [15:0]   : 水平方向上的像素个数
+	  */
+	LCDIF->TRANSFER_COUNT  = (plcdparams->yres << 16) | (plcdparams->xres << 0);
+
+	/*
+	 * 设置ELCDIF的VDCTRL0寄存器
+	 * [29] 0 : VSYNC输出  ，默认为0，无需设置
+	 * [28] 1 : 在DOTCLK模式下，设置1硬件会产生使能ENABLE输出
+	 * [27] 0 : VSYNC低电平有效  ,根据屏幕配置文件将其设置为0
+	 * [26] 0 : HSYNC低电平有效 , 根据屏幕配置文件将其设置为0
+	 * [25] 1 : DOTCLK下降沿有效 ，根据屏幕配置文件将其设置为1
+	 * [24] 1 : ENABLE信号高电平有效，根据屏幕配置文件将其设置为1
+	 * [21] 1 : 帧同步周期单位，DOTCLK mode设置为1
+	 * [20] 1 : 帧同步脉冲宽度单位，DOTCLK mode设置为1
+	 * [17:0] :  vysnc脉冲宽度 
+	 */
+		LCDIF->VDCTRL0 = (1 << 28)|( plcdparams->pins_pol.vsync << 27)\
+						|( plcdparams->pins_pol.hsync << 26)\
+						|( plcdparams->pins_pol.vclk << 25)\
+						|(plcdparams->pins_pol.de << 24)\
+						|(1 << 21)|(1 << 20)|( plcdparams->time_seq.tvp << 0);
+
+	/*
+	 * 设置ELCDIF的VDCTRL1寄存器
+	 * 设置垂直方向的总周期:上黑框tvb+垂直同步脉冲tvp+垂直有效高度yres+下黑框tvf
+	 */  	
+	  LCDIF->VDCTRL1 = plcdparams->time_seq.tvb + plcdparams->time_seq.tvp + plcdparams->yres + plcdparams->time_seq.tvf;  
+
+    /*
+	 * 设置ELCDIF的VDCTRL2寄存器
+	 * [18:31]  : 水平同步信号脉冲宽度
+	 * [17: 0]   : 水平方向总周期
+	 * 设置水平方向的总周期:左黑框thb+水平同步脉冲thp+水平有效高度xres+右黑框thf
+	 */ 
+
+	 LCDIF->VDCTRL2 = (plcdparams->time_seq.thp << 18) | (plcdparams->time_seq.thb + plcdparams->time_seq.thp + plcdparams->xres + plcdparams->time_seq.thf);
+
+	 /*
+	  * 设置ELCDIF的VDCTRL3寄存器
+	  * [27:16] ：水平方向上的等待时钟数 =thb + thp
+      * [15:0]  : 垂直方向上的等待时钟数 = tvb + tvp
+      */ 
+      
+     LCDIF->VDCTRL3 = ((plcdparams->time_seq.thb + plcdparams->time_seq.thp) << 16) | (plcdparams->time_seq.tvb + plcdparams->time_seq.tvp);
+
+	 /*
+	  * 设置ELCDIF的VDCTRL4寄存器
+	  * [18]     使用VSHYNC、HSYNC、DOTCLK模式此为置1
+      * [17:0]  : 水平方向的宽度
+      */ 
+
+	 LCDIF->VDCTRL4 = (1<<18) | (plcdparams->xres);
+
+	 /*
+      * 设置ELCDIF的CUR_BUF和NEXT_BUF寄存器
+      * CUR_BUF    :  当前显存地址
+	  * NEXT_BUF :    下一帧显存地址
+	  * 方便运算，都设置为同一个显存地址
+	  */ 
+	  
+	LCDIF->CUR_BUF  =  plcdparams->fb_base;
+    LCDIF->NEXT_BUF =  plcdparams->fb_base;
+	//PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+
+	imx6ull_lcdclear(0xF800);
+	//PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+	Imx6ull_lcd_controller_enable();
+	//PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+	
+}
+
+/****************************************************************************
+ * Name: up_fbgetvplane
+ *
+ * Description:
+ *   Return a a reference to the framebuffer object for the specified video
+ *   plane of the specified plane.  Many OSDs support multiple planes of video.
+ *
+ * Input Parameters:
+ *   display - In the case of hardware with multiple displays, this
+ *     specifies the display.  Normally this is zero.
+ *   vplane - Identifies the plane being queried.
+ *
+ * Returned Value:
+ *   A non-NULL pointer to the frame buffer access structure is returned on
+ *   success; NULL is returned on any failure.
+ *
+ ****************************************************************************/
+
+FAR struct fb_vtable_s *up_fbgetvplane(int display, int vplane)
+{
+  //PRINT_RELEASE("vplane: %d\n", vplane);
+  if (vplane == 0)
+    {
+      return &g_fbinterface;
+    }
+  else
+    {
+      return NULL;
+    }
+}
+
+/****************************************************************************
+ * Name: up_fbuninitialize
+ *
+ * Description:
+ *   Uninitialize the framebuffer support for the specified display.
+ *
+ * Input Parameters:
+ *   display - In the case of hardware with multiple displays, this
+ *     specifies the display.  Normally this is zero.
+ *
+ * Returned Value:
+ *   None
+ *
+ ****************************************************************************/
+
+void up_fbuninitialize(int display)
+{
+	Imx6ull_lcd_controller_disable();
+}
+
+/****************************************************************************
+ * Name:  imx6ull_lcdclear
+ *
+ * Description:
+ *   This is a non-standard LCD interface just for the AM335x.  Clearing
+ *   the display in the normal way by writing a sequences of runs that
+ *   covers the entire display can be slow.  Here the display is cleared by
+ *   simply setting all VRAM memory to the specified color.
+ *
+ ****************************************************************************/
+
+void imx6ull_lcdclear(nxgl_mxpixel_t color)
+{
+  uint16_t *dest = (uint16_t *)g_lcd_params->fb_vbase;
+
+  int x, y;
+  //PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+
+  for (y = 0; y < g_lcd_params->yres; y++)
+  	for (x = 0; x < g_lcd_params->xres; x++)
+    {
+      *dest++ = color;
+    }
+	//PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+	
+}
+
+int imx6ull_fb_init(void)
+{
+	return fb_register(0, 0);	
+}
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcdc.h openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcdc.h
--- openharmony/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcdc.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcdc.h	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,313 @@
+/****************************************************************************
+ * arch/arm/src/imx6ull/imx6ull_lcdc.h
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * The LCD driver derives from the LPC54xx LCD driver but also includes
+ * information from the FreeBSD AM335x LCD driver which was released under
+ * a two-clause BSD license:
+ *
+ *   Copyright 2013 Oleksandr Tymoshenko <gonzo@freebsd.org>
+ *   All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/* The LPC54 LCD driver uses the common framebuffer interfaces declared in
+ * include/nuttx/video/fb.h.
+ */
+
+#ifndef _IMX6ULL_LCDC_H
+#define _IMX6ULL_LCDC_H
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "imx6ull_lcd.h"
+
+/*根据IMX6ULL芯片手册<<18.6 CCM Memory Map/Register Definition>>658页，定义CCM Memory的结构体,*/
+typedef struct {
+  volatile unsigned int CCR;                              
+  volatile unsigned int CCDR;                            
+  volatile  unsigned int CSR;                            
+  volatile unsigned int CCSR;                           
+  volatile unsigned int CACRR;                             
+  volatile unsigned int CBCDR;                            
+  volatile unsigned int CBCMR;                            
+  volatile unsigned int CSCMR1;                            
+  volatile unsigned int CSCMR2;                            
+  volatile unsigned int CSCDR1;                            
+  volatile unsigned int CS1CDR;                            
+  volatile unsigned int CS2CDR;                            
+  volatile unsigned int CDCDR;                             
+  volatile unsigned int CHSCCDR;                          
+  volatile unsigned int CSCDR2;                            
+  volatile unsigned int CSCDR3;                            
+       unsigned char RESERVED_0[8];
+  volatile  unsigned int CDHIPR;                          
+       unsigned char RESERVED_1[8];
+  volatile unsigned int CLPCR;                             
+  volatile unsigned int CISR;                            
+  volatile unsigned int CIMR;                             
+  volatile unsigned int CCOSR;                            
+  volatile unsigned int CGPR;                             
+  volatile unsigned int CCGR0;                           
+  volatile unsigned int CCGR1;                            
+  volatile unsigned int CCGR2;                           
+  volatile unsigned int CCGR3;                            
+  volatile unsigned int CCGR4;                            
+  volatile unsigned int CCGR5;                            
+  volatile unsigned int CCGR6;                             
+       unsigned char RESERVED_2[4];
+  volatile unsigned int CMEOR;                            
+} CCM_Type;
+
+
+typedef struct 	{
+  volatile unsigned int IOMUXC_SW_MUX_CTL_PAD_LCD_CLK;
+  volatile unsigned int IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE;
+  volatile unsigned int IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC;
+  volatile unsigned int IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC;
+  volatile unsigned int IOMUXC_SW_MUX_CTL_PAD_LCD_RESET;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA00;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA01;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA02;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA03;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA04;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA05;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA06;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA07;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA08;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA09;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA10;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA11;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA12;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA13;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA14;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA15;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA16;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA17;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA18;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA19;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA20;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA21;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA22;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA23;
+}SW_MUX_CTL_Type;
+		  			 		  						  					  				 	   		  	  	 	  
+typedef struct   {
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_CLK;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_RESET;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA00;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA01;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA02;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA03;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA04;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA05;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA06;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA07;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA08;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA09;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA10;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA11;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA12;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA13;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA14;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA15;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA16;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA17;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA18;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA19;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA20;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA21;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA22;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA23;
+}SW_PAD_CTL_Type;
+
+/*根据IMX6ULL芯片手册<<18.7 CCM Analog Memory Map/Register Definition>>的710页，定义CCM Analog Memory的结构体,*/
+typedef struct {
+  volatile unsigned int PLL_ARM;                         
+  volatile unsigned int PLL_ARM_SET;                       
+  volatile unsigned int PLL_ARM_CLR;                       
+  volatile unsigned int PLL_ARM_TOG;                       
+  volatile unsigned int PLL_USB1;                         
+  volatile unsigned int PLL_USB1_SET;                     
+  volatile unsigned int PLL_USB1_CLR;                     
+  volatile unsigned int PLL_USB1_TOG;                      
+  volatile unsigned int PLL_USB2;                          
+  volatile unsigned int PLL_USB2_SET;                     
+  volatile unsigned int PLL_USB2_CLR;                      
+  volatile unsigned int PLL_USB2_TOG;                     
+  volatile unsigned int PLL_SYS;                           
+  volatile unsigned int PLL_SYS_SET;                      
+  volatile unsigned int PLL_SYS_CLR;                     
+  volatile unsigned int PLL_SYS_TOG;                     
+  volatile unsigned int PLL_SYS_SS;                      
+       unsigned char RESERVED_0[12];
+  volatile unsigned int PLL_SYS_NUM;                      
+       unsigned char RESERVED_1[12];
+  volatile unsigned int PLL_SYS_DENOM;                     
+       unsigned char RESERVED_2[12];
+  volatile unsigned int PLL_AUDIO;                         
+  volatile unsigned int PLL_AUDIO_SET;                     
+  volatile unsigned int PLL_AUDIO_CLR;                    
+  volatile unsigned int PLL_AUDIO_TOG;                   
+  volatile unsigned int PLL_AUDIO_NUM;                   
+       unsigned char RESERVED_3[12];
+  volatile unsigned int PLL_AUDIO_DENOM;                 
+       unsigned char RESERVED_4[12];
+  volatile unsigned int PLL_VIDEO;                        
+  volatile unsigned int PLL_VIDEO_SET;                     
+  volatile unsigned int PLL_VIDEO_CLR;                     
+  volatile unsigned int PLL_VIDEO_TOG;                    
+  volatile unsigned int PLL_VIDEO_NUM;                     
+       unsigned char RESERVED_5[12];
+  volatile unsigned int PLL_VIDEO_DENOM;                   
+       unsigned char RESERVED_6[28];
+  volatile unsigned int PLL_ENET;                         
+  volatile unsigned int PLL_ENET_SET;                    
+  volatile unsigned int PLL_ENET_CLR;                      
+  volatile unsigned int PLL_ENET_TOG;                      
+  volatile unsigned int PFD_480;                           
+  volatile unsigned int PFD_480_SET;                       
+  volatile unsigned int PFD_480_CLR;                    
+  volatile unsigned int PFD_480_TOG;                      
+  volatile unsigned int PFD_528;                        
+  volatile unsigned int PFD_528_SET;                     
+  volatile unsigned int PFD_528_CLR;                   
+  volatile unsigned int PFD_528_TOG;                     
+       unsigned char RESERVED_7[64];
+  volatile unsigned int MISC0;                            
+  volatile unsigned int MISC0_SET;                        
+  volatile unsigned int MISC0_CLR;                       
+  volatile unsigned int MISC0_TOG;                        
+  volatile unsigned int MISC1;                             
+  volatile unsigned int MISC1_SET;                        
+  volatile unsigned int MISC1_CLR;                        
+  volatile unsigned int MISC1_TOG;                         
+  volatile unsigned int MISC2;                             
+  volatile unsigned int MISC2_SET;                         
+  volatile unsigned int MISC2_CLR;                       
+  volatile unsigned int MISC2_TOG;                         
+} CCM_ANALOG_Type;
+
+/*根据IMX6ULL芯片手册<<34.6 eLCDIF Memory Map/Register Definition>>2165页，定义eLCDIF的结构体,*/
+typedef struct {
+  volatile unsigned int CTRL;                              
+  volatile unsigned int CTRL_SET;                        
+  volatile unsigned int CTRL_CLR;                         
+  volatile unsigned int CTRL_TOG;                         
+  volatile unsigned int CTRL1;                             
+  volatile unsigned int CTRL1_SET;                         
+  volatile unsigned int CTRL1_CLR;                       
+  volatile unsigned int CTRL1_TOG;                       
+  volatile unsigned int CTRL2;                            
+  volatile unsigned int CTRL2_SET;                       
+  volatile unsigned int CTRL2_CLR;                        
+  volatile unsigned int CTRL2_TOG;                        
+  volatile unsigned int TRANSFER_COUNT;   
+       unsigned char RESERVED_0[12];
+  volatile unsigned int CUR_BUF;                          
+       unsigned char RESERVED_1[12];
+  volatile unsigned int NEXT_BUF;                        
+       unsigned char RESERVED_2[12];
+  volatile unsigned int TIMING;                          
+       unsigned char RESERVED_3[12];
+  volatile unsigned int VDCTRL0;                         
+  volatile unsigned int VDCTRL0_SET;                      
+  volatile unsigned int VDCTRL0_CLR;                     
+  volatile unsigned int VDCTRL0_TOG;                     
+  volatile unsigned int VDCTRL1;                          
+       unsigned char RESERVED_4[12];
+  volatile unsigned int VDCTRL2;                          
+       unsigned char RESERVED_5[12];
+  volatile unsigned int VDCTRL3;                          
+       unsigned char RESERVED_6[12];
+  volatile unsigned int VDCTRL4;                           
+       unsigned char RESERVED_7[12];
+  volatile unsigned int DVICTRL0;    
+  	   unsigned char RESERVED_8[12];
+  volatile unsigned int DVICTRL1;                         
+       unsigned char RESERVED_9[12];
+  volatile unsigned int DVICTRL2;                        
+       unsigned char RESERVED_10[12];
+  volatile unsigned int DVICTRL3;                        
+       unsigned char RESERVED_11[12];
+  volatile unsigned int DVICTRL4;                          
+       unsigned char RESERVED_12[12];
+  volatile unsigned int CSC_COEFF0;  
+  	   unsigned char RESERVED_13[12];
+  volatile unsigned int CSC_COEFF1;                        
+       unsigned char RESERVED_14[12];
+  volatile unsigned int CSC_COEFF2;                        
+       unsigned char RESERVED_15[12];
+  volatile unsigned int CSC_COEFF3;                        
+       unsigned char RESERVED_16[12];
+  volatile unsigned int CSC_COEFF4;   
+  	   unsigned char RESERVED_17[12];
+  volatile unsigned int CSC_OFFSET;  
+       unsigned char RESERVED_18[12];
+  volatile unsigned int CSC_LIMIT;  
+       unsigned char RESERVED_19[12];
+  volatile unsigned int DATA;                              
+       unsigned char RESERVED_20[12];
+  volatile unsigned int BM_ERROR_STAT;                     
+       unsigned char RESERVED_21[12];
+  volatile unsigned int CRC_STAT;                        
+       unsigned char RESERVED_22[12];
+  volatile  unsigned int STAT;                             
+       unsigned char RESERVED_23[76];
+  volatile unsigned int THRES;                             
+       unsigned char RESERVED_24[12];
+  volatile unsigned int AS_CTRL;                           
+       unsigned char RESERVED_25[12];
+  volatile unsigned int AS_BUF;                            
+       unsigned char RESERVED_26[12];
+  volatile unsigned int AS_NEXT_BUF;                     
+       unsigned char RESERVED_27[12];
+  volatile unsigned int AS_CLRKEYLOW;                    
+       unsigned char RESERVED_28[12];
+  volatile unsigned int AS_CLRKEYHIGH;                   
+       unsigned char RESERVED_29[12];
+  volatile unsigned int SYNC_DELAY;                      
+} LCDIF_Type;
+
+
+void Imx6ull_lcd_controller_init(p_lcd_params plcdparams);
+
+#endif /* __ARCH_ARM_SRC_AM335X_AM335X_LCDC_H */
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcd.h openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcd.h
--- openharmony/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcd.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-fb/imx6ull_lcd.h	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,58 @@
+
+#ifndef _IMX6ULL_LCD_H
+#define _IMX6ULL_LCD_H
+
+enum {
+	NORMAL = 0,
+	INVERT = 1,
+};
+
+/* NORMAL : 正常
+ * INVERT : 取反
+ */
+typedef struct pins_polarity {
+	int de;    /* normal: 高电平使能数据 */
+	int vclk;  /* normal: 在下降沿获取数据 */
+	int hsync; /* normal:高脉冲 */
+	int vsync; /* normal:高脉冲  */
+}pins_polarity, *p_pins_polarity;
+
+typedef struct time_sequence {
+	/* 垂直方向 */
+	int tvp; /*  vysnc脉冲宽度 */
+	int tvb; /*上边黑框 , Vertical Back porch */
+	int tvf; /*下边黑框, Vertical Front porch */
+
+	/* 水平方向 */
+	int thp; /* hsync脉冲宽度 */
+	int thb; /* 左边黑框 ,Horizontal Back porch */
+	int thf; /* 右边黑框,Horizontal Front porch */
+
+	int vclk;
+}time_sequence, *p_time_sequence;
+
+
+typedef struct lcd_params {
+	
+	char *name;
+	
+	/*引脚极性参数*/
+	pins_polarity pins_pol;
+
+	/*时序参数*/
+	time_sequence time_seq;
+
+	/*分辨率*/
+	int xres;
+	int yres;
+	int bpp;
+
+	/*显存*/
+	unsigned int fb_base;
+	unsigned int fb_vbase;
+	
+}lcd_params, *p_lcd_params;
+
+
+#endif
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/imx6ull-fb/Makefile openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-fb/Makefile
--- openharmony/vendor/nxp/imx6ull/driver/imx6ull-fb/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-fb/Makefile	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,7 @@
+include $(LITEOSTOPDIR)/config.mk
+
+MODULE_NAME := $(notdir $(shell pwd))
+
+LOCAL_SRCS :=  imx6ull_lcd.c  imx6ull_lcdc.c
+
+include $(MODULE)
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/imx6ull-i2c/i2c_dev.c openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-i2c/i2c_dev.c
--- openharmony/vendor/nxp/imx6ull/driver/imx6ull-i2c/i2c_dev.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-i2c/i2c_dev.c	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,466 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: hi35xx i2c driver user support.
+ * Author: yanghaizhou
+ * Create: 2020-08-11
+ */
+
+#include "i2c_dev.h"
+#include <fs/fs.h> /* from Nuttx */
+#include <limits.h>
+#include <stdio.h>
+#include "hdf_base.h"
+#include "hdf_device_desc.h"
+#include "hdf_log.h"
+#include "i2c_core.h"
+#include "i2c_if.h"
+#include "osal_mem.h"
+#include "user_copy.h"
+
+#define I2C_FS_MODE                 0660
+#define I2C_RDWR_IOCTL_MAX_MSGS     42
+#define I2C_BUF_MAX                 8192
+#define I2C_NAME_SIZE               32
+#define I2C_CNTLR_MAX               32
+
+struct I2cClient {
+    struct DevHandle *handle;
+    struct I2cHost *host;
+    uint16_t addr;
+    uint16_t flags;
+};
+
+static inline int32_t I2cMsgInitFromUser(struct I2cMsg *kMsgs, struct i2c_msg *uMsgs)
+{
+    int32_t ret;
+
+    kMsgs->len = uMsgs->len;
+    kMsgs->addr = uMsgs->addr;
+    kMsgs->flags = uMsgs->flags;
+    if ((uMsgs->flags & I2C_M_RD) != 0) {
+        return HDF_SUCCESS;
+    }
+    ret = LOS_CopyToKernel((void *)(kMsgs->buf), kMsgs->len, (void *)(uMsgs->buf), uMsgs->len);
+    return (ret == LOS_OK) ? HDF_SUCCESS : HDF_ERR_IO;
+}
+
+static inline int32_t I2cMsgBackToUser(struct I2cMsg *kMsgs, struct i2c_msg *uMsgs)
+{
+    int32_t ret;
+
+    if ((kMsgs->flags & I2C_M_RD) == 0) {
+        return HDF_SUCCESS;
+    }
+    ret = LOS_CopyFromKernel((void *)(uMsgs->buf), uMsgs->len, (void *)(kMsgs->buf), kMsgs->len);
+    return (ret == LOS_OK) ? HDF_SUCCESS : HDF_ERR_IO;
+}
+
+static inline int32_t I2cMsgsCopyBackToUser(I2cIoctlWrap *wrap,
+    struct I2cMsg *kMsgs, struct i2c_msg *uMsgs)
+{
+    int ret;
+    unsigned int i;
+
+    for (i = 0; i < wrap->nmsgs; i++) {
+        ret = I2cMsgBackToUser(&kMsgs[i], &uMsgs[i]);
+        if (ret != HDF_SUCCESS) {
+            break;
+        }
+    }
+    return ret;
+}
+
+static void I2cMsgsDestroy(struct I2cMsg *kMsgs, struct i2c_msg *uMsgs)
+{
+    if (kMsgs != NULL) {
+        if (kMsgs[0].buf != NULL) {
+            OsalMemFree(kMsgs[0].buf);
+            kMsgs[0].buf = NULL;
+        }
+    }
+    if (uMsgs != NULL) {
+        OsalMemFree(uMsgs);
+    }
+}
+
+static int32_t I2cMsgsCreateFromUser(I2cIoctlWrap *wrap,
+    struct I2cMsg **kMsgsPp, struct i2c_msg **uMsgsPp)
+{
+    int32_t ret;
+    size_t i;
+    size_t bufLen;
+    struct i2c_msg *uMsgs = NULL;
+    struct I2cMsg *kMsgs = NULL;
+    uint8_t *dataBuf = NULL;
+
+    uMsgs = (struct i2c_msg *)OsalMemCalloc((sizeof(*uMsgs) + sizeof(*kMsgs)) * wrap->nmsgs);
+    if (uMsgs == NULL) {
+        return HDF_ERR_MALLOC_FAIL;
+    }
+    kMsgs = (struct I2cMsg *)((uint8_t *)uMsgs + sizeof(*uMsgs) * wrap->nmsgs);
+
+    ret = LOS_CopyToKernel((void *)uMsgs, sizeof(*uMsgs) * wrap->nmsgs,
+        (void *)wrap->msgs, sizeof(*uMsgs) * wrap->nmsgs);
+    if (ret != LOS_OK) {
+        HDF_LOGE("%s: copy msgs from user fail!\n", __func__);
+        goto __ERR__;
+    }
+
+    for (i = 0, bufLen = 0; i < wrap->nmsgs; i++) {
+        if (uMsgs[i].buf == NULL || uMsgs[i].len == 0) {
+            ret = HDF_ERR_INVALID_PARAM;
+            goto __ERR__;
+        }
+        bufLen += uMsgs[i].len;
+    }
+    if (bufLen >= I2C_BUF_MAX) {
+        HDF_LOGE("%s: buf too long:%u\n", __func__, bufLen);
+        ret = HDF_ERR_INVALID_PARAM;
+        goto __ERR__;
+    }
+
+    dataBuf = (uint8_t *)OsalMemCalloc(bufLen);
+    if (dataBuf == NULL) {
+        ret = HDF_ERR_MALLOC_FAIL;
+        goto __ERR__;
+    }
+
+    for (i = 0; i < wrap->nmsgs; i++) {
+        kMsgs[i].buf = dataBuf;
+        dataBuf += uMsgs[i].len;
+        ret = I2cMsgInitFromUser(&kMsgs[i], &uMsgs[i]);
+        if (ret != HDF_SUCCESS) {
+            goto __ERR__;
+        }
+    }
+
+    *kMsgsPp = kMsgs;
+    *uMsgsPp = uMsgs;
+    return HDF_SUCCESS;
+
+__ERR__:
+    I2cMsgsDestroy(kMsgs, uMsgs);
+    return ret;
+}
+
+static int32_t I2cCntlrRead(struct DevHandle *handle, uint16_t addr,
+    uint8_t *buf, int16_t len, uint16_t flags)
+{
+    int32_t ret;
+    struct I2cMsg msg;
+
+    msg.addr = addr;
+    msg.buf = buf;
+    msg.len = len;
+    msg.flags = flags | I2C_FLAG_READ;
+
+    ret = I2cTransfer(handle, &msg, 1);
+    return (ret == 1) ? HDF_SUCCESS : ret;
+}
+
+ssize_t I2cFsRead(struct file *filep, char *buf, size_t count)
+{
+    int32_t ret;
+    uint8_t *kbuf = NULL;
+    struct I2cClient *client = filep->f_priv;
+
+    if (client == NULL) {
+        HDF_LOGE("%s: client is null!", __func__);
+        return 0;
+    }
+
+    kbuf = (uint8_t *)OsalMemCalloc(count);
+    if (kbuf == NULL) {
+        HDF_LOGE("%s: malloc kbuf fail!", __func__);
+        return 0;
+    }
+
+    ret = I2cCntlrRead(client->handle, client->addr, kbuf, count, client->flags);
+    HDF_LOGD("%s: I2cRead called, ret:%d", __func__, ret);
+
+    if (ret == HDF_SUCCESS) {
+        if (LOS_CopyFromKernel(buf, count, kbuf, count) != LOS_OK) {
+            HDF_LOGE("%s: copy from kernel fail:%d", __func__, ret);
+            ret = HDF_ERR_IO;
+        }
+    }
+    OsalMemFree(kbuf);
+    return (ret == HDF_SUCCESS) ? count : 0;
+}
+
+static int32_t I2cCntlrWrite(struct DevHandle *handle, uint16_t addr,
+    const uint8_t *buf, int16_t len, uint16_t flags)
+{
+    int32_t ret;
+    struct I2cMsg msg;
+
+    msg.addr = addr;
+    msg.buf = (uint8_t *)buf;
+    msg.len = len;
+    msg.flags = flags & (~I2C_FLAG_READ);
+
+    ret = I2cTransfer(handle, &msg, 1);
+    return (ret == 1) ? HDF_SUCCESS : ret;
+}
+
+
+ssize_t I2cFsWrite(struct file *filep, const char *buf, size_t count)
+{
+    int32_t ret;
+    uint8_t *kbuf = NULL;
+    struct I2cClient *client = filep->f_priv;
+
+    if (client == NULL) {
+        HDF_LOGE("%s: client is null!", __func__);
+        return 0;
+    }
+
+    kbuf = (uint8_t *)OsalMemCalloc(count);
+    if (kbuf == NULL) {
+        HDF_LOGE("%s: malloc kbuf fail!", __func__);
+        return 0;
+    }
+    if (LOS_CopyToKernel(kbuf, count, buf, count) != LOS_OK) {
+        HDF_LOGE("%s: copy to kernel fail!", __func__);
+        OsalMemFree(kbuf);
+        return 0;
+    }
+
+    ret = I2cCntlrWrite(client->handle, client->addr, kbuf, count, client->flags);
+    HDF_LOGD("%s: I2cWrite called, ret:%d", __func__, ret);
+
+    OsalMemFree(kbuf);
+    return (ret == HDF_SUCCESS) ? count : 0;
+}
+
+static int I2cIoctlReadWrite(const struct I2cClient *client, const void *arg)
+{
+    int ret;
+    I2cIoctlWrap wrap;
+    struct i2c_msg *uMsgs = NULL;
+    struct I2cMsg *kMsgs = NULL;
+
+    if (arg == NULL) {
+        HDF_LOGE("%s: arg is null!", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+
+    ret = LOS_CopyToKernel(&wrap, sizeof(wrap), (void *)arg, sizeof(wrap));
+    if (ret != LOS_OK) {
+        HDF_LOGE("%s: copy wrap fail!", __func__);
+        return HDF_ERR_IO;
+    }
+
+    if (wrap.msgs == NULL || wrap.nmsgs == 0 || wrap.nmsgs > I2C_RDWR_IOCTL_MAX_MSGS) {
+        HDF_LOGE("%s: wrap msgs is null or invalid num:%u!", __func__, wrap.nmsgs);
+        return HDF_ERR_INVALID_PARAM;
+    }
+
+    ret = I2cMsgsCreateFromUser(&wrap, &kMsgs, &uMsgs);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: recreate msgs fail!\n", __func__);
+        return ret;
+    }
+
+    ret = I2cTransfer(client->handle, kMsgs, wrap.nmsgs);
+    HDF_LOGD("%s: I2cTransfer called, ret:%d", __func__, ret);
+    if ((unsigned int)ret == wrap.nmsgs) {
+        ret = I2cMsgsCopyBackToUser(&wrap, kMsgs, uMsgs);
+        if (ret != HDF_SUCCESS) {
+            HDF_LOGE("%s: copy back fail! ret:%d", __func__, ret);
+        }
+    } else {
+        HDF_LOGD("%s: transfer fail, ret:%d, nmsgs:%u", __func__, ret, wrap.nmsgs);
+    }
+
+    I2cMsgsDestroy(kMsgs, uMsgs);
+    return ret;
+}
+
+static int I2cFsIoctl(struct file *filep, int cmd, unsigned long arg)
+{
+    int retval = ENOERR;
+    struct I2cClient *client = filep->f_priv;
+
+    switch (cmd) {
+        case IOCTL_SLAVE_FORCE:
+        case IOCTL_SLAVE:
+            if ((((client->flags & I2C_M_TEN) == 0) && arg > 0xfe) || (arg > 0x3ff)) {
+                HDF_LOGE("%s:Not support arg(%0d)!!!", __func__, arg);
+                retval = -EINVAL;
+                break;
+            }
+            client->addr = arg;
+            break;
+        case IOCTL_RDWR: {
+            retval = I2cIoctlReadWrite(client, (void *)(uintptr_t)arg);
+            break;
+        }
+        case IOCTL_16BIT_REG:
+            if (arg == 0) {
+                client->flags &= ~I2C_M_16BIT_REG;
+            } else {
+                client->flags |= I2C_M_16BIT_REG;
+            }
+            break;
+        case IOCTL_16BIT_DATA:
+            if (arg == 0) {
+                client->flags &= ~I2C_M_16BIT_DATA;
+            } else {
+                client->flags |= I2C_M_16BIT_DATA;
+            }
+            break;
+        case IOCTL_TENBIT:
+            if (arg == 0) {
+                client->flags &= ~I2C_M_TEN;
+            } else {
+                client->flags |= I2C_M_TEN;
+            }
+            break;
+        case IOCTL_PEC:
+        case IOCTL_RETRIES:
+        case IOCTL_TIMEOUT:
+        default:
+            HDF_LOGE("Not support cmd(%0d)!!!", cmd);
+            retval = -EINVAL;
+    }
+    return retval;
+}
+
+static int I2cFsOpen(struct file *filep)
+{
+    struct DevHandle *handle = NULL;
+    struct I2cClient *client = NULL;
+    struct inode *inode = filep->f_inode;
+    int16_t id = (int16_t)((uintptr_t)inode->i_private);
+
+    handle = I2cOpen(id);
+    if (handle == NULL) {
+        HDF_LOGE("%s:Fail to get host:%d handle!\n", __func__, id);
+        return -1;
+    }
+
+    client = (struct I2cClient *)OsalMemCalloc(sizeof(*client));
+    if (client == NULL) {
+        HDF_LOGE("%s:Fail to malloc client-%d!\n", __func__, id);
+        return -1;
+    }
+    client->handle = handle;
+
+    /* record the client as file private data */
+    filep->f_priv = client;
+    return 0;
+}
+
+static int I2cFsClose(struct file *filep)
+{
+    struct I2cClient *client = filep->f_priv;
+
+    if (client == NULL) {
+        HDF_LOGE("%s: has't opened!\n", __func__);
+        return 0;
+    }
+
+    if (client->handle == NULL) {
+        return 0;
+    }
+    I2cClose(client->handle);
+    client->handle = NULL;
+    OsalMemFree(client);
+    client = NULL;
+
+    filep->f_priv = NULL;
+    return 0;
+}
+
+static ssize_t I2cFsMap(FAR struct file* filep, FAR LosVmMapRegion *region)
+{
+    size_t size = region->range.size;
+
+    (void)filep;
+    PADDR_T paddr = region->pgOff << PAGE_SHIFT;
+    VADDR_T vaddr = region->range.base;
+    LosVmSpace *space = LOS_SpaceGet(vaddr);
+
+    if ((space == NULL) || ((paddr >= SYS_MEM_BASE) && (paddr < SYS_MEM_END))) {
+        return -EINVAL;
+    }
+
+    if (LOS_ArchMmuMap(&space->archMmu, vaddr, paddr, size >> PAGE_SHIFT, region->regionFlags) <= 0) {
+        return -EAGAIN;
+    }
+
+    return 0;
+}
+
+static const struct file_operations_vfs g_i2cFops = {
+    .open = I2cFsOpen,
+    .close = I2cFsClose,
+    .read = I2cFsRead,
+    .write = I2cFsWrite,
+    .ioctl = I2cFsIoctl,
+    .mmap = I2cFsMap,
+};
+
+int32_t I2cAddVfsById(int16_t id)
+{
+#ifdef LOSCFG_FS_VFS
+    int32_t ret;
+    char *name = NULL;
+
+    if (id < 0 || id >= I2C_CNTLR_MAX) {
+        HDF_LOGE("%s: id:%d exceed max:%d", __func__, id);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    name = (char *)OsalMemCalloc(I2C_NAME_SIZE);
+    if (name == NULL) {
+        HDF_LOGE("%s: malloc name fail!", __func__);
+        return HDF_ERR_MALLOC_FAIL;
+    }
+    /* create /dev/i2c-x device files for the i2c adatpers */
+    ret = snprintf_s(name, I2C_NAME_SIZE, I2C_NAME_SIZE - 1, "/dev/i2c-%d", id);
+    if (ret < 0) {
+        HDF_LOGE("I2cAddVfsById: format name fail! ret:%d\n", ret);
+        OsalMemFree(name);
+        return ret;
+    }
+    ret = register_driver(name, &g_i2cFops, I2C_FS_MODE, (void *)((uintptr_t)id));
+    if (ret != 0) {
+        HDF_LOGE("I2cAddVfsById: register %s fail! ret:%d\n", name, ret);
+    }
+    OsalMemFree(name);
+    return ret;
+#else /* LOSCFG_FS_VFS */
+    return HDF_SUCCESS;
+#endif
+}
+
+void I2cRemoveVfsById(int16_t id)
+{
+#ifdef LOSCFG_FS_VFS
+    int32_t ret;
+    char *name = NULL;
+
+    if (id < 0 || id >= I2C_CNTLR_MAX) {
+        HDF_LOGE("%s: id:%d exceed max:%d", __func__, id);
+        return;
+    }
+    name = (char *)OsalMemCalloc(I2C_NAME_SIZE);
+    if (name == NULL) {
+        HDF_LOGE("%s: malloc name fail!", __func__);
+        return;
+    }
+    /* create /dev/i2c-x device files for the i2c controllers */
+    ret = snprintf_s(name, I2C_NAME_SIZE, I2C_NAME_SIZE - 1, "/dev/i2c-%d", id);
+    if (ret < 0) {
+        HDF_LOGE("I2cAddVfsById: format name fail! ret:%d\n", ret);
+        OsalMemFree(name);
+        return;
+    }
+    ret = unregister_driver(name);
+    if (ret != 0) {
+        HDF_LOGE("I2cRegisterFs: unregister %s fail!\n", name);
+    }
+    OsalMemFree(name);
+#endif /* LOSCFG_FS_VFS */
+}
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/imx6ull-i2c/i2c_dev.h openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-i2c/i2c_dev.h
--- openharmony/vendor/nxp/imx6ull/driver/imx6ull-i2c/i2c_dev.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-i2c/i2c_dev.h	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: hi35xx i2c driver user support.
+ * Author: yanghaizhou
+ * Create: 2020-08-11
+ */
+
+#ifndef I2C_USER_H
+#define I2C_USER_H
+
+#include "hdf_base.h"
+
+enum I2cIoctlCmd {
+    IOCTL_RETRIES      = 0x0701,
+    IOCTL_TIMEOUT      = 0x0702,
+    IOCTL_SLAVE        = 0x0703,
+    IOCTL_SLAVE_FORCE  = 0x0706,
+    IOCTL_TENBIT       = 0x0704,
+    IOCTL_FUNCS        = 0x0705,
+    IOCTL_RDWR         = 0x0707,
+    IOCTL_PEC          = 0x0708,
+    IOCTL_SMBUS        = 0x0720,
+    IOCTL_16BIT_REG    = 0x0709,  /* 16BIT REG WIDTH */
+    IOCTL_16BIT_DATA   = 0x070a,  /* 16BIT DATA WIDTH */
+};
+
+enum I2cMsgFlag {
+    I2C_M_RD           = 0x0001,
+    I2C_M_TEN          = 0x0010,
+    I2C_M_RECV_LEN     = 0x0400,
+    I2C_M_NO_RD_ACK    = 0x0800,
+    I2C_M_IGNORE_NAK   = 0x1000,
+    I2C_M_REV_DIR_ADDR = 0x2000,
+    I2C_M_NOSTART      = 0x4000,
+    I2C_M_STOP         = 0x8000,
+#ifdef __LITEOS__
+    I2C_M_16BIT_DATA   = 0x0008,
+    I2C_M_16BIT_REG    = 0x0002,
+#endif
+};
+
+typedef struct i2c_msg {
+    uint16_t addr;
+    uint16_t flags;
+    uint16_t len;
+    uint8_t *buf;
+} I2cMsgUser;
+
+typedef struct i2c_rdwr_ioctl_data {
+    struct i2c_msg *msgs;
+    unsigned int nmsgs;
+} I2cIoctlWrap;
+
+int32_t I2cAddVfsById(int16_t id);
+
+void I2cRemoveVfsById(int16_t id);
+
+#endif /* I2C_USER_H */
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/imx6ull-i2c/i2c_imx6ull.c openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-i2c/i2c_imx6ull.c
--- openharmony/vendor/nxp/imx6ull/driver/imx6ull-i2c/i2c_imx6ull.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-i2c/i2c_imx6ull.c	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,634 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: hi35xx i2c driver implement.
+ * Author: yanghaizhou
+ * Create: 2020-07-25
+ */
+
+#include "asm/platform.h"
+#include "device_resource_if.h"
+#include "hdf_device_desc.h"
+#include "hdf_log.h"
+#include "i2c_core.h"
+#include "i2c_dev.h"
+#include "los_hwi.h"
+#include "osal_io.h"
+#include "osal_mem.h"
+#include "osal_time.h"
+
+/* 
+ *IC2状态码，方便通过返回值对程序返回处进行定位
+ */
+#define I2C_OK				     (0)
+#define I2C_ERROR                (1)
+#define I2C_BUSY				 (2)
+#define I2C_IDLE				 (3)
+#define I2C_NAK				     (4)
+#define I2C_ARBITRATIONLOST	     (5)
+#define I2C_TIMEOUT			     (6)
+#define I2C_ADDRNAK			     (7)
+
+
+/* 寄存器地址的宏结构体定义，此种方式仅定义入口地址即可 */
+/* all registers address is Base address + xh offset*/
+typedef struct tagRegisters{
+  volatile uint16_t IADR;                              /*I2C Address Register, offset: 0x0 */
+           uint8_t ReservedIADR[2];
+  volatile uint16_t IFDR;                              /*I2C Frequency Divider Register, offset: 0x4 */
+           uint8_t ReservedIFDR[2];
+  volatile uint16_t I2CR;                              /*I2C Control Register, offset: 0x8 */
+           uint8_t ReservedI2CR[2];
+  volatile uint16_t I2SR;                              /*I2C Status Register, offset: 0xC */
+           uint8_t ReservedI2SR[2];
+  volatile uint16_t I2DR;                              /*I2C Data I/O Register, offset: 0x10 */
+} I2C_REGISTERS;
+
+/*
+ * IC2操作码定义
+ */
+typedef enum enI2C_OPCODE
+{
+    I2C_WRITE = 0,            /* 主机向从机写数据 */
+    I2C_READ  = 1,  		/* 主机从从机读数据 */
+    I2C_DONOTHING_BULL
+} I2C_OPCODE;
+
+/*
+ * 主机传输结构体
+ */
+typedef struct tagI2cTransfer
+{
+    uint8_t  ucSlaveAddress;      	     /* 7位从机地址 */
+    uint32_t ulOpcode  ; 		     /* 操作码*/
+    uint32_t ulSubAddress;       		/* 目标寄存器地址 */
+    uint8_t  ulSubAddressLen;    	     /* 寄存器地址长度 */
+    volatile uint32_t ulLenth;  	     /* 数据长度 */
+    uint8_t *volatile pbuf;    	     /* 数据*/
+} I2C_TRANSFER;
+
+
+#define HDF_LOG_TAG i2c_imx6ull
+
+#define USER_VFS_SUPPORT
+
+
+struct Imx6ullI2cCntlr {
+    struct I2cCntlr cntlr;
+    volatile unsigned char  *regBase;
+    int16_t regSize;
+    int16_t bus;
+    uint32_t clk;
+    uint32_t freq;
+    uint32_t irq;
+    uint32_t regBasePhy;
+};
+
+struct Imx6ullTransferData {
+    struct I2cMsg *msgs;
+    int16_t index;
+    int16_t count;
+};
+
+/*! @name SW_MUX_CTL_PAD - SW_MUX_CTL_PAD_JTAG_MOD SW MUX Control Register..SW_MUX_CTL_PAD_CSI_DATA07 SW MUX Control Register */
+#define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_MASK      (0xFU)  /* Merged from fields with different position or width, of widths (3, 4), largest definition used */
+#define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_SHIFT     (0U)
+#define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE(x)        (((uint32_t)(((uint32_t)(x)) << IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_SHIFT)) & IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_MASK)  /* Merged from fields with different position or width, of widths (3, 4), largest definition used */
+#define IOMUXC_SW_MUX_CTL_PAD_SION_MASK          (0x10U)
+#define IOMUXC_SW_MUX_CTL_PAD_SION_SHIFT         (4U)
+#define IOMUXC_SW_MUX_CTL_PAD_SION(x)            (((uint32_t)(((uint32_t)(x)) << IOMUXC_SW_MUX_CTL_PAD_SION_SHIFT)) & IOMUXC_SW_MUX_CTL_PAD_SION_MASK)
+/*! @name SELECT_INPUT - USB_OTG1_ID_SELECT_INPUT DAISY Register..USDHC2_WP_SELECT_INPUT DAISY Register */
+#define IOMUXC_SELECT_INPUT_DAISY_MASK           (0x7U)  /* Merged from fields with different position or width, of widths (1, 2, 3), largest definition used */
+#define IOMUXC_SELECT_INPUT_DAISY_SHIFT          (0U)
+#define IOMUXC_SELECT_INPUT_DAISY(x)             (((uint32_t)(((uint32_t)(x)) << IOMUXC_SELECT_INPUT_DAISY_SHIFT)) & IOMUXC_SELECT_INPUT_DAISY_MASK)  /* Merged from fields with different position or width, of widths (1, 2, 3), largest definition used */
+
+#define IOMUXC_UART4_TX_DATA_I2C1_SCL                        IO_DEVICE_ADDR(0x020E00B4), 0x2U, IO_DEVICE_ADDR(0x020E05A4), 0x1U, IO_DEVICE_ADDR(0x020E0340)
+#define IOMUXC_UART4_RX_DATA_I2C1_SDA                        IO_DEVICE_ADDR(0x020E00B8), 0x2U, IO_DEVICE_ADDR(0x020E05A8), 0x2U, IO_DEVICE_ADDR(0x020E0344)
+
+#define IOMUXC_UART5_TX_DATA_I2C2_SCL                        IO_DEVICE_ADDR(0x020E00BCU), 0x2U, IO_DEVICE_ADDR(0x020E05ACU), 0x2U, IO_DEVICE_ADDR(0x020E0348U)
+#define IOMUXC_UART5_RX_DATA_I2C2_SDA                        IO_DEVICE_ADDR(0x020E00C0U), 0x2U, IO_DEVICE_ADDR(0x020E05B0U), 0x2U, IO_DEVICE_ADDR(0x020E034CU)
+
+static inline void IOMUXC_SetPinMux(uint32_t muxRegister,
+                                    uint32_t muxMode,
+                                    uint32_t inputRegister,
+                                    uint32_t inputDaisy,
+                                    uint32_t configRegister,
+                                    uint32_t inputOnfield)
+{
+	(void)configRegister;
+	
+    *((volatile uint32_t *)muxRegister) =
+        IOMUXC_SW_MUX_CTL_PAD_MUX_MODE(muxMode) | IOMUXC_SW_MUX_CTL_PAD_SION(inputOnfield);
+
+    if (inputRegister)
+    {
+        *((volatile uint32_t *)inputRegister) = IOMUXC_SELECT_INPUT_DAISY(inputDaisy);
+    }
+}
+
+static inline void IOMUXC_SetPinConfig(uint32_t muxRegister,
+									   uint32_t muxMode,
+									   uint32_t inputRegister,
+									   uint32_t inputDaisy,
+									   uint32_t configRegister,
+									   uint32_t configValue)
+{
+	(void)muxRegister;
+	(void)muxMode;
+	(void)inputRegister;
+	(void)inputDaisy;
+	
+	if (configRegister)
+	{
+		*((volatile uint32_t *)configRegister) = configValue;
+	}
+}
+
+static void i2c_gpio_init(int bus)
+{
+	if (bus == 0)
+	{
+		/*初始化I2C2*/
+		IOMUXC_SetPinMux(IOMUXC_UART5_TX_DATA_I2C2_SCL, 1);
+		IOMUXC_SetPinMux(IOMUXC_UART5_RX_DATA_I2C2_SDA, 1);
+		
+		
+		IOMUXC_SetPinConfig(IOMUXC_UART5_TX_DATA_I2C2_SCL, 0x70B0);
+		IOMUXC_SetPinConfig(IOMUXC_UART5_RX_DATA_I2C2_SDA, 0X70B0);
+	}
+	else
+	{
+		/* no implementations */
+		/*I2C1 复用UART4	SCL-TXD SDA-RXD*/
+		IOMUXC_SetPinMux(IOMUXC_UART4_TX_DATA_I2C1_SCL, 1);
+		IOMUXC_SetPinMux(IOMUXC_UART4_RX_DATA_I2C1_SDA, 1);
+		IOMUXC_SetPinConfig(IOMUXC_UART4_TX_DATA_I2C1_SCL, 0x70B0);
+		IOMUXC_SetPinConfig(IOMUXC_UART4_RX_DATA_I2C1_SDA, 0X70B0);
+	}
+}
+
+static void i2c_init(I2C_REGISTERS *I2C_BASE)
+{
+    /*I2C_I2CR是控制寄存器,
+     * 可以: 使能I2C,使能中断, 选择主从模式.
+     */
+
+    /* 配置I2C控制器步骤: 关闭I2C,配置,打开I2C */
+
+    /* 设置SCL时钟为100K
+     * I2C的时钟源来源于IPG_CLK_ROOT=49.5Mhz
+	 *	PLL2 = 528 MHz
+	 *	PLL2_PFD2 = 528 *18 /24 = 396 MHz
+	 *	IPG_CLK_ROOT = (PLL2_PFD2 / ahb_podf )/ ipg_podf = (396 MHz/4)/2 = 49.5Mhz
+	 *	
+	 *	PER_CLK_ROOT = IPG_CLK_ROOT/perclk_podf = 49.5 MHz/1 = 49.5 MHz
+	 * 设置I2C的波特率为100K， 因此当分频值=49500000/100000=495	
+	 * 参考Table 31-3. I2C_IFDR Register Field Values 表中0x37对应的512最接近
+	 * 即寄存器IFDR的IC位设置为0X37
+	 */	 
+	I2C_BASE->I2CR &= ~(1 << 7);
+	I2C_BASE->IFDR = 0x37;
+	I2C_BASE->I2CR |= (1<<7);
+}
+
+static uint8_t i2c_check(I2C_REGISTERS *I2C_BASE, uint32_t status)
+{
+	/* 检查是否发生仲裁丢失错误(arbitration lost) */
+	if(status & (1<<4))
+	{
+		I2C_BASE->I2SR &= ~(1<<4);	/* 清除仲裁丢失错误位 			*/
+
+		I2C_BASE->I2CR &= ~(1 << 7);	/* 复位I2C: 先关闭I2C 				*/
+		I2C_BASE->I2CR |= (1 << 7);	/* 再打开I2C 				*/
+		return I2C_ARBITRATIONLOST;
+	} 
+	else if(status & (1 << 0))     	/* 检查NAK */
+	{
+		return I2C_NAK;		/* 返回NAK(无应答) */
+	}
+	return I2C_OK;
+
+}
+
+static uint8_t i2c_start(I2C_REGISTERS *I2C_BASE, uint8_t ucSlaveAddr, uint32_t ulOpcode)
+{
+
+	if(I2C_BASE->I2SR & (1 << 5))			/* I2C忙 */
+		return 1;
+
+	/*
+         * 设置控制寄存器I2CR
+         * bit[5]: 1 主模式(master)
+         * bit[4]: 1 发送(transmit)
+	 */
+	I2C_BASE->I2CR |=  (1 << 5) | (1 << 4);
+
+	/*
+         * 设置数据寄存器I2DR
+         * bit[7:0] : 要发送的数据, 
+         * START信号后第一个数据是从设备地址
+	 */ 
+	I2C_BASE->I2DR = ((uint32_t)ucSlaveAddr << 1) | ((I2C_READ == ulOpcode)? 1 : 0);
+	return 0;
+
+}
+
+static uint8_t i2c_stop(I2C_REGISTERS *I2C_BASE)
+{
+
+	uint16_t usTimeout = 0xffff;
+
+	/*
+	 * 清除控制寄存器I2CR[5:3]
+         * 发出STOP信号
+	 */
+	I2C_BASE->I2CR &= ~((1 << 5) | (1 << 4) | (1 << 3));
+
+	/* 等待STOP信号确实发出去了 */
+	while((I2C_BASE->I2SR & (1 << 5)))
+	{
+		usTimeout--;
+		if(usTimeout == 0)	/* 超时跳出 */
+			return I2C_TIMEOUT;
+	}
+	return I2C_OK;
+
+}
+
+static uint8_t i2c_restart(I2C_REGISTERS *I2C_BASE, uint8_t ucSlaveAddr, uint32_t ulOpcode)
+{
+
+	/* I2C忙并且工作在从模式,跳出 */
+	if(I2C_BASE->I2SR & (1 << 5) && (((I2C_BASE->I2CR) & (1 << 5)) == 0))		
+		return 6;
+
+	/*
+         * 设置控制寄存器I2CR
+         * bit[4]: 1 发送(transmit)
+         * bit[2]: 1 产生重新开始信号(Repeat start)
+	 */
+	I2C_BASE->I2CR |=  (1 << 4) | (1 << 2);
+
+	/*
+         * 设置数据寄存器I2DR
+         * bit[7:0] : 要发送的数据, 
+         * START信号后第一个数据是从设备地址
+	 */ 
+	I2C_BASE->I2DR = ((uint32_t)ucSlaveAddr << 1) | ((I2C_READ == ulOpcode)? 1 : 0);
+	
+	return 0;
+
+}
+
+
+static void i2c_write(I2C_REGISTERS *I2C_BASE, const uint8_t *pbuf, uint32_t len)
+{
+	/* 等待数据寄存器就绪,可以再次发送数据 */
+	while(!(I2C_BASE->I2SR & (1 << 7))); 
+	
+	I2C_BASE->I2SR &= ~(1 << 1); 	  /* 清除IICIF */
+	I2C_BASE->I2CR |= 1 << 4;	      /* 发送数据(transmit) */
+	while(len--)
+	{
+		I2C_BASE->I2DR = *pbuf++; 	    /* 将buf中的数据写入到数据寄存器I2DR */
+		
+		while(!(I2C_BASE->I2SR & (1 << 1)));  /* 等待传输完成,完成或失败,中断状态位被置1 */	
+		I2C_BASE->I2SR &= ~(1 << 1);			/* 清除中断状态位 */
+
+		/* 检查有无错误 */
+		if(i2c_check(I2C_BASE, I2C_BASE->I2SR))
+			break;
+	}
+	
+	I2C_BASE->I2SR &= ~(1 << 1);     /* 清除中断状态位 */
+	i2c_stop(I2C_BASE); 	         /* 发送停止信号 */
+
+}
+
+static void i2c_read(I2C_REGISTERS *I2C_BASE, uint8_t *pbuf, uint32_t len)
+{
+	volatile uint8_t dummy = 0;
+	dummy++; 	/* 防止编译警告 */
+
+	/* 等待数据寄存器就绪 */
+	while(!(I2C_BASE->I2SR & (1 << 7))); 
+	
+	I2C_BASE->I2SR &= ~(1 << 1); 			   /* 清除IICIF */
+	I2C_BASE->I2CR &= ~((1 << 4) | (1 << 3));	/* 接收数据: Receive,TXAK */
+	
+	/* 如果只接收一个字节数据的话发送NACK信号 */
+	if(len == 1)
+        I2C_BASE->I2CR |= (1 << 3);
+
+	dummy = I2C_BASE->I2DR; /* 假读 */
+
+
+	while(len--)
+	{
+		while(!(I2C_BASE->I2SR & (1 << 1))); 	/* 等待传输完成 */	
+		I2C_BASE->I2SR &= ~(1 << 1);			/* 清除标志位 */
+
+	 	if(len == 0)
+        {
+        	i2c_stop(I2C_BASE); 			/* 发送停止信号 */
+        }
+
+        if(len == 1)
+        {
+            I2C_BASE->I2CR |= (1 << 3);
+        }
+		*pbuf++ = I2C_BASE->I2DR;
+	}
+
+}
+
+static uint8_t Imx6ullI2cXferOneMsgPolling(I2C_REGISTERS *I2C_BASE, I2C_TRANSFER *transfer)
+{
+	uint32_t ulRet = 0;
+	uint32_t ulOpcode = transfer->ulOpcode;
+
+	/*开始前准备工作，清除标志位
+	 *bit-4 IAL 仲裁位，bit-1 IIF 中断标志位
+	 */
+	I2C_BASE->I2SR &= ~((1 << 1) | (1 << 4));
+	/* 等待传输完成 */
+	while(!((I2C_BASE->I2SR >> 7) & 0X1)){}; 
+
+	/* 如果要读某个寄存器,寄存器地址要先"写"给从设备
+	 * 所以方向要"先写","后读"
+	 */
+    if ((transfer->ulSubAddressLen > 0) && (transfer->ulOpcode == I2C_READ))
+    {
+        ulOpcode = I2C_WRITE;
+    }
+	ulRet = i2c_start(I2C_BASE, transfer->ucSlaveAddress, ulOpcode);
+
+	if (ulRet)
+	{
+		return ulRet;
+	}
+	
+	/* 等待传输完成: 中断状态为会被置1 */
+	while(!(I2C_BASE->I2SR & (1 << 1))){};
+
+	/* 检查是否出错 */
+	ulRet = i2c_check(I2C_BASE, I2C_BASE->I2SR);
+
+	if (ulRet)
+	{
+	    i2c_stop(I2C_BASE); 			/* 发送停止信号 */
+		return ulRet;
+	}
+
+	/*如果ulSubAddressLen不为0，表示要发送寄存器地址*/
+	if (transfer->ulSubAddressLen)
+	{
+		do
+		{
+			/* 清除中断状态位 */
+		    I2C_BASE->I2SR &= ~(1 << 1); 
+			
+			/* 调整长度, 也许寄存器地址有多个字节, 本程序最多支持4字节 */
+			transfer->ulSubAddressLen--;
+
+			I2C_BASE->I2DR = ((transfer->ulSubAddress) >> (8 * transfer->ulSubAddressLen)); 
+  
+			while(!(I2C_BASE->I2SR & (1 << 1))){};  	/* 等待传输完成: 中断状态位被置1 */
+
+            /* 检查是否出错 */
+            ulRet = i2c_check(I2C_BASE, I2C_BASE->I2SR);
+            if(ulRet)
+            {
+             	i2c_stop(I2C_BASE); 				/* 出错:发送停止信号 */
+             	return ulRet;
+            }
+		}
+		while ((transfer->ulSubAddressLen > 0) && (ulRet == I2C_OK));
+
+		if (I2C_READ == transfer->ulOpcode)
+		{
+            I2C_BASE->I2SR &= ~(1 << 1);			/* 清除中断状态位 */
+            i2c_restart(I2C_BASE, transfer->ucSlaveAddress, I2C_READ); /* 发送重复开始信号和从机地址 */
+    		while(!(I2C_BASE->I2SR & (1 << 1))){}; /* 等待传输完成: 中断状态位被置1 */
+
+            /* 检查是否出错 */
+			ulRet = i2c_check(I2C_BASE, I2C_BASE->I2SR);
+			
+            if(ulRet)
+            {
+             	ulRet = I2C_ADDRNAK;
+                i2c_stop(I2C_BASE); 		/* 出错:发送停止信号 */
+                return ulRet;  
+            }
+           	       
+
+		}
+		
+	}
+    /* 发送数据 */
+    if ((I2C_WRITE == transfer->ulOpcode) && (transfer->ulLenth > 0))
+    {
+    	i2c_write(I2C_BASE, transfer->pbuf, transfer->ulLenth);
+	}
+
+    /* 读取数据 */
+    if ((I2C_READ == transfer->ulOpcode) && (transfer->ulLenth > 0))
+    {
+       	i2c_read(I2C_BASE, transfer->pbuf, transfer->ulLenth);
+	}
+	return 0;	
+
+}
+
+
+static int32_t Imx6ullI2cTransfer(struct I2cCntlr *cntlr, struct I2cMsg *msgs, int16_t count)
+{
+    int32_t ret = HDF_SUCCESS;
+    unsigned long irqSave;
+    struct Imx6ullI2cCntlr *imx6ullI2Ccnt = NULL;
+	I2C_TRANSFER transfer;
+	int i;
+
+    if (cntlr == NULL || cntlr->priv == NULL) {
+        HDF_LOGE("Hi35xxI2cTransfer: cntlr lor imx6ullI2Ccntis null!\n");
+        return HDF_ERR_INVALID_OBJECT;
+    }
+    imx6ullI2Ccnt = (struct Imx6ullI2cCntlr *)cntlr;
+
+    if (msgs == NULL || count <= 0) {
+        HDF_LOGE("Hi35xxI2cTransfer: err parms! count:%d\n", count);
+        return HDF_ERR_INVALID_PARAM;
+    }
+
+    irqSave = LOS_IntLock();
+    for (i = 0; i < count; i++) {
+		transfer.ucSlaveAddress = msgs[i].addr;
+		transfer.ulOpcode = (msgs[i].flags & I2C_FLAG_READ) ? I2C_READ : I2C_WRITE;
+		transfer.ulSubAddress = 0;
+		transfer.ulSubAddressLen = 0;
+		transfer.ulLenth = msgs[i].len;
+		transfer.pbuf    = msgs[i].buf;
+	
+        ret = Imx6ullI2cXferOneMsgPolling((I2C_REGISTERS *)imx6ullI2Ccnt->regBase, &transfer);
+        if (ret != 0) {
+            break;
+        }
+    }
+    LOS_IntRestore(irqSave);
+    return (i > 0) ? i : ret;
+}
+
+static struct I2cMethod g_method = {
+    .transfer = Imx6ullI2cTransfer,
+};
+
+static int32_t Imx6ullI2cReadDrs(struct Imx6ullI2cCntlr *imx6ullI2Ccnt, const struct DeviceResourceNode *node)
+{
+    int32_t ret;
+    uint32_t tmp;
+    struct DeviceResourceIface *drsOps = NULL;
+
+    drsOps = DeviceResourceGetIfaceInstance(HDF_CONFIG_SOURCE);
+    if (drsOps == NULL || drsOps->GetUint32 == NULL) {
+        HDF_LOGE("%s: invalid drs ops fail!\n", __func__);
+        return HDF_FAILURE;
+    }
+
+    ret = drsOps->GetUint32(node, "reg_pbase", &imx6ullI2Ccnt->regBasePhy, 0);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: read regBase fail!\n", __func__);
+        return ret;
+    }
+
+    ret = drsOps->GetUint32(node, "reg_size", &tmp, 0);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: read regsize fail!\n", __func__);
+        return ret;
+    }
+    imx6ullI2Ccnt->regSize = (uint16_t)tmp;
+
+    ret = drsOps->GetUint32(node, "freq", &imx6ullI2Ccnt->freq, 0);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: read freq fail!\n", __func__);
+        return ret;
+    }
+
+    ret = drsOps->GetUint32(node, "irq", &imx6ullI2Ccnt->irq, 0);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: read irq fail! \n", __func__);
+        return ret;
+    }
+
+    ret = drsOps->GetUint32(node, "clk", &imx6ullI2Ccnt->clk, 0);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: read clk fail!\n", __func__);
+        return ret;
+    }
+
+    ret = drsOps->GetUint32(node, "bus", &tmp, 0);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: read bus fail!\n", __func__);
+        return ret;
+    }
+    imx6ullI2Ccnt->bus = (uint16_t)tmp;
+
+    return HDF_SUCCESS;
+}
+
+static int32_t Imx6ullI2cBind(struct HdfDeviceObject *device)
+{
+    int32_t ret;
+    struct Imx6ullI2cCntlr *imx6ullI2Ccnt = NULL;
+
+    HDF_LOGI("%s: Enter", __func__);
+    if (device == NULL || device->property == NULL) {
+        HDF_LOGE("%s: device or property is NULL\n", __func__);
+        return HDF_ERR_INVALID_OBJECT;
+    }
+
+    imx6ullI2Ccnt = (struct Imx6ullI2cCntlr *)OsalMemCalloc(sizeof(*imx6ullI2Ccnt));
+    if (imx6ullI2Ccnt == NULL) {
+        HDF_LOGE("%s: malloc imx6ullI2Ccnt fail!", __func__);
+        return HDF_ERR_MALLOC_FAIL;
+    }
+
+    ret = Imx6ullI2cReadDrs(imx6ullI2Ccnt, device->property);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: read drs fail! ret:%d", __func__, ret);
+        goto __ERR__;
+    }
+
+    imx6ullI2Ccnt->regBase = OsalIoRemap(imx6ullI2Ccnt->regBasePhy, imx6ullI2Ccnt->regSize);
+    if (imx6ullI2Ccnt->regBase == NULL) {
+        HDF_LOGE("%s: ioremap regBase fail!\n", __func__);
+        ret = HDF_ERR_IO;
+        goto __ERR__;
+    }
+
+	i2c_gpio_init(imx6ullI2Ccnt->bus);
+    i2c_init((I2C_REGISTERS *)imx6ullI2Ccnt->regBase);
+
+    imx6ullI2Ccnt->cntlr.device = device;
+    imx6ullI2Ccnt->cntlr.priv = (void *)device->property;
+    imx6ullI2Ccnt->cntlr.busId = imx6ullI2Ccnt->bus;
+    imx6ullI2Ccnt->cntlr.ops = &g_method;
+    ret = I2cCntlrAdd(&imx6ullI2Ccnt->cntlr);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: add i2c controller fail:%d!\n", __func__, ret);
+        goto __ERR__;
+    }
+
+#ifdef USER_VFS_SUPPORT
+    (void)I2cAddVfsById(imx6ullI2Ccnt->cntlr.busId);
+#endif
+    return HDF_SUCCESS;
+__ERR__:
+    if (imx6ullI2Ccnt != NULL) {
+        if (imx6ullI2Ccnt->regBase != NULL) {
+            OsalIoUnmap((void *)imx6ullI2Ccnt->regBase);
+            imx6ullI2Ccnt->regBase = NULL;
+        }
+        OsalMemFree(imx6ullI2Ccnt);
+        imx6ullI2Ccnt = NULL;
+    }
+    return ret;
+}
+
+static int32_t Imx6ullI2cInit(struct HdfDeviceObject *device)
+{
+    (void)device;
+    return HDF_SUCCESS;
+}
+
+static void Imx6ullI2cRelease(struct HdfDeviceObject *device)
+{
+    struct I2cCntlr *cntlr = NULL;
+    struct Imx6ullI2cCntlr *imx6ullI2Ccnt = NULL;
+
+    HDF_LOGI("%s: enter\n", __func__);
+
+    if (device == NULL) {
+        HDF_LOGE("%s: device is null!\n", __func__);
+        return;
+    }
+
+    cntlr = I2cCntlrFromDevice(device);
+    if (cntlr == NULL) {
+        HDF_LOGE("%s: no service binded!\n", __func__);
+        return;
+    }
+    I2cCntlrRemove(cntlr);
+
+    imx6ullI2Ccnt = (struct Imx6ullI2cCntlr *)cntlr;
+    OsalIoUnmap((void *)imx6ullI2Ccnt->regBase);
+    OsalMemFree(imx6ullI2Ccnt);
+}
+
+struct HdfDriverEntry g_i2cDriverEntry = {
+    .moduleVersion = 1,
+    .Bind = Imx6ullI2cBind,
+    .Init = Imx6ullI2cInit,
+    .Release = Imx6ullI2cRelease,
+    .moduleName = "HDF_PLATFORM_I2C",
+};
+HDF_INIT(g_i2cDriverEntry);
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/imx6ull-i2c/Makefile openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-i2c/Makefile
--- openharmony/vendor/nxp/imx6ull/driver/imx6ull-i2c/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-i2c/Makefile	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,19 @@
+include $(LITEOSTOPDIR)/config.mk
+include $(LITEOSTOPDIR)/../../drivers/hdf/lite/lite.mk
+
+MODULE_NAME := $(notdir $(shell pwd))
+
+LOCAL_SRCS :=  i2c_dev.c i2c_imx6ull.c
+
+LOCAL_FLAGS :=  -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/config \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/core \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/ability/sbuf/include \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/utils/include \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/osal \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/platform \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/lite/include/host/
+
+LOCAL_CFLAGS += -fstack-protector-strong
+
+include $(HDF_DRIVER)
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/imx6ull-uart/imx6ull_uart.h openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-uart/imx6ull_uart.h
--- openharmony/vendor/nxp/imx6ull/driver/imx6ull-uart/imx6ull_uart.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-uart/imx6ull_uart.h	2020-10-31 00:27:40.756668370 +0800
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _AMBA_PL011_UART_H
+#define _AMBA_PL011_UART_H
+
+#include "los_typedef.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+
+/*根据IMX6ULL芯片手册<<55.15 UART Memory Map/Register Definition>>的3608页，定义UART的结构体,*/
+typedef struct {
+  volatile unsigned int  URXD;               /**< UART Receiver Register, offset: 0x0 	           串口接收寄存器，偏移地址0x0     */
+  		   unsigned char RESERVED_0[60];		
+  volatile unsigned int  UTXD;               /**< UART Transmitter Register, offset: 0x40          串口发送寄存器，偏移地址0x40*/
+  		   unsigned char RESERVED_1[60];		
+  volatile unsigned int  UCR1;               /**< UART Control Register 1, offset: 0x80 	       串口控制寄存器1，偏移地址0x80*/
+  volatile unsigned int  UCR2;               /**< UART Control Register 2, offset: 0x84 	       串口控制寄存器2，偏移地址0x84*/
+  volatile unsigned int  UCR3;               /**< UART Control Register 3, offset: 0x88            串口控制寄存器3，偏移地址0x88*/
+  volatile unsigned int  UCR4;               /**< UART Control Register 4, offset: 0x8C            串口控制寄存器4，偏移地址0x8C*/
+  volatile unsigned int  UFCR;               /**< UART FIFO Control Register, offset: 0x90         串口FIFO控制寄存器，偏移地址0x90*/
+  volatile unsigned int  USR1;               /**< UART Status Register 1, offset: 0x94             串口状态寄存器1，偏移地址0x94*/
+  volatile unsigned int  USR2;               /**< UART Status Register 2, offset: 0x98             串口状态寄存器2，偏移地址0x98*/
+  volatile unsigned int  UESC;               /**< UART Escape Character Register, offset: 0x9C     串口转义字符寄存器，偏移地址0x9C*/
+  volatile unsigned int  UTIM;               /**< UART Escape Timer Register, offset: 0xA0         串口转义定时器寄存器 偏移地址0xA0*/
+  volatile unsigned int  UBIR;               /**< UART BRM Incremental Register, offset: 0xA4      串口二进制倍率增加寄存器 偏移地址0xA4*/
+  volatile unsigned int  UBMR;               /**< UART BRM Modulator Register, offset: 0xA8 	   串口二进制倍率调节寄存器 偏移地址0xA8*/
+  volatile unsigned int  UBRC;               /**< UART Baud Rate Count Register, offset: 0xAC      串口波特率计数寄存器 偏移地址0xAC*/
+  volatile unsigned int  ONEMS;              /**< UART One Millisecond Register, offset: 0xB0      串口一毫秒寄存器 偏移地址0xB0*/
+  volatile unsigned int  UTS;                /**< UART Test Register, offset: 0xB4                 串口测试寄存器 偏移地址0xB4*/		
+  volatile unsigned int  UMCR;               /**< UART RS-485 Mode Control Register, offset: 0xB8  串口485模式控制寄存器 偏移地址0xB8*/
+} UART_Type;
+
+
+/*UART1的寄存器的基地址*/
+//#define UART1_BASE          (0x2020000u)
+
+#define IMX6ULL_UART1    ((UART_Type *)UART0_REG_BASE)
+#define IMX6ULL_PHY_UART1    ((UART_Type *)0x2020000u)
+
+
+#define CMD_LENGTH  128
+
+extern CHAR g_inputCmd[CMD_LENGTH];
+extern INT32 g_inputIdx;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+#endif
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/imx6ull-uart/Makefile openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-uart/Makefile
--- openharmony/vendor/nxp/imx6ull/driver/imx6ull-uart/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-uart/Makefile	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,7 @@
+include $(LITEOSTOPDIR)/config.mk
+
+MODULE_NAME := $(notdir $(shell pwd))
+
+LOCAL_SRCS :=  uart_core.c uart_dev.c uart_imx6ull.c
+
+include $(MODULE)
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_core.c openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_core.c
--- openharmony/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_core.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_core.c	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,156 @@
+#include "errno.h"
+#include "string.h"
+#include "uart_dev.h"
+#include "user_copy.h"
+
+int uart_dev_read(struct uart_driver_data *udd, char *buf, size_t count)
+{
+    struct uart_ioc_transfer *transfer = NULL;
+    unsigned int wp, rp;
+    unsigned long data;
+    int ret = 0;
+
+    if (udd == NULL) {
+        uart_error("udd is null");
+        return -EFAULT;
+    }
+
+    transfer = udd->rx_transfer;
+    if (transfer == NULL) {
+        uart_error("transfer is null");
+        return -EFAULT;
+    }
+    if (buf == NULL) {
+        uart_error("buf is nullptr\n");
+        return -EFAULT;
+    }
+
+    wp = transfer->wp;
+    rp = transfer->rp;
+    data = (unsigned long)(uintptr_t)transfer->data;
+
+    if (!(transfer->flags & BUF_CIRCLED)) {
+        if (count >= (wp - rp)) {
+            count = wp - rp;
+        }
+        ret = LOS_CopyFromKernel(buf, BUF_SIZE, (void *)(uintptr_t)(data + rp), count);
+        if (ret){
+            return -EFAULT;
+        }
+        transfer->rp += count;
+        return count;
+    } else {
+        if (count < (BUF_SIZE - rp)) {
+            ret = LOS_CopyFromKernel(buf, BUF_SIZE, (void *)(uintptr_t)(data + rp), count);
+            if (ret) {
+                return -EFAULT;
+            }
+            transfer->rp += count;
+            return count;
+        } else {
+            unsigned int copy_size = BUF_SIZE - rp;
+            unsigned int left_size = count - copy_size;
+            ret = LOS_CopyFromKernel(buf, BUF_SIZE, (void *)(uintptr_t)(data + rp), copy_size);
+            if (ret) {
+                return -EFAULT;
+            }
+            rp = 0;
+            if (left_size > wp) {
+                left_size = wp;
+            }
+            ret = LOS_CopyFromKernel((void *)(buf + copy_size), BUF_SIZE, (void *)(uintptr_t)(data + rp), left_size);
+            if (ret) {
+                return -EFAULT;
+            }
+            transfer->rp = left_size;
+            transfer->flags &= ~BUF_CIRCLED;
+            return (copy_size + left_size);
+        }
+    }
+}
+
+static int notify(struct wait_queue_head *wait)
+{
+    if (wait == NULL) {
+        return -EINVAL;
+    }
+
+    LOS_EventWrite(&wait->stEvent, 0x1);
+    notify_poll(wait);
+    return 0;
+}
+
+int uart_recv_notify(struct uart_driver_data *udd, const char *buf, size_t count)
+{
+    struct uart_ioc_transfer *transfer = NULL;
+    unsigned int wp, rp;
+    unsigned long data;
+    int ret = 0;
+
+    if (udd == NULL) {
+        uart_error("udd is null");
+        return -EFAULT;
+    }
+
+    transfer = udd->rx_transfer;
+    if (transfer == NULL) {
+        uart_error("transfer is null");
+        return -EFAULT;
+    }
+    wp = transfer->wp;
+    rp = transfer->rp;
+    data = (unsigned long)(uintptr_t)transfer->data;
+
+    if (!(transfer->flags & BUF_CIRCLED)) {
+        if (count < (BUF_SIZE - wp)) {
+            ret = LOS_CopyToKernel((void *)(uintptr_t)(data + wp), BUF_SIZE, (void *)(buf), count);
+            if (ret) {
+                return -EFAULT;
+            }
+            transfer->wp += count;
+            notify(&udd->wait);
+            return count;
+        } else {
+            unsigned int copy_size = BUF_SIZE - wp;
+            unsigned int left_size = count - copy_size;
+            ret = LOS_CopyToKernel((void *)(uintptr_t)(data + wp), BUF_SIZE, (void *)(buf), copy_size);
+            if (ret) {
+                return -EFAULT;
+            }
+            wp = 0;
+            if (left_size > rp) {
+                /* overflowed. some new data will be discarded */
+                uart_error("[%d]rx buf overflow", udd->num);
+                left_size = rp;
+            }
+            ret = LOS_CopyToKernel((void *)(uintptr_t)(data + wp), BUF_SIZE, (void *)(buf + copy_size), left_size);
+            if (ret) {
+                return -EFAULT;
+            }
+            transfer->wp = left_size;
+            transfer->flags |= BUF_CIRCLED;
+            notify(&udd->wait);
+            return (copy_size + left_size);
+        }
+    } else {
+        if (count > (rp - wp)) {
+            /* overflowed. some new data will be discarded */
+            uart_error("[%d]rx buf overflow", udd->num);
+            count = rp - wp;
+        }
+        ret = LOS_CopyToKernel((void *)(uintptr_t)(data + wp), BUF_SIZE, (void *)(buf), count);
+        if (ret) {
+                return -EFAULT;
+        }
+        transfer->wp += count;
+        notify(&udd->wait);
+        return count;
+    }
+}
+
+int uart_rx_buf_empty(struct uart_driver_data *udd)
+{
+    struct uart_ioc_transfer *transfer = udd->rx_transfer;
+    return (transfer->wp == transfer->rp);
+}
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_dev.c openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_dev.c
--- openharmony/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_dev.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_dev.c	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,356 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "stdio.h"
+#include "stdlib.h"
+#include "string.h"
+#include "errno.h"
+
+#include "fs/fs.h"
+#include "fcntl.h"
+
+#include "asm/platform.h"
+#include "poll.h"
+
+#include "uart_dev.h"
+#include "user_copy.h"
+
+static int uartdev_open(FAR struct file *filep)
+{
+    int ret = 0;
+    struct inode *inode = filep->f_inode;
+    struct wait_queue_head *wait = NULL;
+    struct uart_driver_data *udd = (struct uart_driver_data *)inode->i_private;
+    if (udd == NULL) {
+        uart_error("invalid i_private!");
+        return -EINVAL;
+    }
+    wait = &udd->wait;
+    if (udd->state == UART_STATE_NOT_OPENED) {
+        udd->state = UART_STATE_OPENING;
+        (void)LOS_EventInit(&wait->stEvent);
+        spin_lock_init(&wait->lock);
+        LOS_ListInit(&wait->poll_queue);
+        udd->rx_transfer = (struct uart_ioc_transfer *)LOS_MemAlloc(m_aucSysMem0, sizeof(struct uart_ioc_transfer));
+        if (NULL == udd->rx_transfer) {
+            uart_error("alloc transfer failed!");
+            return -ENOMEM;
+        }
+        memset_s(udd->rx_transfer, sizeof(struct uart_ioc_transfer), 0, sizeof(struct uart_ioc_transfer));
+        if (udd->ops->startup && udd->ops->startup(udd)) {
+            uart_error("startup failed...");
+            ret = -EFAULT;
+            goto free_transfer;
+        }
+    }
+    udd->state = UART_STATE_USEABLE;
+    udd->count++;
+    return 0;
+
+free_transfer:
+    (VOID)LOS_MemFree(m_aucSysMem0, udd->rx_transfer);
+    udd->rx_transfer = NULL;
+    return ret;
+}
+
+static int uartdev_release(FAR struct file *filep)
+{
+    struct inode *inode = filep->f_inode;
+    struct wait_queue_head *wait = NULL;
+    struct uart_driver_data *udd = (struct uart_driver_data *)inode->i_private;
+    if (udd == NULL) {
+        uart_error("uart_driver_data is NULL");
+        return -EINVAL;
+    }
+    if ((--udd->count) != 0) {
+        return 0;
+    }
+
+    wait = &udd->wait;
+
+    if (udd->flags & UART_FLG_DMA_RX) {
+        if (udd->ops->dma_shutdown) {
+            udd->ops->dma_shutdown(udd, UART_DMA_DIR_RX);
+        }
+    }
+    if (udd->flags & UART_FLG_DMA_TX) {
+        if (udd->ops->dma_shutdown) {
+            udd->ops->dma_shutdown(udd, UART_DMA_DIR_TX);
+        }
+    }
+
+    LOS_ListDelete(&wait->poll_queue);
+    LOS_EventDestroy(&wait->stEvent);
+
+    if (udd->ops->shutdown) {
+        udd->ops->shutdown(udd);
+    }
+
+    if (udd->rx_transfer) {
+        (VOID)LOS_MemFree(m_aucSysMem0, udd->rx_transfer);
+    }
+    udd->rx_transfer = NULL;
+    udd->state = UART_STATE_NOT_OPENED;
+
+    return 0;
+}
+
+static ssize_t uartdev_read(FAR struct file *filep, FAR char *buf, size_t count)
+{
+    int ret = 0;
+    struct inode *inode = filep->f_inode;
+
+    struct uart_driver_data *udd = (struct uart_driver_data *)inode->i_private;
+    if (udd == NULL) {
+        uart_error("uart_driver_data is NULL");
+        return -EINVAL;
+    }
+    if (UART_STATE_USEABLE != udd->state) {
+        return -EFAULT;
+    }
+
+    if ((udd->flags & UART_FLG_RD_BLOCK) &&
+        (uart_rx_buf_empty(udd))) {
+        (void)LOS_EventRead(&udd->wait.stEvent,
+                            0x1, LOS_WAITMODE_OR, LOS_WAIT_FOREVER);
+    }
+
+    ret = uart_dev_read(udd, buf, count);
+
+    if ((udd->flags & UART_FLG_RD_BLOCK) &&
+        (uart_rx_buf_empty(udd))) {
+        (void)LOS_EventClear(&udd->wait.stEvent, ~(0x1));
+    }
+    return ret;
+}
+
+static ssize_t uartdev_write(struct file *filep, const char *buf, size_t count)
+{
+    int ret = 0;
+    struct inode *inode = filep->f_inode;
+    struct uart_driver_data *udd = (struct uart_driver_data *)inode->i_private;
+    if (udd == NULL) {
+        uart_error("uart_driver_data is NULL");
+        return -EINVAL;
+    }
+
+    if (UART_STATE_USEABLE != udd->state) {
+        return -EFAULT;
+    }
+
+    if (udd->ops->start_tx) {
+        ret = udd->ops->start_tx(udd, buf, count);
+    }
+
+    return ret;
+}
+
+static int uartcfg_attr(struct uart_driver_data *udd, unsigned long arg)
+{
+    int ret;
+    int len = sizeof(struct __uart_attr);
+
+    if (!LOS_IsUserAddressRange((vaddr_t)arg, len)) {
+        ret = memcpy_s((void *)&udd->attr, len, (void *)arg, len);
+    } else {
+        ret = LOS_ArchCopyFromUser(&udd->attr, (void *)arg, len);
+    }
+
+    if (ret != LOS_OK) {
+        return ret;
+    }
+    if ((udd->ops->config) && (udd->ops->config(udd))) {
+        uart_error("config failed!");
+        ret = -EFAULT;
+    }
+    return ret;
+}
+
+static int uartdev_ioctl(FAR struct file *filep, int cmd, unsigned long arg)
+{
+    int ret = 0;
+    struct inode *inode = filep->f_inode;
+    struct uart_driver_data *udd = (struct uart_driver_data *)inode->i_private;
+
+    if (udd == NULL) {
+        uart_error("uart_driver_data is NULL");
+        return -EINVAL;
+    }
+
+    if (UART_STATE_USEABLE != udd->state) {
+        return -EFAULT;
+    }
+
+    switch (cmd) {
+        case UART_CFG_BAUDRATE:
+            /*
+             * baudrate should be between 0 and CONFIG_MAX_BAUDRATE
+             */
+            if ((arg <= CONFIG_MAX_BAUDRATE) && (arg > 0)) {
+                udd->baudrate = arg;
+                if (udd->ops->config && udd->ops->config(udd)) {
+                    uart_error("invalid  baudrate, which is:%d\n", arg);
+                    ret = -EFAULT;
+                }
+            } else {
+                uart_error("invalid  baudrate, which is:%d\n", arg);
+                ret = -EINVAL;
+            }
+            break;
+
+        case UART_CFG_DMA_RX:
+            if (arg == UART_DMA_RX_EN) {
+                if (!(udd->flags & UART_FLG_DMA_RX)) {
+                    if (udd->ops->dma_startup) {
+                        ret = udd->ops->dma_startup(udd, UART_DMA_DIR_RX);
+                        if (!ret) {
+                            udd->flags |= UART_FLG_DMA_RX;
+                        } else {
+                            uart_error("dma startup failed!");
+                            ret = -EFAULT;
+                        }
+                    } else {
+                        uart_error("dma receive not supported!");
+                        ret = -ENOTSUP;
+                    }
+                }
+            } else if (arg == UART_DMA_RX_DIS) {
+                if (udd->ops->dma_shutdown) {
+                    udd->ops->dma_shutdown(udd, UART_DMA_DIR_RX);
+                    udd->flags &= ~UART_FLG_DMA_RX;
+                } else {
+                    uart_error("dma receive not supported!");
+                    ret = -ENOTSUP;
+                }
+            } else {
+                uart_error("invalid parameter!");
+                ret = -EINVAL;
+            }
+            break;
+
+        case UART_CFG_DMA_TX:
+            if (arg == UART_DMA_TX_EN) {
+                if (!(udd->flags & UART_FLG_DMA_TX)) {
+                    if (udd->ops->dma_startup) {
+                        ret = udd->ops->dma_startup(udd, UART_DMA_DIR_TX);
+                        if (!ret) {
+                            udd->flags |= UART_FLG_DMA_TX;
+                        } else {
+                            uart_error("dma startup failed!");
+                            ret = -EFAULT;
+                        }
+                    } else {
+                        uart_error("dma send not supported!");
+                        ret = -ENOTSUP;
+                    }
+                }
+            } else if (arg == UART_DMA_TX_DIS) {
+                if (udd->ops->dma_shutdown) {
+                    udd->ops->dma_shutdown(udd, UART_DMA_DIR_TX);
+                    udd->flags &= ~UART_FLG_DMA_TX;
+                } else {
+                    uart_error("dma send not supported!");
+                    ret = -ENOTSUP;
+                }
+            } else {
+                uart_error("invalid parameter!");
+                ret = -EINVAL;
+            }
+            break;
+        case UART_CFG_RD_BLOCK:
+            if (arg == UART_RD_BLOCK) {
+                udd->flags |= UART_FLG_RD_BLOCK;
+            } else if (arg == UART_RD_NONBLOCK) {
+                udd->flags &= ~UART_FLG_RD_BLOCK;
+                (void)LOS_EventWrite(&udd->wait.stEvent, 0x1);
+            }
+            break;
+
+        case UART_CFG_ATTR:
+            ret = uartcfg_attr(udd, arg);
+            break;
+        case UART_CFG_PRIVATE:
+            if (udd->ops->priv_operator) {
+                ret = udd->ops->priv_operator(udd, (void *)(uintptr_t)arg);
+            }
+            break;
+        /* add more configs */
+
+        default:
+            uart_error("unknow ioctl cmd:%d\n", cmd);
+            ret = -EINVAL;
+            break;
+    }
+    return ret;
+}
+
+extern void poll_wait(struct file *filp,
+                      wait_queue_head_t *wait_address, poll_table *p);
+static int uartdev_poll(struct file *filep, poll_table *table)
+{
+    struct inode *inode = filep->f_inode;
+    struct uart_driver_data *udd = (struct uart_driver_data *)inode->i_private;
+    if (udd == NULL) {
+        uart_error("uart_driver_data is NULL");
+        return -EINVAL;
+    }
+    if (UART_STATE_USEABLE != udd->state) {
+        return -EFAULT;
+    }
+
+    poll_wait(filep, &udd->wait, table);
+
+    if (!uart_rx_buf_empty(udd)) {
+        return POLLIN | POLLRDNORM;
+    }
+    return 0;
+}
+
+static ssize_t uartdev_map(FAR struct file* filep, FAR LosVmMapRegion *region)
+{
+    PRINTK("%s %d, mmap is not support\n", __FUNCTION__, __LINE__);
+    return 0;
+}
+
+const struct file_operations_vfs uartdev_fops = {
+    .open   = uartdev_open,
+    .close  = uartdev_release,
+    .read   = uartdev_read,
+    .write  = uartdev_write,
+    .seek   = NULL,
+    .ioctl  = uartdev_ioctl,
+    .mmap   = uartdev_map,
+#ifndef CONFIG_DISABLE_POLL
+    .poll   = uartdev_poll,
+#endif
+    .unlink = NULL,
+};
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_dev.h openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_dev.h
--- openharmony/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_dev.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_dev.h	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,245 @@
+#ifndef __UART_USER_H__
+#define __UART_USER_H__
+
+#include "sys/ioctl.h"
+#include "linux/wait.h"
+#include "poll.h"
+#include "console.h"
+
+#define UART_IOC_MAGIC   'u'
+
+/* baudrate config */
+#define UART_CFG_BAUDRATE _IO(UART_IOC_MAGIC, 1)
+
+/* DMA CONFIG: receive */
+#define UART_DMA_RX_EN    1
+#define UART_DMA_RX_DIS    0
+
+#define UART_CFG_DMA_RX    _IO(UART_IOC_MAGIC, 2)
+
+/* DMA CONFIG: send */
+#define UART_DMA_TX_EN    1
+#define UART_DMA_TX_DIS    0
+
+#define UART_CFG_DMA_TX    _IO(UART_IOC_MAGIC, 3)
+
+/* Read Block: */
+#define UART_RD_BLOCK    1
+#define UART_RD_NONBLOCK    0
+
+#define UART_CFG_RD_BLOCK    CONSOLE_CMD_RD_BLOCK_SERIAL
+
+/* ATTRIBUTE CONFIG: data_bits, stop_bits, etc. */
+struct uart_attr {
+    unsigned int data_bits : 4;    /* bit0~3: data bits */
+#define UART_ATTR_DATABIT_8    0
+#define UART_ATTR_DATABIT_7    1
+#define UART_ATTR_DATABIT_6    2
+#define UART_ATTR_DATABIT_5    3
+
+    unsigned int parity : 4;      /* bit4~7: parity */
+#define UART_ATTR_PARITY_NONE    0
+#define UART_ATTR_PARITY_ODD    1
+#define UART_ATTR_PARITY_EVEN    2
+#define UART_ATTR_PARITY_MARK    3
+#define UART_ATTR_PARITY_SPACE    4
+
+    unsigned int stop_bits : 4;   /* bit8~11: stop bits */
+#define UART_ATTR_STOPBIT_1    0
+#define UART_ATTR_STOPBIT_1P5    1
+#define UART_ATTR_STOPBIT_2    2
+
+    unsigned int rts : 1;    /* bit 12: rts */
+#define UART_ATTR_RTS_DIS    0
+#define UART_ATTR_RTS_EN    1
+
+    unsigned int cts : 1;    /* bit 13: cts */
+#define UART_ATTR_CTS_DIS    0
+#define UART_ATTR_CTS_EN    1
+
+    unsigned int fifo_rx_en : 1;    /* bit 14: rx fifo enable */
+#define UART_ATTR_RX_FIFO_DIS    0
+#define UART_ATTR_RX_FIFO_EN    1
+
+    unsigned int fifo_tx_en : 1;    /* bit 15: tx fifo enable */
+#define UART_ATTR_TX_FIFO_DIS    0
+#define UART_ATTR_TX_FIFO_EN    1
+
+    unsigned int reserved : 16;    /* bit16~31: reserved */
+};
+/*
+ * uart attribute config cmd,
+ * parameter should be 'struct uart_init *'
+ * */
+#define UART_CFG_ATTR    _IOW(UART_IOC_MAGIC, 5, int)
+
+#define BUF_SIZE    0x4000    /* receive buf default size: 16K */
+struct uart_driver_data;
+
+struct uart_ops {
+    int (*startup)(struct uart_driver_data *udd);
+    int (*shutdown)(struct uart_driver_data *udd);
+
+    int (*dma_startup)(struct uart_driver_data *udd, int dir);
+    int (*dma_shutdown)(struct uart_driver_data *udd, int dir);
+#define UART_DMA_DIR_RX    0
+#define UART_DMA_DIR_TX    1
+
+    int (*start_tx)(struct uart_driver_data *udd,
+                    const char *buf, size_t count);
+
+    int (*config)(struct uart_driver_data *udd);
+    /* private operation */
+    int (*priv_operator)(struct uart_driver_data *udd, void *data);
+};
+
+struct uart_ioc_transfer {
+    unsigned int rp;
+    unsigned int wp;
+    unsigned int flags;
+#define BUF_CIRCLED    (1 << 0)
+#define BUF_OVERFLOWED    (1 << 1)
+#define BUF_EMPTIED    (1 << 2)
+
+    char data[BUF_SIZE];
+};
+
+struct __uart_attr {
+    unsigned int data_bits : 4;    /* bit0~3: data bits */
+#define UART_ATTR_DATABIT_8    0
+#define UART_ATTR_DATABIT_7    1
+#define UART_ATTR_DATABIT_6    2
+#define UART_ATTR_DATABIT_5    3
+
+    unsigned int parity : 4;      /* bit4~7: parity */
+#define UART_ATTR_PARITY_NONE    0
+#define UART_ATTR_PARITY_ODD    1
+#define UART_ATTR_PARITY_EVEN    2
+#define UART_ATTR_PARITY_MARK    3
+#define UART_ATTR_PARITY_SPACE    4
+
+    unsigned int stop_bits : 4;   /* bit8~11: stop bits */
+#define UART_ATTR_STOPBIT_1    0
+#define UART_ATTR_STOPBIT_1P5    1
+#define UART_ATTR_STOPBIT_2    2
+
+    unsigned int rts : 1;    /* bit 12: rts */
+#define UART_ATTR_RTS_DIS    0
+#define UART_ATTR_RTS_EN    1
+
+    unsigned int cts : 1;    /* bit 13: cts */
+#define UART_ATTR_CTS_DIS    0
+#define UART_ATTR_CTS_EN    1
+
+    unsigned int fifo_rx_en : 1;    /* bit 14: rx fifo enable */
+#define UART_ATTR_RX_FIFO_DIS    0
+#define UART_ATTR_RX_FIFO_EN    1
+
+    unsigned int fifo_tx_en : 1;    /* bit 15: tx fifo enable */
+#define UART_ATTR_TX_FIFO_DIS    0
+#define UART_ATTR_TX_FIFO_EN    1
+
+    unsigned int reserved : 16;    /* bit16~31: reserved */
+};
+
+typedef int (*recv_notify)(struct uart_driver_data *udd,
+                           const char *buf, size_t count);
+
+struct uart_driver_data {
+    unsigned int num;
+    unsigned int baudrate;
+    struct __uart_attr attr;
+    struct uart_ioc_transfer *rx_transfer;
+    wait_queue_head_t wait;
+    int count;
+    int state;
+#define UART_STATE_NOT_OPENED   (0)
+#define UART_STATE_OPENING       (1)
+#define UART_STATE_USEABLE       (2)
+#define UART_STATE_SUSPENED     (3)
+
+    unsigned int flags;
+#define UART_FLG_DMA_RX   (1 << 0)
+#define UART_FLG_DMA_TX   (1 << 1)
+#define UART_FLG_RD_BLOCK   (1 << 2)
+
+    recv_notify recv;
+    struct uart_ops *ops;
+    void *private;
+};
+
+
+#ifndef FALSE
+#define FALSE    (0)
+#endif
+
+#ifndef TRUE
+#define TRUE    (1)
+#endif
+
+
+
+
+#define CONFIG_MAX_BAUDRATE    921600 /* max baud rate */
+
+
+/* trace */
+#define  TRACE_INIT    (1<<0)
+#define  TRACE_DATA    (1<<2)
+#define  TRACE_MSG     (1<<3)
+#define  TRACE_ERR     (1<<4)
+
+#define TRACE_MASK     (0xff)
+/* messages print definitions, for debug ,err e.g. */
+#ifdef LOSCFG_DEBUG_VERSION
+#define uart_trace(mask, msg...) do { \
+        if ((mask) & TRACE_MASK) { \
+            dprintf("<uart>,%s:%d: ", __func__, __LINE__); \
+            dprintf(msg); \
+            dprintf("\n"); \
+        } \
+    } while (0)
+#else
+#define uart_trace(mask, msg...)
+#endif
+
+#define uart_error(msg...) do { \
+    dprintf("<uart,err>:%s,%d: ", __func__, __LINE__); \
+    dprintf(msg); \
+    dprintf("\n"); \
+}while(0)
+
+
+
+/*
+ * uart core functions
+ * */
+/* read some data from rx_data buf in uart_ioc_transfer */
+int uart_dev_read(struct uart_driver_data *udd, char *buf, size_t count);
+/* check the buf is empty */
+int uart_rx_buf_empty(struct uart_driver_data *udd);
+
+int uart_recv_notify(struct uart_driver_data *udd, const char *buf, size_t count);
+
+/*
+ * uart functions which are in uart host driver
+ * uart host driver must define them
+ * */
+/* get uart host numbers */
+int get_uart_num(void);
+/* get uart driver data(udd) which is defined in uart host drivers,
+ * through uart number */
+struct uart_driver_data *get_uart_drv_data(int num);
+/* uart private cmmand for uart host */
+#define UART_CFG_PRIVATE    _IOW(UART_IOC_MAGIC, 6, int)
+
+int uart_dev_init(void);
+int uartdev_de_init(void);
+int uart_suspend(void *data);
+int uart_resume(void *data);
+void uart_early_init(void);
+
+struct uart_softc {
+    struct uart_driver_data *udd;
+};
+#endif /* __UART_USER_H__ */
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_imx6ull.c openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_imx6ull.c
--- openharmony/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_imx6ull.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/imx6ull-uart/uart_imx6ull.c	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,409 @@
+#include "linux/delay.h"
+#include "asm/io.h"
+
+#include "los_typedef.h"
+#include "los_task.h"
+#include "los_base.h"
+#include "los_event.h"
+#include "errno.h"
+
+#include "linux/interrupt.h"
+#include "linux/kernel.h"
+#include "linux/spinlock.h"
+#include "imx6ull_uart.h"
+#include "asm/platform.h"
+#include <sys/bus.h>
+
+#include "uart.h"
+#include "uart_dev.h"
+#include "string.h"
+
+#include "los_magickey.h"
+#include "imx6ull_uart.h"
+
+struct imx6ull_port {
+        int enable;
+        unsigned long phys_base;
+        unsigned int irq_num;
+        struct uart_driver_data *udd;
+};
+
+__attribute__ ((section(".data"))) UINT32 g_uart_fputc_en = 1;
+
+
+LITE_OS_SEC_BSS STATIC SPIN_LOCK_INIT(g_uartOutputSpin);
+
+
+STATIC INLINE UINTPTR uart_to_ptr(UINTPTR n)
+{
+    (VOID)n;
+    return UART_REG_BASE;
+}
+
+STATIC VOID UartPutcReg(UINTPTR base, CHAR c)
+{
+	UART_Type *uartRegs = (UART_Type *)base;
+
+	while (!((uartRegs->USR2) & (1<<3))); /*等待上个字节发送完毕*/
+	uartRegs->UTXD = (unsigned char)c;		
+
+}
+
+STATIC VOID UartPutStr(UINTPTR base, const CHAR *s, UINT32 len)
+{
+    UINT32 i;
+
+    for (i = 0; i < len; i++) {
+        if (*(s + i) == '\n') {
+			UartPutcReg(base, *"\r");
+        }
+		UartPutcReg(base, *(s + i));
+    }
+}
+
+
+UINT32 UartPutsReg(UINTPTR base, const CHAR *s, UINT32 len, BOOL isLock)
+{
+    UINT32 intSave;
+
+    if (g_uart_fputc_en == 0) {
+        return 0;
+    }
+
+    if (isLock) {
+        LOS_SpinLockSave(&g_uartOutputSpin, &intSave);
+        UartPutStr(base, s, len);
+        LOS_SpinUnlockRestore(&g_uartOutputSpin, intSave);
+    } else {
+        UartPutStr(base, s, len);
+    }
+
+    return len;
+}
+
+VOID UartPuts(const CHAR *s, UINT32 len, BOOL isLock)
+{
+    UINTPTR base = uart_to_ptr(0);
+    (VOID)UartPutsReg(base, s, len, isLock);
+}
+
+INT32 uart_puts(const CHAR *s, UINTPTR len, VOID *state)
+{
+    (VOID)state;
+    UINTPTR i;
+
+    for (i = 0; i < len; i++) {
+        if (*(s + i) != '\0') {
+            if (*(s + i) == '\n') {
+                (VOID)uart_fputc('\r', NULL);
+            }
+
+            (VOID)uart_fputc(*(s + i), NULL);
+        }
+    }
+
+    return (INT32)len;
+}
+VOID uart_early_init(VOID)
+{
+    /* enable uart transmit */
+}
+
+VOID uart_init(VOID)
+{
+}
+
+#define FIFO_SIZE    128
+
+static irqreturn_t imx6ull_uart_irq(int irq, void *data)
+{
+	char buf[FIFO_SIZE];
+	unsigned int count = 0;
+	struct imx6ull_port *port = NULL;
+	struct uart_driver_data *udd = (struct uart_driver_data *)data;
+	UART_Type *uartRegs;
+    uint32_t status;
+	
+	if (udd == NULL) {
+		uart_error("udd is null!\n");
+		return IRQ_HANDLED;
+	}
+	port = (struct imx6ull_port *)udd->private;
+
+	uartRegs = (UART_Type *)port->phys_base;
+
+    status = uartRegs->USR2;
+    if (status & (1<<0)) {
+        do {
+            buf[count++] = uartRegs->URXD;
+            if (udd->num != CONSOLE_UART) {
+				PRINT_RELEASE("%s %s %d, udd->num = %d, CONSOLE_UART = %d\n", __FILE__, __FUNCTION__, __LINE__, udd->num, CONSOLE_UART);
+                continue;
+            }
+            if (CheckMagicKey(buf[count - 1])) {
+                goto end;
+            }
+
+			if (buf[count-1] == '\r')
+				buf[count-1] = '\n';
+			status = uartRegs->USR2;
+		} while (status & (1<<0));
+		//buf[count] = '\0';
+		//PRINT_RELEASE("%s %s %d, udd->recv %d, %s\n", __FILE__, __FUNCTION__, __LINE__, count, buf);
+        udd->recv(udd, buf, count);
+    }
+	
+end:
+	/* clear all interrupt */
+	return 0;
+}
+
+
+static int imx6ull_config_in(struct uart_driver_data *udd)
+{
+	return 0;
+}
+
+static int imx6ull_startup(struct uart_driver_data *udd) 
+{
+	int ret = 0;
+	struct imx6ull_port *port = NULL;
+	UART_Type *uartRegs;
+
+	if (udd == NULL) {
+		uart_error("udd is null!\n");
+		return -EFAULT;
+	}
+
+	port = (struct imx6ull_port *)udd->private;
+	if (!port) {
+		uart_error("port is null!");
+		return -EFAULT;
+	}
+	
+	uartRegs = (UART_Type *)port->phys_base;
+	
+	/* enable the clock */
+	LOS_TaskLock();
+	//uart_clk_cfg(udd->num, true); //use for hi3518
+	LOS_TaskUnlock();
+	
+	
+	uartRegs = (UART_Type *)port->phys_base;
+	
+    /* enable the clock */
+    /* uart disable */
+	uartRegs->UCR1 &= ~(1<<0);
+	
+    /* clear all interrupt,set mask */
+    /* mask all interrupt */
+
+	/* enable Transmitter and Receiver */
+	uartRegs->UCR2 |= (1<<2)|(1<<1);
+
+    /* mask all interrupt */
+	/* UCR3
+	 * [13] : DTREN, Data Terminal Ready Interrupt Enable
+	 * [12] : PARERREN, Parity Error Interrupt Enable
+	 * [11] : FRAERREN, Frame Error Interrupt Enable
+	 * [5]  : AIRINTEN, Asynchronous IR WAKE Interrupt Enable
+	 * [4]  : AWAKEN, Asynchronous WAKE Interrupt Enable
+	 * [3]  : DTRDEN, Data Terminal Ready Delta Enable
+	 * [0]  : ACIEN, Autobaud Counter Interrupt Enable
+	 */
+	uartRegs->UCR3 &= ~((1<<13)|(1<<12)|(1<<11)|(1<<5)|(1<<4)|(1<<3)|(1<<0));
+
+	/* UCR4
+	 * [8] : ENIRI, Serial Infrared Interrupt Enable
+	 * [7] : WKEN, WAKE Interrupt Enable
+	 * [6] : IDDMAEN, DMA IDLE Condition Detected Interrupt Enable
+	 * [3]  : TCEN, TransmitComplete Interrupt Enable
+	 * [2]  : BKEN, BREAK Condition Detected Interrupt Enable
+	 * [1]  : OREN, Receiver Overrun Interrupt Enable
+	 * [0]  : DREN, Receive Data Ready Interrupt Enable
+	 */
+	uartRegs->UCR4 &= ~((1<<8)|(1<<7)|(1<<6)|(1<<3)|(1<<2)|(1<<1)|(1<<0));
+	
+
+	ret = request_irq(port->irq_num, (irq_handler_t)imx6ull_uart_irq,
+							  0, "uart_dw", udd);
+
+	/* enable rx interrupt */
+	uartRegs->UCR4 |= (1<<0);
+
+	/* enable uart */
+	uartRegs->UCR1 |= (1<<0);
+	
+	imx6ull_config_in(udd);
+
+	return ret;
+}
+
+static int imx6ull_shutdown(struct uart_driver_data *udd)
+{
+	return 0;
+}
+
+static int imx6ull_start_tx(struct uart_driver_data *udd, const char *buf, size_t count)
+{
+	unsigned int tx_len = count;
+	struct imx6ull_port *port = NULL;
+	char value;
+	unsigned int i;
+	int ret = 0;
+
+	if (udd == NULL) {
+		uart_error("udd is null!\n");
+		return -EFAULT;
+	}
+	port = (struct imx6ull_port *)udd->private;
+	if (!port) {
+		uart_error("port is null!");
+		return -EFAULT;
+	}
+	/* UART_WITH_LOCK: there is a spinlock in the function to write reg in order. */
+	for (i = 0; i < tx_len; i++ ){
+		ret = LOS_CopyToKernel((void *)&value, sizeof(char),(void *)(buf++), sizeof(char));
+		if (ret) {
+			return i;
+		}
+		(void)UartPutsReg(port->phys_base, &value, 1, UART_WITH_LOCK);
+	}
+	return count;
+}
+
+static int imx6ull_config(struct uart_driver_data *udd)
+{
+	return imx6ull_config_in(udd);
+}
+
+static struct uart_ops imx6ull_uops = {
+	.startup        = imx6ull_startup,
+	.shutdown       = imx6ull_shutdown,
+	.start_tx       = imx6ull_start_tx,
+	.config         = imx6ull_config,
+};
+
+#define MAX_DEV_NAME_SIZE  32
+extern const struct file_operations_vfs uartdev_fops;
+extern struct uart_driver_data *get_udd_by_unit(int unit);
+
+static int imx6ull_attach(device_t self)
+{
+	struct resource *res = NULL;
+	char dev_name[MAX_DEV_NAME_SIZE];
+	struct imx6ull_port *port = NULL;
+	int unit = device_get_unit(self);
+	struct uart_softc *sc = device_get_softc(self);
+	struct uart_driver_data *udd = sc->udd;
+
+	if (udd == NULL) {
+		uart_error("imx6ull_attach get uart driver data err!");
+		return -1;
+	}
+	port = (struct imx6ull_port *)LOS_MemAlloc(m_aucSysMem0, sizeof(struct imx6ull_port));
+	if (!port) {
+		return -1;
+	}
+	memset_s(port, sizeof(struct imx6ull_port), 0, sizeof(struct imx6ull_port));
+	res = bus_alloc_resource_any(self, SYS_RES_MEMORY, &unit, 0);
+	if (!res) {
+		goto err;
+	}
+	port->phys_base = (unsigned long)(uintptr_t)ioremap(res->start, res->count);
+	if (!port->phys_base) {
+		goto err;
+	}
+	res = bus_alloc_resource_any(self, SYS_RES_IRQ, &unit, 0);
+	if (!res) {
+		goto err;
+	}
+	
+	port->irq_num = res->start;
+	if (port->irq_num == LOS_NOK) {
+		goto err;
+	}
+
+	udd->private = port;
+	udd->ops = &imx6ull_uops;
+	port->udd = udd;
+	udd->recv = uart_recv_notify;
+	udd->count = 0;
+	memset_s(dev_name, MAX_DEV_NAME_SIZE, 0, MAX_DEV_NAME_SIZE);
+	snprintf_s(dev_name, MAX_DEV_NAME_SIZE, MAX_DEV_NAME_SIZE - 1, "/dev/uartdev-%d", udd->num);
+	if (register_driver(dev_name, &uartdev_fops, 0666, udd)) {
+		uart_error("gen /dev/uartdev-%d fail!\n", udd->num);
+		goto err;
+	}
+
+	return 0;
+err:
+	iounmap((void *)(uintptr_t)port->phys_base);
+	(VOID)LOS_MemFree(m_aucSysMem0, port);
+	port =  NULL;
+	return -1;
+}
+
+static int imx6ull_probe(device_t self)
+{
+	return (BUS_PROBE_DEFAULT);
+}
+
+static int imx6ull_detach(device_t self)
+{
+	struct uart_softc *sc = device_get_softc(self);
+	struct uart_driver_data *udd = sc->udd;
+	struct imx6ull_port *port = NULL;
+	char dev_name[MAX_DEV_NAME_SIZE];
+	if (udd == NULL || (udd->state != UART_STATE_USEABLE)) {
+		uart_error("imx6ull_detach uart driver data state invalid!");
+		return -1;
+	}
+
+	(void)memset_s(dev_name, MAX_DEV_NAME_SIZE, 0, MAX_DEV_NAME_SIZE);
+	(void)snprintf_s(dev_name, MAX_DEV_NAME_SIZE, MAX_DEV_NAME_SIZE - 1, "/dev/uartdev-%d", udd->num);
+	if (unregister_driver(dev_name)) {
+		uart_error("imx6ull_detach unregister /dev/uartdev-%d fail!\n", udd->num);
+	}
+	port = udd->private;
+	if (port == NULL) {
+		return -1;
+	}
+	if (port->phys_base) {
+		iounmap((void *)(uintptr_t)port->phys_base);
+		port->phys_base = 0;
+	}
+	(VOID)LOS_MemFree(m_aucSysMem0, port);
+	udd->private = NULL;
+	return 0;
+}
+
+static device_method_t uart_methods[] = 
+{
+	/* Device interface */
+	DEVMETHOD(device_probe, imx6ull_probe),
+	DEVMETHOD(device_attach, imx6ull_attach),
+	DEVMETHOD(device_detach, imx6ull_detach),
+	DEVMETHOD(device_shutdown, bus_generic_shutdown),
+	DEVMETHOD_END
+};
+
+static driver_t uart_driver = 
+{
+	.name = "uart",
+	.methods = uart_methods,
+	.size = sizeof(struct uart_softc),
+};
+
+static devclass_t uart_devclass;
+DRIVER_MODULE(uart, nexus, uart_driver, uart_devclass, 0, 0);
+
+int uart_dev_init(void)
+{
+	return driver_module_handler(NULL, MOD_LOAD, &uart_nexus_driver_mod);
+}
+
+void uart_dev_exit(void)
+{
+	driver_module_handler(NULL, MOD_UNLOAD, &uart_nexus_driver_mod);
+}
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/common/BUILD.gn openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/BUILD.gn
--- openharmony/vendor/nxp/imx6ull/driver/mtd/common/BUILD.gn	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/BUILD.gn	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,42 @@
+# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("drivers_mtd_common") {
+
+    sources = [
+        "src/common.c",
+        "src/mtd_list.c",
+        "src/mtdblock.c",
+        "src/mtdchar.c",
+    ]
+
+    include_dirs = [
+        "include",
+    ]
+}
\ No newline at end of file
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/common/include/hifmc_common.h openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/include/hifmc_common.h
--- openharmony/vendor/nxp/imx6ull/driver/mtd/common/include/hifmc_common.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/include/hifmc_common.h	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,306 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __HIFMC_COMMON_H__
+#define __HIFMC_COMMON_H__
+
+/* HIFMC ECCTYPE REG CONFIG */
+enum hifmc_ecc_reg {
+    hifmc_ecc_0bit   = 0x00,
+    hifmc_ecc_8bit   = 0x01,
+    hifmc_ecc_16bit  = 0x02,
+    hifmc_ecc_24bit  = 0x03,
+    hifmc_ecc_28bit  = 0x04,
+    hifmc_ecc_40bit  = 0x05,
+    hifmc_ecc_64bit  = 0x06,
+};
+
+/* HIFMC PAGESIZE REG CONFIG */
+enum hifmc_page_reg {
+    hifmc_pagesize_2K    = 0x0,
+    hifmc_pagesize_4K    = 0x1,
+    hifmc_pagesize_8K    = 0x2,
+    hifmc_pagesize_16K   = 0x3,
+};
+
+enum hifmc_page_reg hifmc_page_type2reg(int type);
+int hifmc_page_reg2type(enum hifmc_page_reg reg);
+enum hifmc_ecc_reg hifmc_ecc_type2reg(int type);
+int hifmc_ecc_reg2type(enum hifmc_ecc_reg reg);
+
+/* HIFMC REG */
+/*****************************************************************************/
+#define FMC_CFG                             0x00
+#define FMC_CFG_SPI_NAND_SEL(_type)         (((_size) & 0x3) << 11)
+#define FMC_CFG_SPI_NOR_ADDR_MODE(_mode)    ((_mode) << 10)
+#define FMC_CFG_BLOCK_SIZE(_size)           (((_size) & 0x3) << 8)
+#define FMC_CFG_ECC_TYPE(_type)             (((_type) & 0x7) << 5)
+#define FMC_CFG_PAGE_SIZE(_size)            (((_size) & 0x3) << 3)
+#define FMC_CFG_FLASH_SEL(_type)            (((_type) & 0x3) << 1)
+#define FMC_CFG_OP_MODE(_mode)              ((_mode) & 0x1)
+
+#define SPI_NOR_ADDR_MODE_3_BYTES           0x0
+#define SPI_NOR_ADDR_MODE_4_BYTES           0x1
+
+#define FMC_SPI_NOR_ADDR_MODE_SHIFT             10
+#define FMC_SPI_NOR_ADDR_MODE_MASK              (0x1 << FMC_SPI_NOR_ADDR_MODE_SHIFT)
+
+#define ECC_TYPE_SHIFT                      5
+#define ECC_TYPE_MASK                       (0x7 << ECC_TYPE_SHIFT)
+
+#define HFMC_PAGE_SHIFT                     3
+#define PAGE_SIZE_MASK                      (0x3 << HFMC_PAGE_SHIFT)
+
+#define FLASH_TYPE_SPI_NOR                  0x0
+#define FLASH_TYPE_SPI_NAND                 0x1
+#define FLASH_TYPE_NAND                     0x2
+#define FLASH_TYPE_DEFAULT                  0x3
+#define FLASH_SEL_SHIFT                     1
+#define FLASH_SEL_MASK                      (0x3 << FLASH_SEL_SHIFT)
+
+#define OP_MODE_BOOT                        0x0
+#define OP_MODE_NORMAL                      0x1
+#define OP_MODE_MASK                        0x1
+
+/*****************************************************************************/
+#define FMC_GLOBAL_CFG                      0x04
+#define FMC_GLOBAL_CFG_WP_ENABLE            (1 << 6)
+#define FMC_GLOBAL_CFG_RANDOMIZER_EN        (1 << 2)
+#define FMC_GLOBAL_CFG_EDO_EN               (1 << 9)
+
+/*****************************************************************************/
+#define FMC_SPI_TIMING_CFG                  0x08
+#define TIMING_CFG_TCSH(_n)                 (((_n) & 0xf) << 8)
+#define TIMING_CFG_TCSS(_n)                 (((_n) & 0xf) << 4)
+#define TIMING_CFG_TSHSL(_n)                ((_n) & 0xf)
+
+#define CS_HOLD_TIME                        0x6
+#define CS_SETUP_TIME                       0x6
+#define CS_DESELECT_TIME                    0xf
+
+/*****************************************************************************/
+#define FMC_PND_PWIDTH_CFG                  0x0c
+#define PWIDTH_CFG_RW_HCNT(_n)              (((_n) & 0xf) << 8)
+#define PWIDTH_CFG_R_LCNT(_n)               (((_n) & 0xf) << 4)
+#define PWIDTH_CFG_W_LCNT(_n)               ((_n) & 0xf)
+#define RW_H_WIDTH                          (0x2)
+#define R_L_WIDTH                           (0x3)
+#define W_L_WIDTH                           (0x2)
+
+/*****************************************************************************/
+#define FMC_INT                             0x18
+#define FMC_INT_AHB_OP                      (1 << 7)
+#define FMC_INT_WR_LOCK                     (1 << 6)
+#define FMC_INT_DMA_ERR                     (1 << 5)
+#define FMC_INT_ERR_ALARM                   (1 << 4)
+#define FMC_INT_ERR_INVALID                 (1 << 3)
+#define FMC_INT_ERR_VALID                   (1 << 2)
+#define FMC_INT_OP_FAIL                     (1 << 1)
+#define FMC_INT_OP_DONE                     (1 << 0)
+
+/*****************************************************************************/
+#define FMC_INT_EN                          0x1c
+#define FMC_INT_EN_AHB_OP                   (1 << 7)
+#define FMC_INT_EN_WR_LOCK                  (1 << 6)
+#define FMC_INT_EN_DMA_ERR                  (1 << 5)
+#define FMC_INT_EN_ERR_ALARM                (1 << 4)
+#define FMC_INT_EN_ERR_INVALID              (1 << 3)
+#define FMC_INT_EN_ERR_VALID                (1 << 2)
+#define FMC_INT_EN_OP_FAIL                  (1 << 1)
+#define FMC_INT_EN_OP_DONE                  (1 << 0)
+
+/*****************************************************************************/
+#define FMC_INT_CLR                         0x20
+#define FMC_INT_CLR_AHB_OP                  (1 << 7)
+#define FMC_INT_CLR_WR_LOCK                 (1 << 6)
+#define FMC_INT_CLR_DMA_ERR                 (1 << 5)
+#define FMC_INT_CLR_ERR_ALARM               (1 << 4)
+#define FMC_INT_CLR_ERR_INVALID             (1 << 3)
+#define FMC_INT_CLR_ERR_VALID               (1 << 2)
+#define FMC_INT_CLR_OP_FAIL                 (1 << 1)
+#define FMC_INT_CLR_OP_DONE                 (1 << 0)
+#define FMC_INT_CLR_ALL                     0xff
+
+/*****************************************************************************/
+#define FMC_CMD                             0x24
+#define FMC_CMD_CMD2(_cmd)                  (((_cmd) & 0xff) << 8)
+#define FMC_CMD_CMD1(_cmd)                  ((_cmd) & 0xff)
+
+/*****************************************************************************/
+#define FMC_ADDRH                           0x28
+#define FMC_ADDRL                           0x2c
+
+/*****************************************************************************/
+#define FMC_OP_CFG                          0x30
+#define OP_CFG_FM_CS(_cs)                   ((_cs) << 11)
+#define OP_CFG_FORCE_CS_EN(_en)             ((_en) << 10)
+#define OP_CFG_MEM_IF_TYPE(_type)           (((_type) & 0x7) << 7)
+#define OP_CFG_ADDR_NUM(_addr)              (((_addr) & 0x7) << 4)
+#define OP_CFG_DUMMY_NUM(_dummy)            ((_dummy) & 0xf)
+
+/*****************************************************************************/
+#define FMC_SPI_OP_ADDR                     0x34
+
+/*****************************************************************************/
+#define FMC_DATA_NUM                        0x38
+#define FMC_DATA_NUM_CNT(_n)                ((_n) & 0x3fff)
+
+/*****************************************************************************/
+#define FMC_OP                              0x3c
+#define FMC_OP_DUMMY_EN(_en)                ((_en) << 8)
+#define FMC_OP_CMD1_EN(_en)                 ((_en) << 7)
+#define FMC_OP_ADDR_EN(_en)                 ((_en) << 6)
+#define FMC_OP_WRITE_DATA_EN(_en)           ((_en) << 5)
+#define FMC_OP_CMD2_EN(_en)                 ((_en) << 4)
+#define FMC_OP_WAIT_READY_EN(_en)           ((_en) << 3)
+#define FMC_OP_READ_DATA_EN(_en)            ((_en) << 2)
+#define FMC_OP_READ_STATUS_EN(_en)          ((_en) << 1)
+#define FMC_OP_REG_OP_START                 1
+
+/*****************************************************************************/
+#define FMC_DMA_LEN                         0x40
+#define FMC_DMA_LEN_SET(_len)               ((_len) & 0x0fffffff)
+
+/*****************************************************************************/
+#define FMC_DMA_AHB_CTRL                    0x48
+#define FMC_DMA_AHB_CTRL_DMA_PP_EN          (1 << 3)
+#define FMC_DMA_AHB_CTRL_BURST16_EN         (1 << 2)
+#define FMC_DMA_AHB_CTRL_BURST8_EN          (1 << 1)
+#define FMC_DMA_AHB_CTRL_BURST4_EN          1
+#define ALL_BURST_ENABLE                    (FMC_DMA_AHB_CTRL_BURST16_EN \
+                                            | FMC_DMA_AHB_CTRL_BURST8_EN \
+                                            | FMC_DMA_AHB_CTRL_BURST4_EN)
+
+/*****************************************************************************/
+#define FMC_DMA_SADDR_D0                    0x4c
+#define FMC_DMA_SADDRH_D0                   0x200
+#define FMC_DMA_SADDR_D1                    0x50
+#define FMC_DMA_SADDRH_D1                   0x204
+#define FMC_DMA_SADDR_D2                    0x54
+#define FMC_DMA_SADDRH_D2                   0x208
+#define FMC_DMA_SADDR_D3                    0x58
+#define FMC_DMA_SADDRH_D3                   0x20c
+#define FMC_DMA_SADDR_OOB                   0x5c
+#define FMC_DMA_SADDRH_OOB                  0x210
+#define FMC_DMA_ADDR_OFFSET                 4096
+
+/*****************************************************************************/
+#define FMC_DMA_BLK_SADDR                   0x60
+#define FMC_DMA_BLK_SADDR_SET(_addr)        ((_addr) & 0xffffff)
+
+/*****************************************************************************/
+#define FMC_DMA_BLK_LEN                     0x64
+#define FMC_DMA_BLK_LEN_SET(_len)           ((_len) & 0xffff)
+
+/*****************************************************************************/
+#define FMC_OP_CTRL                         0x68
+#define OP_CTRL_RD_OPCODE(_code)            (((_code) & 0xff) << 16)
+#define OP_CTRL_WR_OPCODE(_code)            (((_code) & 0xff) << 8)
+#define OP_CTRL_RD_OP_SEL(_op)              (((_op) & 0x3) << 4)
+#define OP_CTRL_DMA_OP(_type)               ((_type) << 2)
+#define OP_CTRL_RW_OP(_op)                  ((_op) << 1)
+#define OP_CTRL_DMA_OP_READY                1
+
+#define RD_OP_READ_ALL_PAGE                 0x0
+#define RD_OP_READ_OOB                      0x1
+#define RD_OP_BLOCK_READ                    0x2
+
+#define RD_OP_SHIFT                         4
+#define RD_OP_MASK                          (0x3 << RD_OP_SHIFT)
+
+#define OP_TYPE_DMA                         0x0
+#define OP_TYPE_REG                         0x1
+
+#define RW_OP_READ                          0x0
+#define RW_OP_WRITE                         0x1
+
+/*****************************************************************************/
+#define FMC_OP_PARA                         0x70
+#define FMC_OP_PARA_RD_OOB_ONLY             (1 << 1)
+
+/*****************************************************************************/
+#define FMC_BOOT_SET                        0x74
+#define FMC_BOOT_SET_DEVICE_ECC_EN          (1 << 3)
+#define FMC_BOOT_SET_BOOT_QUAD_EN           (1 << 1)
+
+/*****************************************************************************/
+#define FMC_STATUS                          0xac
+
+#define GET_OP                              0
+#define SET_OP                              1
+
+/*****************************************************************************/
+#define FMC_VERSION                         0xbc
+
+/*****************************************************************************/
+#define FMC_CPU_WAIT_TIMEOUT        0x800000
+#define FMC_DMA_WAIT_TIMEOUT        0xf0000000
+
+#define FMC_CMD_WAIT_CPU_FINISH(_host) \
+    do { \
+        unsigned regval, timeout = FMC_CPU_WAIT_TIMEOUT; \
+        do { \
+            regval = reg_read((_host), FMC_OP); \
+            --timeout; \
+        } while ((regval & FMC_OP_REG_OP_START) && timeout); \
+        if (!timeout) \
+            ERR_MSG(" Wait cmd cpu finish timeout!\n"); \
+    } while (0)
+
+/*****************************************************************************/
+#define FMC_DMA_WAIT_INT_FINISH(_host) \
+    do { \
+        unsigned regval, timeout = FMC_DMA_WAIT_TIMEOUT; \
+        do { \
+            regval = reg_read((_host), FMC_INT); \
+            --timeout; \
+        } while ((!(regval & FMC_INT_OP_DONE) && timeout)); \
+        if (!timeout) { \
+            ERR_MSG(" Wait dma int finish timeout!\n"); \
+        } \
+    } while (0)
+
+/*****************************************************************************/
+#define FMC_DMA_WAIT_CPU_FINISH(_host) \
+    do { \
+        unsigned regval, timeout = FMC_CPU_WAIT_TIMEOUT; \
+        do { \
+            regval = reg_read((_host), FMC_OP_CTRL); \
+            --timeout; \
+        } while ((regval & OP_CTRL_DMA_OP_READY) && timeout); \
+        if (!timeout) { \
+            ERR_MSG(" Wait dma cpu finish timeout!\n"); \
+        } \
+    } while (0)
+
+/*****************************************************************************/
+#endif /* End of __HIFMC_COMMON_H__ */
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/common/include/mtd_common.h openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/include/mtd_common.h
--- openharmony/vendor/nxp/imx6ull/driver/mtd/common/include/mtd_common.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/include/mtd_common.h	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,183 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MTD_COMMON_H__
+#define __MTD_COMMON_H__
+
+#include "stdint.h"
+
+/*---------------------------------------------------------------------------*/
+/* base type macros */
+/*---------------------------------------------------------------------------*/
+#ifndef u16
+#define u16         unsigned short
+#endif
+#ifndef u32
+#define u32         unsigned int
+#endif
+#ifndef ulong
+#define ulong       unsigned long
+#endif
+
+/*---------------------------------------------------------------------------*/
+/* frequently-used macros */
+/*---------------------------------------------------------------------------*/
+#ifndef min
+#define min(x,y) (x<y?x:y)
+#endif
+#ifndef max
+#define max(x,y) (x<y?y:x)
+#endif
+#ifndef min_t
+#define min_t(t, x,y) ((t)x<(t)y?(t)x:(t)y)
+#endif
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+#endif
+
+/*---------------------------------------------------------------------------*/
+/* mtd device capacity mcaros */
+/*---------------------------------------------------------------------------*/
+#define _256B       (256)
+#define _512B       (512)
+#define _1K         (1024)
+#define _2K         (2048)
+#define _4K         (4096)
+#define _8K         (8192)
+#define _16K        (16384)
+#define _32K        (32768)
+#define _64K        (0x10000UL)
+#define _128K       (0x20000UL)
+#define _256K       (0x40000UL)
+#define _512K       (0x80000UL)
+#define _1M         (0x100000UL)
+#define _2M         (0x200000UL)
+#define _4M         (0x400000UL)
+#define _8M         (0x800000UL)
+#define _16M        (0x1000000UL)
+#define _32M        (0x2000000UL)
+#define _64M        (0x4000000UL)
+#define _128M       (0x8000000UL)
+#define _256M       (0x10000000UL)
+#define _512M       (0x20000000UL)
+#define _1G         (0x40000000ULL)
+#define _2G         (0x80000000ULL)
+#define _4G         (0x100000000ULL)
+#define _8G         (0x200000000ULL)
+#define _16G        (0x400000000ULL)
+#define _64G        (0x1000000000ULL)
+#define INFINITE    (0xFFFFFFFF)
+/*---------------------------------------------------------------------------*/
+/* mtd device print control mcaros */
+/*---------------------------------------------------------------------------*/
+#include "los_printf.h"
+#include "asm/io.h"
+
+#define DISABLE     0
+#define ENABLE      1
+
+#define READ        0
+#define WRITE       1
+
+#define MTD_REG_DEBUG DISABLE
+//#define MTD_REG_DEBUG ENABLE
+
+#define mtd_trace(debug, msg...) do { \
+    if (debug == ENABLE) { \
+        dprintf("%s:%d: ", __func__, __LINE__); \
+        dprintf(msg); \
+        dprintf("\n"); \
+    } \
+} while (0)
+
+#define mtd_readl(addr) ({unsigned int reg = readl((UINTPTR)addr); \
+        mtd_trace(MTD_REG_DEBUG, "readl(0x%p) = 0x%08X", (UINTPTR)addr, reg); \
+        reg; })
+
+#define mtd_writel(v, addr) do { \
+    writel(v, (UINTPTR)addr); \
+    mtd_trace(MTD_REG_DEBUG, "writel(0x%p) = 0x%08X",\
+            (UINTPTR)addr, (unsigned int)(v)); \
+} while (0)
+
+/*****************************************************************************/
+#define INIT_DBG      0        /* Init  debug print */
+#define ER_DBG        0        /* Erase debug print */
+#define WR_DBG        0        /* Write debug print */
+#define RD_DBG        0        /* Read  debug print */
+
+#define DB_BUG(fmt, args...) \
+    do { \
+        dprintf("%s(%d): BUG: " fmt, __FILE__, __LINE__, ##args); \
+        __asm("b ."); \
+    } while (0)
+
+#define DBG_MSG(_fmt, arg...) \
+    dprintf("%s(%d): " _fmt, __func__, __LINE__, ##arg);
+
+#define ERR_MSG(_fmt, arg...) \
+    dprintf("%s(%d): Error:" _fmt, __func__, __LINE__, ##arg);
+
+#define WARN_MSG(_fmt, arg...) \
+    dprintf("%s(%d): Warning:" _fmt, __func__, __LINE__, ##arg);
+
+#define INFO_MSG(_fmt, arg...) \
+    dprintf(_fmt, ##arg);
+
+#define MTD_PR(_type, _fmt, arg...) \
+    do { \
+        if (_type) \
+            DBG_MSG(_fmt, ##arg) \
+    } while (0)
+
+/* function and variable declaration */
+
+char *ulltostr(unsigned long long size);
+int ffs(int x);
+void mtd_dma_cache_inv(void *addr, unsigned int size);
+void mtd_dma_cache_clean(void *addr, unsigned int size);
+
+extern const struct file_operations_vfs g_mtdchar_fops;
+extern const struct block_operations g_dev_spinor_ops;
+extern const struct block_operations g_dev_nand_ops;
+
+static inline const struct file_operations_vfs * GetMtdCharFops(void)
+{
+    return &g_mtdchar_fops;
+}
+static inline const struct block_operations * GetDevSpinorOps(void)
+{
+	return &g_dev_spinor_ops;
+}
+
+#endif /* End of __MTD_COMMON_H__ */
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/common/include/spi_common.h openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/include/spi_common.h
--- openharmony/vendor/nxp/imx6ull/driver/mtd/common/include/spi_common.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/include/spi_common.h	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,402 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SPI_COMMON_H__
+#define __SPI_COMMON_H__
+
+#define FEATURE_ECC_ENABLE                  (1 << 4)
+#define FEATURE_QE_ENABLE                   (1 << 0)
+/*****************************************************************************/
+
+#define STATUS_P_FAIL_MASK                  (1 << 3)
+#define STATUS_E_FAIL_MASK                  (1 << 2)
+#define STATUS_WEL_MASK                     (1 << 1)
+#define STATUS_OIP_MASK                     (1 << 0)
+
+/*****************************************************************************/
+#define FEATURES_OP_ADDR_NUM                1
+#define STD_OP_ADDR_NUM                     3
+
+/*****************************************************************************/
+#define SPI_IF_TYPE_STD         0x0
+#define SPI_IF_TYPE_DUAL        0x1
+#define SPI_IF_TYPE_DIO         0x2
+#define SPI_IF_TYPE_QUAD        0x3
+#define SPI_IF_TYPE_QIO         0x4
+
+#define SPI_IF_READ_STD         (0x01)
+#define SPI_IF_READ_FAST        (0x02)
+#define SPI_IF_READ_DUAL        (0x04)
+#define SPI_IF_READ_DUAL_ADDR       (0x08)
+#define SPI_IF_READ_QUAD        (0x10)
+#define SPI_IF_READ_QUAD_ADDR       (0x20)
+#define SPI_IF_READ_QUAD_DTR        (0x40)
+#define  spi_is_quad(spi) \
+        (((SPI_IF_TYPE_QUAD == spi->read->iftype) \
+        || (SPI_IF_TYPE_QIO == spi->read->iftype) \
+        || (SPI_IF_TYPE_QUAD == spi->write->iftype) \
+        || (SPI_IF_TYPE_QIO == spi->write->iftype))?1:0)
+
+#define SPI_IF_WRITE_STD        (0x01)
+#define SPI_IF_WRITE_DUAL       (0x02)
+#define SPI_IF_WRITE_DUAL_ADDR      (0x04)
+#define SPI_IF_WRITE_QUAD       (0x08)
+#define SPI_IF_WRITE_QUAD_ADDR      (0x10)
+
+#define SPI_IF_ERASE_SECTOR_4K      (0x01)
+#define SPI_IF_ERASE_SECTOR_32K     (0x02)
+#define SPI_IF_ERASE_SECTOR_64K     (0x04)
+#define SPI_IF_ERASE_SECTOR_128K    (0x08)
+#define SPI_IF_ERASE_SECTOR_256K    (0x10)
+
+/*****************************************************************************/
+
+/*****************************************************************************/
+#define SPI_CMD_READ_STD        0x03    /* Standard read cache */
+#define SPI_CMD_READ_STD4B      0x13    /* Standard read cache 4byte mode */
+#define SPI_CMD_READ_FAST       0x0B    /* Higher speed read cache */
+#define SPI_CMD_READ_FAST4B     0x0C /* Higher speed read cache 4byte mode */
+#define SPI_CMD_READ_DUAL       0x3B    /* 2 IO read cache only date */
+#define SPI_CMD_READ_DUAL4B     0x3C /* 2 IO read cache only date 4byte mode*/
+#define SPI_CMD_READ_DUAL_ADDR  0xBB    /* 2 IO read cache date&addr */
+#define SPI_CMD_READ_DUAL_ADDR4B 0xBC /* 2 IO read cache date&addr 4byte mode */
+#define SPI_CMD_READ_QUAD       0x6B    /* 4 IO read cache only date */
+#define SPI_CMD_READ_QUAD4B     0x6C /* 4 IO read cache only date 4byte mode */
+#define SPI_CMD_READ_QUAD_ADDR  0xEB    /* 4 IO read cache date&addr */
+#define SPI_CMD_READ_QUAD_ADDR4B 0xEC /* 4 IO read cache date&addr 4byte mode */
+#define SPI_CMD_READ_QUAD_DTR       0xED    /* 4DTR MODE */
+#define SPI_CMD_READ_QUAD_DTR4B     0xEE    /* 4DTR MODE 4byte mode */
+#define SPI_CMD_READ_QUAD_DTR4B_WINBOND     0xEC    /* 4DTR MODE */
+
+#define SPI_CMD_WRITE_STD       0x02    /* Standard page program */
+#define SPI_CMD_WRITE_STD4B     0x12    /* Standard page program 4byte mode */
+#define SPI_CMD_WRITE_DUAL      0xA2    /* 2 IO program only date */
+#define SPI_CMD_WRITE_DUAL4B    0xA2    /* 2 IO program only date 4byte mode*/
+#define SPI_CMD_WRITE_DUAL_ADDR     0xD2    /* 2 IO program date&addr */
+#define SPI_CMD_WRITE_DUAL_ADDR4B   0xD2 /* 2 IO program date&addr 4byte mode */
+#define SPI_CMD_WRITE_QUAD      0x32    /* 4 IO program only date */
+#define SPI_CMD_WRITE_QUAD4B    0x34    /* 4 IO program only date 4byte mode */
+#define SPI_CMD_WRITE_QUAD_ADDR     0x38    /* 4 IO program date&addr */
+#define SPI_CMD_WRITE_QUAD_ADDR4B   0x3E /* 4 IO program date&addr 4byte mode*/
+
+#define SPI_CMD_SE_4K           0x20    /* 4KB sector Erase */
+#define SPI_CMD_SE_4K4B         0x21    /* 4KB sector Erase 4byte mode */
+#define SPI_CMD_SE_32K          0x52    /* 32KB sector Erase */
+#define SPI_CMD_SE_32K4B        0x5C    /* 32KB sector Erase 4byte mode */
+#define SPI_CMD_SE_64K          0xD8    /* 64KB sector Erase */
+#define SPI_CMD_SE_64K4B        0xDC    /* 64KB sector Erase 4byte mode */
+#define SPI_CMD_SE_128K         0xD8    /* 128KB sector Erase */
+#define SPI_CMD_SE_128K4B       0xD8    /* 128KB sector Erase 4byte mode */
+#define SPI_CMD_SE_256K         0xD8    /* 256KB sector Erase */
+#define SPI_CMD_SE_256K4B       0xD8    /* 256KB sector Erase 4byte mode */
+
+/*****************************************************************************/
+#define SET_READ_STD(_dummy_, _size_, _clk_) \
+    static struct spi_op read_std_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_STD, SPI_CMD_READ_STD, _dummy_, _size_, _clk_ }
+
+#define SET_READ_STD4B(_dummy_, _size_, _clk_) \
+    static struct spi_op read_std4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_STD, SPI_CMD_READ_STD4B, _dummy_, _size_, _clk_ }
+
+#define SET_READ_FAST(_dummy_, _size_, _clk_) \
+    static struct spi_op read_fast_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_FAST, SPI_CMD_READ_FAST, _dummy_, _size_, _clk_ }
+
+#define SET_READ_FAST4B(_dummy_, _size_, _clk_) \
+    static struct spi_op read_fast4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_FAST, SPI_CMD_READ_FAST4B, _dummy_, _size_, _clk_ }
+
+#define SET_READ_DUAL(_dummy_, _size_, _clk_) \
+    static struct spi_op read_dual_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_DUAL, SPI_CMD_READ_DUAL, _dummy_, _size_, _clk_ }
+
+#define SET_READ_DUAL4B(_dummy_, _size_, _clk_) \
+    static struct spi_op read_dual4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_DUAL, SPI_CMD_READ_DUAL4B, _dummy_, _size_, _clk_ }
+
+#define SET_READ_DUAL_ADDR(_dummy_, _size_, _clk_) \
+    static struct spi_op read_dual_addr_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_DUAL_ADDR, SPI_CMD_READ_DUAL_ADDR, _dummy_, _size_, _clk_ }
+
+#define SET_READ_DUAL_ADDR4B(_dummy_, _size_, _clk_) \
+    static struct spi_op read_dual_addr4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_DUAL_ADDR, SPI_CMD_READ_DUAL_ADDR4B, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_QUAD, SPI_CMD_READ_QUAD, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD4B(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_QUAD, SPI_CMD_READ_QUAD4B, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD_ADDR(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad_addr_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_QUAD_ADDR, SPI_CMD_READ_QUAD_ADDR, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD_ADDR4B(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad_addr4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_QUAD_ADDR, SPI_CMD_READ_QUAD_ADDR4B, _dummy_, _size_, _clk_ }
+
+#ifdef CONFIG_DTR_MODE_SUPPORT
+#define SET_READ_QUAD_DTR(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad_dtr_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_QUAD_DTR, SPI_CMD_READ_QUAD_DTR, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD_DTR4B(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad_dtr4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_QUAD_DTR, SPI_CMD_READ_QUAD_DTR4B, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD_DTR4B_WINBOND(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad_dtr_winbond_##_dummy_##_size_##_clk_ = \
+    {SPI_IF_READ_QUAD_DTR, SPI_CMD_READ_QUAD_DTR4B_WINBOND, \
+        _dummy_, _size_, _clk_ }
+#endif
+
+/*****************************************************************************/
+#define SET_WRITE_STD(_dummy_, _size_, _clk_) \
+    static struct spi_op write_std_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_WRITE_STD, SPI_CMD_WRITE_STD, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_STD4B(_dummy_, _size_, _clk_) \
+    static struct spi_op write_std4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_WRITE_STD, SPI_CMD_WRITE_STD4B, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_DUAL(_dummy_, _size_, _clk_) \
+    static struct spi_op write_dual_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_WRITE_DUAL, SPI_CMD_WRITE_DUAL, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_DUAL4B(_dummy_, _size_, _clk_) \
+    static struct spi_op write_dual4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_WRITE_DUAL, SPI_CMD_WRITE_DUAL4B, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_DUAL_ADDR(_dummy_, _size_, _clk_) \
+    static struct spi_op write_dual_addr_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_DUAL_ADDR, SPI_CMD_WRITE_DUAL_ADDR, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_DUAL_ADDR4B(_dummy_, _size_, _clk_) \
+    static struct spi_op write_dual_addr4b_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_DUAL_ADDR, SPI_CMD_WRITE_DUAL_ADDR4B, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_QUAD(_dummy_, _size_, _clk_) \
+    static struct spi_op write_quad_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_WRITE_QUAD, SPI_CMD_WRITE_QUAD, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_QUAD4B(_dummy_, _size_, _clk_) \
+    static struct spi_op write_quad4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_WRITE_QUAD, SPI_CMD_WRITE_QUAD4B, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_QUAD_ADDR(_dummy_, _size_, _clk_) \
+    static struct spi_op write_quad_addr_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_QUAD_ADDR, SPI_CMD_WRITE_QUAD_ADDR, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_QUAD_ADDR4B(_dummy_, _size_, _clk_) \
+    static struct spi_op write_quad_addr4b_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_QUAD_ADDR, SPI_CMD_WRITE_QUAD_ADDR4B, _dummy_, _size_, _clk_ }
+
+/*****************************************************************************/
+#define SET_ERASE_SECTOR_4K(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_4k_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_4K, SPI_CMD_SE_4K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_4K4B(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_4k4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_4K, SPI_CMD_SE_4K4B, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_32K(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_32k_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_32K, SPI_CMD_SE_32K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_32K4B(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_32k4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_32K, SPI_CMD_SE_32K4B, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_64K(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_64k_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_64K, SPI_CMD_SE_64K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_64K4B(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_64k4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_64K, SPI_CMD_SE_64K4B, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_128K(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_128k_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_128K, SPI_CMD_SE_128K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_128K4B(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_128k4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_128K, SPI_CMD_SE_128K4B, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_256K(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_256k_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_256K, SPI_CMD_SE_256K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_256K4B(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_256k4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_256K, SPI_CMD_SE_256K4B, _dummy_, _size_, _clk_ }
+
+/*****************************************************************************/
+#define READ_STD(_dummy_, _size_, _clk_) read_std_##_dummy_##_size_##_clk_
+#define READ_STD4B(_dummy_, _size_, _clk_) read_std4b_##_dummy_##_size_##_clk_
+#define READ_FAST(_dummy_, _size_, _clk_) read_fast_##_dummy_##_size_##_clk_
+#define READ_FAST4B(_dummy_, _size_, _clk_) read_fast4b_##_dummy_##_size_##_clk_
+#define READ_DUAL(_dummy_, _size_, _clk_) read_dual_##_dummy_##_size_##_clk_
+#define READ_DUAL4B(_dummy_, _size_, _clk_) read_dual4b_##_dummy_##_size_##_clk_
+#define READ_DUAL_ADDR(_dummy_, _size_, _clk_) \
+        read_dual_addr_##_dummy_##_size_##_clk_
+#define READ_DUAL_ADDR4B(_dummy_, _size_, _clk_) \
+        read_dual_addr4b_##_dummy_##_size_##_clk_
+#define READ_QUAD(_dummy_, _size_, _clk_) read_quad_##_dummy_##_size_##_clk_
+#define READ_QUAD4B(_dummy_, _size_, _clk_) read_quad4b_##_dummy_##_size_##_clk_
+#define READ_QUAD_ADDR(_dummy_, _size_, _clk_) \
+        read_quad_addr_##_dummy_##_size_##_clk_
+#define READ_QUAD_ADDR4B(_dummy_, _size_, _clk_) \
+        read_quad_addr4b_##_dummy_##_size_##_clk_
+#ifdef CONFIG_DTR_MODE_SUPPORT
+#define READ_QUAD_DTR(_dummy_, _size_, _clk_) \
+        read_quad_dtr_##_dummy_##_size_##_clk_
+#define READ_QUAD_DTR4B(_dummy_, _size_, _clk_) \
+        read_quad_dtr4b_##_dummy_##_size_##_clk_
+#define READ_QUAD_DTR4B_WINBOND(_dummy_, _size_, _clk_) \
+        read_quad_dtr4b_winbond_##_dummy_##_size_##_clk_
+#endif
+
+/*****************************************************************************/
+#define WRITE_STD(_dummy_, _size_, _clk_) write_std_##_dummy_##_size_##_clk_
+#define WRITE_STD4B(_dummy_, _size_, _clk_) write_std4b_##_dummy_##_size_##_clk_
+#define WRITE_DUAL(_dummy_, _size_, _clk_) write_dual_##_dummy_##_size_##_clk_
+#define WRITE_DUAL4B(_dummy_, _size_, _clk_) write_dual4b_##_dummy_##_size_##_clk_
+#define WRITE_DUAL_ADDR(_dummy_, _size_, _clk_) \
+        write_dual_addr_##_dummy_##_size_##_clk_
+#define WRITE_DUAL_ADDR4B(_dummy_, _size_, _clk_) \
+        write_dual_addr4b_##_dummy_##_size_##_clk_
+#define WRITE_QUAD(_dummy_, _size_, _clk_) write_quad_##_dummy_##_size_##_clk_
+#define WRITE_QUAD4B(_dummy_, _size_, _clk_) write_quad4b_##_dummy_##_size_##_clk_
+#define WRITE_QUAD_ADDR(_dummy_, _size_, _clk_) \
+        write_quad_addr_##_dummy_##_size_##_clk_
+#define WRITE_QUAD_ADDR4B(_dummy_, _size_, _clk_) \
+        write_quad_addr4b_##_dummy_##_size_##_clk_
+
+/*****************************************************************************/
+#define ERASE_SECTOR_4K(_dummy_, _size_, _clk_) \
+        erase_sector_4k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_4K4B(_dummy_, _size_, _clk_) \
+        erase_sector_4k4b_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_32K(_dummy_, _size_, _clk_) \
+        erase_sector_32k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_32K4B(_dummy_, _size_, _clk_) \
+        erase_sector_32k4b_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_64K(_dummy_, _size_, _clk_) \
+        erase_sector_64k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_64K4B(_dummy_, _size_, _clk_) \
+        erase_sector_64k4b_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_128K(_dummy_, _size_, _clk_) \
+        erase_sector_128k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_128K4B(_dummy_, _size_, _clk_) \
+        erase_sector_128k4b_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_256K(_dummy_, _size_, _clk_) \
+        erase_sector_256k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_256K4B(_dummy_, _size_, _clk_) \
+        erase_sector_256k4b_##_dummy_##_size_##_clk_
+
+/*****************************************************************************/
+#define SPI_CMD_WREN            0x06    /* Write Enable */
+#define SPI_CMD_WRDI            0x04    /* Write Disable */
+
+/*****************************************************************************/
+#define SPI_CMD_WRSR            0x01    /* Write Status Register */
+#define SPI_CMD_WRSR2           0x31    /* Write Status Register-2 */
+#define SPI_CMD_WRSR3           0x11    /* Write Status Register-3 */
+
+#define SPI_CMD_RDSR            0x05    /* Read Status Register */
+#define SPI_CMD_RDSR2           0x35    /* Read Status Register-2 */
+#define SPI_CMD_RDSR3           0x15    /* Read Status Register-3 */
+
+#define SPI_CMD_RDCR            0x35    /* Read Config Register */
+
+#define SPI_CMD_RDID            0x9F    /* Read Identification */
+
+#define SPI_CMD_RD_SFDP         0x5A    /* Read SFDP */
+/*****************************************************************************/
+#define SPI_CMD_GET_FEATURES        0x0F    /* Get Features */
+#define SPI_CMD_SET_FEATURE     0x1F    /* Set Feature */
+
+#define SPI_CMD_PAGE_READ       0x13    /* Page Read to Cache */
+
+#define SPI_CMD_RESET           0xff    /* Reset the device */
+
+/*****************************************************************************/
+#define SPI_CMD_EN4B    0xB7 /* enter 4 bytes mode and set 4 byte bit as '1' */
+#define SPI_CMD_EX4B    0xE9    /* exit 4 bytes mode and clear 4 byte bit */
+
+/*****************************************************************************/
+#define MAX_SPI_OP          8
+
+/*****************************************************************************/
+/* SPI general operation parameter */
+struct spi_op {
+    unsigned char iftype;
+    unsigned char cmd;
+    unsigned char dummy;
+    unsigned int size;
+    unsigned int clock;
+};
+
+struct spi;
+/* SPI interface special operation function hook */
+struct spi_drv {
+    int (*wait_ready)(struct spi *spi);
+    int (*write_enable)(struct spi *spi);
+    int (*qe_enable)(struct spi *spi);
+    int (*bus_prepare)(struct spi *spi, int op);
+    int (*entry_4addr)(struct spi *spi, int en);
+};
+
+/* SPI interface all operation */
+struct spi {
+    char *name;
+    unsigned int cs;
+    unsigned long long chipsize;
+    unsigned long long  erasesize;
+    unsigned int addrcycle;
+
+    struct spi_op read[MAX_SPI_OP];
+    struct spi_op write[MAX_SPI_OP];
+    struct spi_op erase[MAX_SPI_OP];
+
+    void *host;
+
+    struct spi_drv *driver;
+};
+
+#endif /* __SPI_COMMON_H__ */
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/common/Makefile openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/Makefile
--- openharmony/vendor/nxp/imx6ull/driver/mtd/common/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/Makefile	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,36 @@
+# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+include $(LITEOSTOPDIR)/config.mk
+
+MODULE_NAME := mtd_common
+
+LOCAL_SRCS := $(wildcard src/*.c)
+
+include $(MODULE)
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/common/src/common.c openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/src/common.c
--- openharmony/vendor/nxp/imx6ull/driver/mtd/common/src/common.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/src/common.c	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "stdio.h"
+#include "los_typedef.h"
+#include "asm/platform.h"
+#include "los_base.h"
+#include "los_vm_phys.h"
+//#include "asm/dma.h"
+
+extern int snprintf_s(char *str, size_t sizeOfBuffer, size_t n, const char *fmt, ...);
+/*----------------------------------------------------------------------------*/
+/* ulltostr */
+/*----------------------------------------------------------------------------*/
+char *ulltostr(unsigned long long size)
+{
+    int ix;
+    static char buffer[20];
+    unsigned long size_long;
+    char *fmt[] = {"%u", "%uK", "%uM", "%uG", "%uT", "%uP"};
+
+    for (ix = 0; (ix < 5) && !(size & 0x3FF) && size; ix++) {
+        size = (size >> 10);
+    }
+
+    size_long = (unsigned long)size;
+
+    snprintf_s(buffer, sizeof(buffer), sizeof(buffer) - 1, fmt[ix], size_long);
+
+    return buffer;
+}
+
+/*----------------------------------------------------------------------------*/
+/* ffs */
+/*----------------------------------------------------------------------------*/
+int ffs(int x)
+{
+    int r = 1;
+    unsigned int f = (unsigned int)x;
+
+    if (!f) {
+        return 0;
+    }
+
+    if (!(f & 0xffff)) {
+        f >>= 16;
+        r += 16;
+    }
+    if (!(f & 0xff)) {
+        f >>= 8;
+        r += 8;
+    }
+    if (!(f & 0xf)) {
+        f >>= 4;
+        r += 4;
+    }
+    if (!(f & 3)) {
+        f >>= 2;
+        r += 2;
+    }
+    if (!(f & 1)) {
+        r += 1;
+    }
+    return r;
+}
+#if 0
+/*----------------------------------------------------------------------------*/
+/* mtd_dma_cache_inv */
+/*----------------------------------------------------------------------------*/
+void mtd_dma_cache_inv(void *addr, unsigned int size)
+{
+    addr = (void *)(UINTPTR)LOS_PaddrToKVaddr((PADDR_T)(UINTPTR)addr);
+
+    UINTPTR start = (UINTPTR)addr & ~(CACHE_ALIGNED_SIZE - 1);
+    UINTPTR end = (UINTPTR)addr + size;
+
+    end = ALIGN(end, CACHE_ALIGNED_SIZE);
+
+    dma_cache_inv(start, end);
+}
+
+/*----------------------------------------------------------------------------*/
+/* mtd_dma_cache_clean */
+/*----------------------------------------------------------------------------*/
+void mtd_dma_cache_clean(void *addr, unsigned int size)
+{
+    addr = (void *)(UINTPTR)LOS_PaddrToKVaddr((PADDR_T)(UINTPTR)addr);
+    UINTPTR start = (UINTPTR)addr & ~(CACHE_ALIGNED_SIZE - 1);
+    UINTPTR end = (UINTPTR)addr + size;
+
+    end = ALIGN(end, CACHE_ALIGNED_SIZE);
+
+    dma_cache_clean(start, end);
+}
+#endif
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/common/src/mtdblock.c openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/src/mtdblock.c
--- openharmony/vendor/nxp/imx6ull/driver/mtd/common/src/mtdblock.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/src/mtdblock.c	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "fs/fs.h"
+#include "inode/inode.h"
+
+#include "mtd_common.h"
+static int mtdblock_open(FAR struct inode *inode_p)
+{
+    return 0;
+}
+
+static int mtdblock_close(FAR struct inode *inode_p)
+{
+    return 0;
+}
+
+static ssize_t mtdblock_read(FAR struct inode *inode_p, FAR unsigned char *buffer,
+                             unsigned long long start_sector, unsigned int nsectors)
+{
+    return 0;
+}
+
+static ssize_t mtdblock_write(FAR struct inode *inode_p, FAR const unsigned char *buffer,
+                              unsigned long long start_sector, unsigned int nsectors)
+{
+    return 0;
+}
+
+static int mtdblock_geometry(FAR struct inode *inode_p, FAR struct geometry *geometry_p)
+{
+    return 0;
+}
+
+static int mtdblock_ioctl(FAR struct inode *inode_p, int cmd, unsigned long arg)
+{
+    return 0;
+}
+
+const struct block_operations g_dev_nand_ops = {
+    .open       = mtdblock_open,
+    .close      = mtdblock_close,
+    .read       = mtdblock_read,
+    .write      = mtdblock_write,
+    .geometry   = mtdblock_geometry,
+    .ioctl      = mtdblock_ioctl,
+    .unlink     = NULL
+};
+
+const struct block_operations g_dev_spinor_ops = {
+    .open       = mtdblock_open,
+    .close      = mtdblock_close,
+    .read       = mtdblock_read,
+    .write      = mtdblock_write,
+    .geometry   = mtdblock_geometry,
+    .ioctl      = mtdblock_ioctl,
+    .unlink     = NULL
+};
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/common/src/mtdchar.c openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/src/mtdchar.c
--- openharmony/vendor/nxp/imx6ull/driver/mtd/common/src/mtdchar.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/src/mtdchar.c	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,235 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_config.h"
+#if defined(LOSCFG_FS_YAFFS) || defined(LOSCFG_FS_JFFS)
+
+#include "fs/fs.h"
+#include "stdio.h"
+#include "string.h"
+#include "errno.h"
+
+#include "los_mux.h"
+#include "mtd_dev.h"
+
+#include "mtd_partition.h"
+#include "user_copy.h"
+
+/*
+ * open device interface
+ */
+static int mtdchar_open(FAR struct file *filep)
+{
+    struct inode *inode_p = filep->f_inode;
+    mtd_partition *partition = (mtd_partition *)(inode_p->i_private);
+
+    if (partition->user_num != 0) { // be opened
+        return -EBUSY;
+    }
+
+    struct MtdDev *mtd = (struct MtdDev *)(partition->mtd_info);
+    size_t block_size = mtd->eraseSize;
+
+    (void)LOS_MuxLock(&partition->lock, LOS_WAIT_FOREVER);
+
+    partition->user_num = 1;
+    filep->f_pos = partition->start_block * block_size;
+
+    (void)LOS_MuxUnlock(&partition->lock);
+
+    return ENOERR;
+}
+
+/*
+ * close device interface
+ */
+static int mtdchar_close(FAR struct file *filep)
+{
+    struct inode *inode_p = filep->f_inode;
+    mtd_partition *partition = (mtd_partition *)(inode_p->i_private);
+
+    (void)LOS_MuxLock(&partition->lock, LOS_WAIT_FOREVER);
+
+    partition->user_num = 0;
+
+    (void)LOS_MuxUnlock(&partition->lock);
+
+    return ENOERR;
+}
+
+/*
+ * read device interface
+ */
+static ssize_t mtdchar_read(FAR struct file *filep, FAR char *buffer, size_t buflen)
+{
+    struct inode *inode_p = filep->f_inode;
+    mtd_partition *partition = (mtd_partition *)(inode_p->i_private);
+
+    (void)LOS_MuxLock(&partition->lock, LOS_WAIT_FOREVER);
+
+    struct MtdDev *mtd = (struct MtdDev *)(partition->mtd_info);
+    uint64_t block_size = mtd->eraseSize;
+    uint64_t start_addr = partition->start_block * block_size;
+    uint64_t end_addr = (partition->end_block + 1) * block_size;
+
+    uint64_t retlen;
+    ssize_t ret = 0;
+
+
+    if (!buflen) {
+        ret = 0;
+        goto out1;
+    }
+
+    retlen = mtd->read(mtd, start_addr, end_addr - start_addr, buffer);
+
+    if (retlen < 0) {
+        goto out1;
+    }
+
+    filep->f_pos += retlen;
+
+    ret = (ssize_t)retlen;
+
+out1:
+    (void)LOS_MuxUnlock(&partition->lock);
+    return ret;
+}
+
+/*
+ * write device interface
+ */
+static ssize_t mtdchar_write(FAR struct file *filep, FAR const char *buffer, size_t buflen)
+{
+    struct inode *inode_p = filep->f_inode;
+    mtd_partition *partition = (mtd_partition *)(inode_p->i_private);
+
+    (void)LOS_MuxLock(&partition->lock, LOS_WAIT_FOREVER);
+
+    struct MtdDev *mtd = (struct MtdDev *)(partition->mtd_info);
+    uint64_t block_size = mtd->eraseSize;
+    uint64_t start_addr = partition->start_block * block_size;
+    uint64_t end_addr = (partition->end_block + 1) * block_size;
+    uint64_t retlen;
+    int ret = 0;
+
+    if (!buflen) {
+        ret = 0;
+        goto out1;
+    }
+
+    retlen = mtd->write(mtd, start_addr, end_addr - start_addr, buffer);
+
+    if (retlen < 0) {
+        goto out1;
+    }
+
+    filep->f_pos += retlen;
+
+    ret = (ssize_t)retlen;
+
+out1:
+    (void)LOS_MuxUnlock(&partition->lock);
+    return ret;
+}
+
+/*
+ * lseek device interface
+ */
+static off_t mtdchar_lseek(FAR struct file *filep, off_t offset, int whence)
+{
+    struct inode *inode_p = filep->f_inode;
+    mtd_partition *partition = (mtd_partition *)(inode_p->i_private);
+
+    (void)LOS_MuxLock(&partition->lock, LOS_WAIT_FOREVER);
+
+    struct MtdDev *mtd = (struct MtdDev *)(partition->mtd_info);
+    size_t block_size = mtd->eraseSize;
+    size_t end_addr = (partition->end_block + 1) * block_size;
+    size_t start_addr = partition->start_block * block_size;
+
+    switch (whence) {
+        case SEEK_SET:
+            if (offset >= 0 && (size_t)offset < end_addr - start_addr) {
+                filep->f_pos = start_addr + offset;
+                goto out1;
+            } else {
+                goto err1;
+            }
+
+        case SEEK_CUR:
+            if (offset + (size_t)filep->f_pos >= start_addr &&
+                    (size_t)(offset + filep->f_pos) < end_addr) {
+                filep->f_pos += offset;
+                goto out1;
+            } else {
+                goto err1;
+            }
+
+        case SEEK_END:
+            if (offset < 0 && offset + end_addr >= start_addr) {
+                filep->f_pos = (off_t)(offset + end_addr);
+                goto out1;
+            } else {
+                goto err1;
+            }
+
+        default:
+            goto err1;
+    }
+err1:
+    (void)LOS_MuxUnlock(&partition->lock);
+    return -EINVAL;
+out1:
+    (void)LOS_MuxUnlock(&partition->lock);
+    return filep->f_pos;
+}
+
+static ssize_t mtdchar_map(FAR struct file* filep, FAR LosVmMapRegion *region)
+{
+    PRINTK("%s %d, mmap is not support\n", __FUNCTION__, __LINE__);
+    return 0;
+}
+
+const struct file_operations_vfs g_mtdchar_fops = {
+    .open   =   mtdchar_open,
+    .close  =   mtdchar_close,
+    .read   =   mtdchar_read,
+    .write  =   mtdchar_write,
+    .seek   =   mtdchar_lseek,
+    .mmap   =   mtdchar_map,
+#ifndef CONFIG_DISABLE_POLL
+    .poll   =   NULL,
+#endif
+    .unlink =   NULL,
+};
+
+#endif
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/common/src/mtd_list.c openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/src/mtd_list.c
--- openharmony/vendor/nxp/imx6ull/driver/mtd/common/src/mtd_list.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/common/src/mtd_list.c	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,114 @@
+#include "stdio.h"
+#include "stdlib.h"
+#include "string.h"
+
+typedef struct Node {
+    char *type;           /* flash type */
+    int status;           /* flash status */
+    struct MtdDev *mtd; /* mtd_info struct */
+    struct Node *next;    /* next mtd_info struct */
+} Lnode, *linklist;
+
+linklist head;
+#if 0 
+struct MtdDev *GetMtd(const char *type)
+{
+    linklist p;
+    if ((!type) || (!head)) {
+        return NULL;
+    }
+    p = head->next;
+    while (p) {
+        if (strcmp(type, p->type) == 0) {
+            p->status++;
+            return p->mtd;
+        }
+        p = p->next;
+    }
+    return NULL;
+}
+#endif
+int get_mtd_info(const char *type)
+{
+    linklist p;
+    if ((!type) || (!head)) {
+        return -1;
+    }
+    p = head->next;
+    while (p) {
+        if (strcmp(type, p->type) == 0) {
+            return 0;
+        }
+        p = p->next;
+    }
+    return -1;
+}
+int FreeMtd(struct MtdDev *mtd)
+{
+    linklist p;
+    if ((!mtd) || (!head)) {
+        return -1;
+    }
+    p = head->next;
+    while (p) {
+        if (p->mtd == mtd) {
+            p->status--;
+            return 0;
+        }
+        p = p->next;
+    }
+    return -1;
+}
+
+int del_mtd_list(struct MtdDev *mtd)
+{
+    linklist p, q;
+    if ((!mtd) || (!head)) {
+        return -1;
+    }
+    p = head->next;
+    q = head;
+    while (p) {
+        if (p->mtd == mtd) {
+            if (!p->status) {
+                q->next = p->next;
+                free(p);
+                return 0;
+            } else {
+                return -1;
+            }
+        }
+        q = p;
+        p = p->next;
+    }
+    return -1;
+}
+void add_mtd_list(char *type, struct MtdDev *mtd)
+{
+    linklist p, q;
+    if ((!mtd) || (!type) || (!head)) {
+        return;
+    }
+    p = head->next;
+    q = (linklist)zalloc(sizeof(Lnode));
+    if (!q) {
+        return;
+    }
+    q->type = type;
+    q->mtd = mtd;
+    q->status = 0;
+    head->next = q;
+    q->next = p;
+}
+int mtd_init_list(void)
+{
+    head = (linklist)zalloc(sizeof(Lnode));
+    if (!head) {
+        return -1;
+    }
+    head->next = NULL;
+    head->mtd = NULL;
+    head->type = NULL;
+    head->status = 0;
+    return 0;
+}
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/BUILD.gn openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/BUILD.gn
--- openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/BUILD.gn	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/BUILD.gn	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,44 @@
+# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("drivers_mtd_spinor") {
+
+    sources = [
+        "src/common/spinor.c",
+        "src/common/spinor_common.c",
+        "src/common/spinor_ids.c",
+        "src/common/spinor_scan.c",
+    ]
+
+    include_dirs = [
+        "../common/include",
+        "src/common",
+        "include",
+    ]
+}
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/include/spinor.h openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/include/spinor.h
--- openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/include/spinor.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/include/spinor.h	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SPINOR_H__
+#define __SPINOR_H__
+
+// #include "linux/mtd/mtd.h"
+
+struct erase_info {
+    int scrub;
+    struct erase_info *next;
+    unsigned char state;
+    unsigned long priv;
+    void (*callback) (struct erase_info *self);
+    unsigned int cell;
+    unsigned int dev;
+    unsigned long retries;
+    unsigned long time;
+    uint64_t fail_addr;
+    uint64_t len;
+    uint64_t addr;
+    struct MtdDev *mtd;
+};
+
+// int spinor_init(void);
+// void spinor_register(struct mtd_info *mtd);
+
+#endif
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/Kconfig openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/Kconfig
--- openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/Kconfig	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,29 @@
+config LOSCFG_DRIVERS_MTD_SPI_NOR
+    bool "Enable MTD spi_nor flash"
+    default y
+    depends on LOSCFG_DRIVERS_MTD
+    help
+      Answer Y to support spi_nor flash.
+choice
+    depends on  LOSCFG_DRIVERS_MTD_SPI_NOR
+    prompt "SpiNorFlash Chips"
+    default LOSCFG_DRIVERS_MTD_SPI_NOR_HISFC350
+
+config LOSCFG_DRIVERS_MTD_SPI_NOR_HISFC350
+    depends on LOSCFG_PLATFORM_HI3516A || LOSCFG_PLATFORM_HI3731
+    bool "Enable hisfc350"
+    help
+      Answer Y to support hisfc350.
+
+config LOSCFG_DRIVERS_MTD_SPI_NOR_HIFMC100
+    depends on LOSCFG_PLATFORM_HI3518EV200 || LOSCFG_PLATFORM_HI3519 || LOSCFG_PLATFORM_HI3519V101 || LOSCFG_PLATFORM_HI3559  || LOSCFG_PLATFORM_HI3516CV300 || LOSCFG_PLATFORM_HI3559AV100ES || LOSCFG_PLATFORM_HI3559AV100 || LOSCFG_PLATFORM_HI3516CV500 || LOSCFG_PLATFORM_HI3516DV300 || LOSCFG_PLATFORM_HI3516EV200 || LOSCFG_PLATFORM_HI3516EV300 || LOSCFG_PLATFORM_HI3518EV300 || LOSCFG_PLATFORM_HI3556V200 || LOSCFG_PLATFORM_HI3559V200
+    bool "Enable hifmc100"
+    help
+      Answer Y to support hifmc100.
+	  
+config LOSCFG_DRIVERS_MTD_SPI_NOR_SUNXI
+    depends on LOSCFG_PLATFORM_SUN8I
+    bool "Enable spinor sunxi"
+    help
+      Answer Y to support spinor sunxi.	 
+endchoice
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/Makefile openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/Makefile
--- openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/Makefile	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,43 @@
+# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+include $(LITEOSTOPDIR)/config.mk
+
+MODULE_NAME := spinor_flash
+
+SRCS_HOST = $(wildcard src/$(NOR_DRIVER_DIR)/*.c)
+
+SRCS_COMMON_TMP0 = $(wildcard src/common/*.c)
+SRCS_COMMON = $(subst $(SRCS_COMMON_DEL0),,$(SRCS_COMMON_TMP0))
+LOCAL_SRCS := $(SRCS_COMMON) $(SRCS_HOST)
+
+LOCAL_FLAGS := 	-I$(LITEOSTOPDIR)/../../vendor/allwinner/sun8i/driver/mtd/common/include \
+				-I$(LITEOSTOPDIR)/../../vendor/allwinner/sun8i/driver/mtd/spi_nor/include
+
+include $(MODULE)
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/host_common.h openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/host_common.h
--- openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/host_common.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/host_common.h	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __HOST_COMMON_H__
+#define __HOST_COMMON_H__
+
+#include "sys/types.h"
+#include "los_mux.h"
+
+#include "mtd_common.h"
+#include "spinor_common.h"
+#include "spi_common.h"
+
+#define reg_read(_host, _reg) \
+        mtd_readl((UINTPTR)((char *)_host->regbase + (_reg)))
+
+#define reg_write(_host, _value, _reg) \
+        mtd_writel((unsigned)(_value), (UINTPTR)((char *)_host->regbase + (_reg)))
+
+#define get_host(_host) \
+        if(LOS_OK != LOS_MuxLock(&(_host)->lock, LOS_WAIT_FOREVER)) \
+            return -1;
+
+#define put_host(_host) \
+        if(LOS_OK != LOS_MuxUnlock(&(_host)->lock)) \
+            return -1;
+struct spinor_host {
+    struct spinor_info *spinor;
+
+    char     *regbase;
+    char     *membase;
+
+    void (*set_system_clock)(unsigned clock, int clk_en);
+    void (*set_host_addr_mode)(struct spinor_host *host, int enable);
+
+    char *buffer;
+    char *dma_buffer;
+    char *dma_buffer_bak;
+
+    int num_chip;
+    struct spi spi[1];
+
+    LosMux lock;
+};
+
+#endif /* End of __HOST_COMMON_H__ */
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/ramdisk.c.bak2 openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/ramdisk.c.bak2
--- openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/ramdisk.c.bak2	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/ramdisk.c.bak2	2020-10-31 00:27:40.760668270 +0800
@@ -0,0 +1,59 @@
+
+
+static int sector_size = 512;
+static int ramdisk_base =  DDR_RAMFS_VBASE;
+static int ramdisk_size =  DDR_RAMFS_SIZE;
+
+
+static int	ramdisk_open(FAR struct inode *inode)
+{
+	return 0;
+}
+
+static int	ramdisk_close(FAR struct inode *inode)
+{
+	return 0;
+}
+
+ssize_t ramdisk_read(FAR struct inode *inode, FAR unsigned char *buffer,
+		  unsigned long long start_sector, unsigned int nsectors)
+{
+	const char *addr = (const char *)(ramdisk_base + start_sector * sector_size);
+	memcpy(buffer, addr, nsectors * sector_size);
+	return nsectors;
+}
+		  
+ssize_t ramdisk_write(FAR struct inode *inode, FAR const unsigned char *buffer,
+		  unsigned long long start_sector, unsigned int nsectors)
+{
+	char *addr = (const char *)(ramdisk_base + start_sector * sector_size;)
+	memcpy(addr, buffer, nsectors * sector_size);
+	return nsectors;
+}
+
+		  
+static int 	ramdisk_geometry(FAR struct inode *inode, FAR struct geometry *geometry)
+{
+	geometry->geo_available    = true;	 /* true: The device is available */
+	geometry->geo_writeenabled = true; /* true: It is okay to write to this device */
+	geometry->geo_nsectors     = ramdisk_size / sector_size;	 /* Number of sectors on the device */
+	geometry->geo_sectorsize   = sector_size;	 /* Size of one sector */
+	return 0;
+}
+
+static int 	ramdisk_ioctl(FAR struct inode *inode, int cmd, unsigned long arg)
+{
+	return 0;
+}
+
+static int 	ramdisk_unlink(FAR struct inode *inode)
+{
+	return 0;
+}
+
+
+struct block_operations g_ramdisk_opr = {
+};
+
+
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/ramdisk.c.ok openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/ramdisk.c.ok
--- openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/ramdisk.c.ok	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/ramdisk.c.ok	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "errno.h"
+#include "fs/fs.h"
+#include "stdio.h"
+#include "stdlib.h"
+#include "spinor.h"
+#include "fs/fs.h"
+#include "inode/inode.h"
+
+static int sector_size = 512;
+static unsigned int ramdisk_start_addr = DDR_RAMFS_VBASE;
+static unsigned int ramdisk_size       = DDR_RAMFS_SIZE;
+
+static int ramdisk_open(FAR struct inode *inode_p)
+{
+    return 0;
+}
+
+static int ramdisk_close(FAR struct inode *inode_p)
+{
+    return 0;
+}
+
+static ssize_t ramdisk_read(FAR struct inode *inode_p, FAR unsigned char *buffer,
+                             unsigned long long start_sector, unsigned int nsectors)
+{
+	unsigned char * addr = (unsigned char *)(ramdisk_start_addr + sector_size * start_sector);
+	memcpy(buffer, addr, nsectors * sector_size);
+    return nsectors;
+}
+
+static ssize_t ramdisk_write(FAR struct inode *inode_p, FAR const unsigned char *buffer,
+                              unsigned long long start_sector, unsigned int nsectors)
+{
+	unsigned char * addr = (unsigned char *)(ramdisk_start_addr + sector_size * start_sector);
+	memcpy(addr, buffer, nsectors * sector_size);
+    return nsectors;
+}
+
+static int ramdisk_geometry(FAR struct inode *inode_p, FAR struct geometry *geometry_p)
+{
+	geometry_p->geo_available    = true;	 /* true: The device is available */
+	//bool   geo_mediachanged; /* true: The media has changed since last query */
+	geometry_p->geo_writeenabled = true; /* true: It is okay to write to this device */
+	geometry_p->geo_nsectors     = ramdisk_size / sector_size;	 /* Number of sectors on the device */
+	geometry_p->geo_sectorsize   = sector_size;	 /* Size of one sector */
+    return 0;
+}
+
+static int ramdisk_ioctl(FAR struct inode *inode_p, int cmd, unsigned long arg)
+{
+    return 0;
+}
+
+const struct block_operations g_dev_ramdisk_ops = {
+    .open       = ramdisk_open,
+    .close      = ramdisk_close,
+    .read       = ramdisk_read,
+    .write      = ramdisk_write,
+    .geometry   = ramdisk_geometry,
+    .ioctl      = ramdisk_ioctl,
+    .unlink     = NULL
+};
+
+
+extern INT32 los_alloc_diskid_byname(const CHAR *diskName);
+extern INT32 los_disk_init(const CHAR *diskName, const struct block_operations *bops,
+                    VOID *priv, INT32 diskID, VOID *info);
+
+int my_ramdisk_init(void)
+{
+#if 1	
+	char *node_name = "/dev/ramdisk";
+
+	INT32 diskId = los_alloc_diskid_byname(node_name);
+	if (diskId < 0) {
+		PRINT_ERR("Failed to alloc disk %s!\n", node_name);
+		return -1;
+	}
+	if (los_disk_init(node_name, &g_dev_ramdisk_ops, NULL, diskId, NULL) != ENOERR) {
+		PRINT_ERR("Failed to init my ramdisk disk!\n");
+		return -1;
+	}
+#else
+	int ret = register_blockdriver("/dev/ramdisk", &g_dev_ramdisk_ops, 0755, NULL);
+	if (ret)
+		PRINT_ERR("Failed to iregister_blockdriver!\n");
+#endif
+	return 0;
+}
+
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/spinor.c openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/spinor.c
--- openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/spinor.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/spinor.c	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,162 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "errno.h"
+#include "fs/fs.h"
+#include "stdio.h"
+#include "stdlib.h"
+#include "spinor.h"
+#include "mtd_common.h"
+#include "spinor_common.h"
+#include "mtd_dev.h"
+
+struct MtdDev spinor_mtd;
+void AddMtdList(char *type, struct MtdDev *mtd);
+
+extern int get_mtd_info(const char *type);
+
+void* GetMtd(const char *type)
+{
+	(void)type;
+	return &spinor_mtd;
+}
+
+static int ramnor_erase(struct MtdDev *mtd, UINT64 start, UINT64 len, UINT64 *failAddr)
+{
+	unsigned char * rambase = (unsigned char *)mtd->priv;
+
+    uint32_t offset = start;
+    uint32_t length = len;
+
+    if (offset + length > mtd->size) {
+        return -EINVAL;
+    }
+
+    if (offset & (mtd->eraseSize - 1)) {
+        return -EINVAL;
+    }
+
+    if (length & (mtd->eraseSize - 1)) {
+        return -EINVAL;
+    }
+
+	memset((void *)(rambase+offset), 0xff, length);
+    return 0;
+}
+
+static int ramnor_write(struct MtdDev *mtd, UINT64 start, UINT64 len, const char *buf)
+{
+	unsigned char * rambase = (unsigned char *)mtd->priv;
+    uint32_t offset = start;
+    uint32_t length = len;
+
+    if ((offset + length) > mtd->size) {
+        return -EINVAL;
+    }
+
+    if (!length) {
+        return 0;
+    }
+
+    memcpy((void *)(rambase+offset), buf, length);
+	return len;
+}
+
+static int ramnor_read(struct MtdDev *mtd, UINT64 start, UINT64 len, char *buf)
+{
+	unsigned char * rambase = (unsigned char *)mtd->priv;
+    uint32_t offset = start;
+    uint32_t length = len;
+	//int i;
+
+    if ((offset + length) > mtd->size) {
+		PRINT_RELEASE("%s %s %d, memcpy: 0x%x, 0x%x, 0x%x\n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)buf, (unsigned int)(rambase+start), (unsigned int)len); 	
+        return -EINVAL;
+    }
+
+    if (!length) {
+		PRINT_RELEASE("%s %s %d, memcpy: 0x%x, 0x%x, 0x%x\n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)buf, (unsigned int)(rambase+start), (unsigned int)len); 	
+        return 0;
+    }
+
+	//PRINT_RELEASE("%s %s %d, memcpy: 0x%x, 0x%x, 0x%x\n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)buf, (unsigned int)(rambase+start), (unsigned int)len);		
+
+    //return spinor->read(spinor, (uint32_t)from, (uint32_t)len, buf);
+    memcpy(buf, (void *)(rambase+offset), length);
+
+	return len;
+}
+
+
+void ramnor_register(struct MtdDev *mtd)
+{
+    //mtd->priv = (void *)DDR_RAMFS_VBASE;
+
+    //mtd->size = DDR_RAMFS_SIZE;
+    mtd->eraseSize = 0x10000;
+
+    mtd->type = MTD_NORFLASH;
+
+    mtd->erase = ramnor_erase;
+    mtd->read = ramnor_read;
+    mtd->write = ramnor_write;
+
+}
+
+/*---------------------------------------------------------------------------*/
+/* spinor_node_register- spinor node register */
+/*---------------------------------------------------------------------------*/
+int spinor_node_register(struct MtdDev *mtd)
+{
+    int ret = 0;
+    ret = register_blockdriver("/dev/spinor", &g_dev_spinor_ops, 0755, mtd);
+    if (ret) {
+        ERR_MSG("register spinor err %d!\n", ret);
+    }
+
+    return ret;
+}
+
+int spinor_init(void)
+{
+    spinor_mtd.priv = (void *)DDR_RAMFS_VBASE;
+	spinor_mtd.size = DDR_RAMFS_SIZE;
+
+    /* ramnor register */
+    ramnor_register(&spinor_mtd);
+	PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);		
+//    AddMtdList("spinor", &spinor_mtd);
+    if (spinor_node_register(&spinor_mtd)) {
+        PRINT_RELEASE("spinor node register fail!\n");
+        return -1;
+    }
+    return get_mtd_info("spinor") ;
+}
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/spinor_common.h openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/spinor_common.h
--- openharmony/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/spinor_common.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/mtd/spi_nor/src/common/spinor_common.h	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SPINOR_COMMON_H__
+#define __SPINOR_COMMON_H__
+
+#include "spinor_common.h"
+
+/*****************************************************************************/
+#define SPI_NOR_SR_WIP_MASK             (1 << 0)
+#define SPI_NOR_SR_LEN                  1    /* Status Register length(byte) */
+
+#define SPI_NOR_CR_LEN                  1    /* Config Register length(byte) */
+#define SPI_NOR_CR_SHIFT                8    /* Config Register shift(bit) */
+#define SPI_NOR_CR_4BYTE_SHIFT          5
+#define SPI_NOR_CR_4BYTE_MASK           (1 << SPI_NOR_CR_4BYTE_SHIFT)
+#define SPI_NOR_GET_4BYTE_BY_CR(cr)     (((cr) & SPI_NOR_CR_4BYTE_MASK) \
+                                            >> SPI_NOR_CR_4BYTE_SHIFT)
+#define SPI_NOR_CR_QE_SHIFT             1
+#define SPI_NOR_CR_QE_MASK              (1 << SPI_NOR_CR_QE_SHIFT)
+#define SPI_NOR_GET_QE_BY_CR(cr)        (((cr) & SPI_NOR_CR_QE_MASK) \
+                                        >> SPI_NOR_CR_QE_SHIFT)
+
+#define SPI_4BYTE_ADDR_LEN              (4)
+#define SPI_3BYTE_ADDR_LEN              (3)
+
+#define SPI_CMD_SR_WIP                  1    /* Write in Progress */
+#define SPI_CMD_SR_WEL                  2    /* Write Enable Latch */
+
+#define SPI_CMD_SR_QE                   (1 << 9)    /* quad enable */
+#define SPI_CMD_SR_XQE                  (0 << 9)    /* quad disable */
+
+#define SPI_NOR_SR_LEN                  1 /* Status Register length */
+#define SPI_NOR_CR_LEN                  1 /* Config Register length */
+
+#define SPI_NOR_MAX_ID_LEN 8
+/*---------------------------------------------------------------------------*/
+/* struct spinor_dev_info - spinor device information structure */
+/*---------------------------------------------------------------------------*/
+struct spinor_dev_info {
+    char *name;/* Human-readable label */
+    union {
+        char id[SPI_NOR_MAX_ID_LEN];/* The full ID array */
+        struct {
+            uint8_t mfr_id;/* id[0]: Manufacturer ID */
+            uint8_t dev_id;/* id[1]: Device ID */
+        };
+    };
+    uint16_t id_len;/* The valid length of ID */
+
+    uint32_t blocksize;/* Size of an erase block */
+
+    uint64_t chipsize;/* Total size of the device */
+
+    void *priv;
+};
+
+/*---------------------------------------------------------------------------*/
+/* struct spinor_info - spinor various interface and information structure */
+/*---------------------------------------------------------------------------*/
+struct spinor_info {
+    struct spinor_dev_info dev;
+    int numchips;
+
+    void *priv;
+
+    int (*erase)(struct spinor_info *spinor, uint32_t addr, uint32_t len);
+    int (*write)(struct spinor_info *spinor,
+                 uint32_t to, uint32_t len, const char *buf);
+    int (*read)(struct spinor_info *spinor,
+                uint32_t from, uint32_t len, const char *buf);
+    void (*read_id)(struct spinor_info *spinor, char *id);
+    void (*ids_probe)(struct spinor_info *spinor);
+    int (*resume)(struct spinor_info *spinor);
+
+    uint8_t cur_cs;
+};
+
+#endif /* End of __SPINOR_COMMON_H__ */
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/touch/Makefile openharmony_100ask/vendor/nxp/imx6ull/driver/touch/Makefile
--- openharmony/vendor/nxp/imx6ull/driver/touch/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/touch/Makefile	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,17 @@
+include $(LITEOSTOPDIR)/config.mk
+include $(LITEOSTOPDIR)/../../drivers/hdf/lite/lite.mk
+
+MODULE_NAME := $(notdir $(shell pwd))
+
+LOCAL_SRCS :=  touch_gt9xx.c
+
+LOCAL_FLAGS :=  -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/osal \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/core \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/ability/sbuf/include \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/utils/include \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/lite/include/host
+
+LOCAL_CFLAGS += -fstack-protector-strong
+
+include $(HDF_DRIVER)
+
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/touch/touch_gt9xx.c openharmony_100ask/vendor/nxp/imx6ull/driver/touch/touch_gt9xx.c
--- openharmony/vendor/nxp/imx6ull/driver/touch/touch_gt9xx.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/touch/touch_gt9xx.c	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,666 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: ft6236 touch driver implement.
+ * Author: zhaihaipeng
+ * Create: 2020-07-25
+ */
+
+#include <stdlib.h>
+#include <asm/io.h>
+#include <fs/fs.h>
+#include <fs_poll_pri.h>
+#include <los_queue.h>
+#include <poll.h>
+#include <user_copy.h>
+#include <securec.h>
+#include "gpio_if.h"
+#include "hdf_device_desc.h"
+#include "hdf_log.h"
+#include "osal_irq.h"
+#include "osal_mem.h"
+#include "osal_time.h"
+#include "touch_gt9xx.h"
+
+
+/* device node path and access right */
+#define TOUCH_DEVICE "/dev/input/event1"
+#define TOUCH_DEVICE_MODE 0666
+/* task config */
+#define TASK_PRIO_LEVEL_TWO 2
+#define TASK_SIZE 0x6000
+#define TOUCH_EVENT_DOWN       0
+#define TOUCH_EVENT_UP         1
+#define TOUCH_EVENT_CONTACT    2
+
+/* the macro defines of GT911 */
+#define ONE_BYTE_MASK         0xFF
+#define ONE_BYTE_OFFSET       8
+#define GT_EVENT_UP           0x80
+#define GT_EVENT_INVALID      0
+#define GT_EVENT_SIZE         6
+#define GT_X_LOW              0
+#define GT_X_HIGH             1
+#define GT_Y_LOW              2
+#define GT_Y_HIGH             3
+#define GT_PRESSURE_LOW       4
+#define GT_PRESSURE_HIGH      5
+#define GT_ADDR_LEN           2
+#define GT_BUF_STATE_ADDR     0x814E
+#define GT_X_LOW_BYTE_BASE    0x8150
+#define GT_FINGER_NUM_MASK    0x03
+#define GT_CLEAN_DATA_LEN     3
+#define GT_REG_HIGH_POS       0
+#define GT_REG_LOW_POS        1
+#define GT_CLEAN_POS          2
+#define GT_CLEAN_FLAG         0x0
+/* Config info macro of GT911 */
+#define GT_CFG_INFO_ADDR      0x8140
+#define GT_CFG_INFO_LEN       10
+#define GT_PROD_ID_1ST        0
+#define GT_PROD_ID_2ND        1
+#define GT_PROD_ID_3RD        2
+#define GT_PROD_ID_4TH        3
+#define GT_FW_VER_LOW         4
+#define GT_FW_VER_HIGH        5
+#define GT_SOLU_X_LOW         6
+#define GT_SOLU_X_HIGH        7
+#define GT_SOLU_Y_LOW         8
+#define GT_SOLU_Y_HIGH        9
+
+/* the sleep time for task */
+#define TASK_SLEEP_MS 100
+#define EVENT_SYNC 0x1
+
+static TouchCoreData *g_coreData;
+static InputEventData g_touchEventData;
+static EVENT_CB_S g_touchEventIrq;
+
+uint32_t IrqHandle(uint32_t irqId, void *dev);
+
+
+/* start for imx6ull */
+
+/*
+ * int pin: GPIO1_IO05
+ * rst pin: SNVS_TAMPER2/GPIO5_IO02
+ */
+
+#define GT9XX_INT_NUM  (66 + 32)
+
+/** GPIO - Register Layout Typedef */
+typedef struct {
+  volatile uint32_t DR;                                /**< GPIO data register, offset: 0x0 */
+  volatile uint32_t GDIR;                              /**< GPIO direction register, offset: 0x4 */
+  volatile  uint32_t PSR;                               /**< GPIO pad status register, offset: 0x8 */
+  volatile uint32_t ICR1;                              /**< GPIO interrupt configuration register1, offset: 0xC */
+  volatile uint32_t ICR2;                              /**< GPIO interrupt configuration register2, offset: 0x10 */
+  volatile uint32_t IMR;                               /**< GPIO interrupt mask register, offset: 0x14 */
+  volatile uint32_t ISR;                               /**< GPIO interrupt status register, offset: 0x18 */
+  volatile uint32_t EDGE_SEL;                          /**< GPIO edge select register, offset: 0x1C */
+} GPIO_Type;
+
+
+static volatile unsigned int *CCM_CCGR1                              ;
+static volatile unsigned int *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER2;
+static volatile unsigned int *IOMUXC_GPIO1_IO05_GPIO1_IO05           ;
+static volatile unsigned int *IOMUXC_PAD_CTL_GPIO1_IO05              ;
+static GPIO_Type *gpio1;
+static GPIO_Type *gpio5;
+
+static void gt911_io_init(void)
+{
+	unsigned int val;
+	
+	CCM_CCGR1                               = (volatile unsigned int *)IO_DEVICE_ADDR(0x20C406C);
+	IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER2 = (volatile unsigned int *)IO_DEVICE_ADDR(0x2290010);
+	IOMUXC_GPIO1_IO05_GPIO1_IO05            = (volatile unsigned int *)IO_DEVICE_ADDR(0x20E0070);
+	IOMUXC_PAD_CTL_GPIO1_IO05               = (volatile unsigned int *)IO_DEVICE_ADDR(0x20E02FC);	
+
+	gpio1 = (GPIO_Type *)IO_DEVICE_ADDR(0x0209C000);
+	gpio5 = (GPIO_Type *)IO_DEVICE_ADDR(0x020AC000);
+
+	/* GPIO5和GPIO1都是使用CCM_CCGR1 */
+	/* 使能GPIO5 GPIO1
+	 * set CCM to enable GPIO5 GPIO1
+	 * CCM_CCGR1[CG15] 0x20C406C
+	 * bit[31:30] = 0b11 || bit[27:26] = 0b11 = 0b110011 = 0d51
+	 */
+	*CCM_CCGR1 |= (51<<26);
+	
+	/* 设置GPIO5_IO02用于GPIO 同理设置GPIO1_IO05
+	 * set IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER2
+	 *      to configure GPIO5_IO02 as GPIO
+	 * IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER2  0x2290010
+	 * bit[3:0] = 0b0101 alt5
+	 */
+	val = *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER2;
+	val &= ~(0xf);
+	val |= (5);
+	*IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER2 = val;
+	
+	val = *IOMUXC_GPIO1_IO05_GPIO1_IO05;
+	val &= ~(0xf);
+	val |= (5);
+	*IOMUXC_GPIO1_IO05_GPIO1_IO05 = val;
+
+	gpio5->GDIR |= (1<<2);
+	gpio1->GDIR |= (1<<5);
+}
+
+void gt9xx_irq_init(TouchCoreData *cd)
+{
+	int32_t ret;
+
+	/* if set 0, masked */
+	gpio1->IMR &= ~(1 << 1);
+	
+	/* if set detects any edge on the corresponding input signal*/
+	gpio1->EDGE_SEL &= ~(1 << 5);
+
+	/* falling-edge */
+	gpio1->ICR1 |= (3<<10);
+	
+	/* clear interrupt first to avoid unexpected event */
+	gpio1->ISR |= (1 << 5);
+
+	/* IrqHandle */
+	ret = OsalRegisterIrq(cd->intGpioNum, 0, IrqHandle, "gt9xx_irq", NULL);
+
+	if (ret)
+	{
+		HDF_LOGE("%s %s %d, gt9xx_irq_init err\n", __FILE__, __FUNCTION__, __LINE__);
+	}
+}
+
+static int32_t gt9xx_irq_enable(uint32_t irq)
+{
+	(void)irq;
+	
+	/* if set 1, unmasked, Interrupt n is enabled */
+	gpio1->IMR |= (1 << 5);
+
+	return HDF_SUCCESS;
+}
+
+int32_t gt9xx_irq_disable(uint32_t irq)
+{
+	(void)irq;
+	
+	/* if set 0, masked */
+	gpio1->IMR &= ~(1 << 5);
+
+	return HDF_SUCCESS;
+}
+
+static void gt9xx_irq_clear(uint32_t irq)
+{
+	(void)irq;
+	
+	gpio1->ISR |= (1 << 5);
+}
+
+static void gt9xx_init(void)
+{
+    /*初始化gt911_io*/
+	gt911_io_init();
+	/*初始化两个I0都为低电平*/
+	gpio5->DR &= ~(1<<2);
+	gpio1->DR &= ~(1<<5);
+	/*10ms*/
+	OsalMSleep(RESET_LOW_DELAY);
+	/*reset 输出高，INT转为悬浮输出态*/
+	gpio5->DR |= (1<<2);
+	*IOMUXC_PAD_CTL_GPIO1_IO05 = 0x0088; 
+	gpio1->GDIR &= ~(1<<5);
+	/*100ms*/
+	OsalMSleep(RESET_LOW_DELAY*10);
+}
+
+/* end for imx6ull */
+
+
+TouchCoreData *GetCoreData(void)
+{
+    return g_coreData;
+}
+
+static void TouchWakeupPoll(void)
+{
+    TouchCoreData *cd = GetCoreData();
+    cd->readFinishFlag = true;
+    wake_up_interruptible(&cd->pollWait);
+}
+
+uint32_t IrqHandle(uint32_t irqId, void *dev)
+{
+    (void)dev;
+    int ret = gt9xx_irq_disable(irqId);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: disable irq failed, ret %d", __func__, ret);
+    }
+    (void)LOS_EventWrite(&g_touchEventIrq, EVENT_SYNC);
+
+    return HDF_SUCCESS;
+}
+
+static void TouchConfigInit(TouchCoreData *cd)
+{
+    /* init waitqueue for poll */
+    __init_waitqueue_head(&cd->pollWait);
+
+    /* config i2c and input */
+    cd->i2cClient.i2cCfg.addr = DRIVER_CHIP_I2C_ADDR;
+    cd->i2cClient.i2cCfg.busNum = I2C_BUS_NUM;
+    cd->inputCfg.solutionX = TOUCH_SOLUTION_X;
+    cd->inputCfg.solutionY = TOUCH_SOLUTION_Y;
+
+    /* config device type and module info */
+    cd->inputDevType = INDEV_TYPE_TOUCH;
+    (void)strncpy_s(cd->chipInfo, CHIP_INFO_LEN, "HZ1145130", strlen("HZ1145130"));
+    (void)strncpy_s(cd->vendorName, VENDOR_NAME_LEN, "ZG1695", strlen("TG1695"));
+    (void)strncpy_s(cd->chipName, CHIP_NAME_LEN, "GT9xx", strlen("GT9xx"));
+
+    /* pin num and irq trigger config info */
+    //cd->rstGpioNum = RST_GPIO_GROUP * GPIO_GROUP_SIZE + RST_GPIO_OFFSET;
+    cd->intGpioNum = GT9XX_INT_NUM;
+    cd->irqFlag = OSAL_IRQF_TRIGGER_FALLING;
+    cd->shouldStop = false;
+}
+
+
+static int TouchSetupGpio(const TouchCoreData *cd)
+{
+	gt9xx_init();
+    return HDF_SUCCESS;
+}
+
+static void ReadChipVersion(TouchCoreData *cd)
+{
+    unsigned char buf[GT_CFG_INFO_LEN] = {0};
+    int ret = InputI2cRead(&cd->i2cClient, GT_CFG_INFO_ADDR, GT_ADDR_LEN, buf, GT_CFG_INFO_LEN);
+    if (ret < 0) {
+        HDF_LOGE("%s: read chip version failed", __func__);
+        return;
+    }
+
+    int version = (buf[GT_FW_VER_HIGH] << ONE_BYTE_OFFSET) | buf[GT_FW_VER_LOW];
+    int xSolution = (buf[GT_SOLU_X_HIGH] << ONE_BYTE_OFFSET) | buf[GT_SOLU_X_LOW];
+    int ySolution = (buf[GT_SOLU_Y_HIGH] << ONE_BYTE_OFFSET) | buf[GT_SOLU_Y_LOW];
+    HDF_LOGI("%s: IC FW version is 0x%x", __func__, version);
+    if (buf[GT_FW_VER_HIGH] == 0x0) {
+        HDF_LOGI("Product ID : %c%c%c_%02x%02x, X_Solu = %d, Y_Solu = %d", buf[GT_PROD_ID_1ST], buf[GT_PROD_ID_2ND],
+            buf[GT_PROD_ID_3RD], buf[GT_FW_VER_HIGH], buf[GT_FW_VER_LOW], xSolution, ySolution);
+    } else {
+        HDF_LOGI("Product_ID: %c%c%c%c_%02x%02x, X_Solu = %d, Y_Solu = %d", buf[GT_PROD_ID_1ST], buf[GT_PROD_ID_2ND],
+            buf[GT_PROD_ID_3RD], buf[GT_PROD_ID_4TH], buf[GT_FW_VER_HIGH], buf[GT_FW_VER_LOW], xSolution, ySolution);
+    }
+}
+
+static int TouchSetupI2c(TouchCoreData *cd)
+{
+    /* get i2c handle */
+    cd->i2cClient.i2cHandle = I2cOpen(cd->i2cClient.i2cCfg.busNum);
+    if (cd->i2cClient.i2cHandle == NULL) {
+        HDF_LOGE("%s: open i2c failed", __func__);
+        return HDF_FAILURE;
+    }
+
+    ReadChipVersion(cd);
+    return HDF_SUCCESS;
+}
+
+static int TouchCleanBuffer(void)
+{
+    TouchCoreData *cd = GetCoreData();
+    unsigned char writeBuf[GT_CLEAN_DATA_LEN];
+    writeBuf[GT_REG_HIGH_POS] = (GT_BUF_STATE_ADDR >> ONE_BYTE_OFFSET) & ONE_BYTE_MASK;
+    writeBuf[GT_REG_LOW_POS] = GT_BUF_STATE_ADDR & ONE_BYTE_MASK;
+    writeBuf[GT_CLEAN_POS] = GT_CLEAN_FLAG;
+    int ret = InputI2cWrite(&cd->i2cClient, writeBuf, GT_CLEAN_DATA_LEN);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: InputI2cWrite fail, ret = %d", __func__, ret);
+    }
+    return ret;
+}
+
+static int EventHandler(const TouchCoreData *cd, InputEventData *event)
+{
+	static int bPressed = 0;
+    unsigned char fingerNum = 0;
+    int pointNum;
+    (void)memset_s(event, sizeof(InputEventData), 0, sizeof(InputEventData));
+
+    int ret = InputI2cRead(&cd->i2cClient, GT_BUF_STATE_ADDR, GT_ADDR_LEN, &fingerNum, 1);
+    if (ret < 0) {
+        return HDF_FAILURE;
+    }
+
+	//PRINT_RELEASE("%s %s %d, fingerNum= 0x%x\n", __FILE__, __FUNCTION__, __LINE__, fingerNum);
+	
+    if (fingerNum == GT_EVENT_INVALID) {
+		return HDF_FAILURE;
+		
+    }
+    if (fingerNum == GT_EVENT_UP) {
+        g_touchEventData.pointNum = 0;
+        g_touchEventData.definedEvent = TOUCH_EVENT_UP;
+
+		if (bPressed) {
+			bPressed = 0;
+			//HDF_LOGE("%s: pointNum is invalid, %d", __func__, pointNum);
+			event->pressure = 0;
+			event->pointNum = 0;
+			event->definedEvent = TOUCH_EVENT_DOWN;
+			
+			if (memcpy_s(&g_touchEventData, sizeof(InputEventData), event, sizeof(InputEventData)) != EOK) {
+				HDF_LOGE("%s: memcpy_s fail", __func__);
+				return HDF_FAILURE;
+			}
+		}	
+        goto exit;
+    }
+
+    pointNum = fingerNum & GT_FINGER_NUM_MASK;
+    if (pointNum > 0) {
+        unsigned char eventBuf[GT_EVENT_SIZE] = {0};
+        (void)InputI2cRead(&cd->i2cClient, GT_X_LOW_BYTE_BASE, GT_ADDR_LEN, eventBuf, GT_EVENT_SIZE);
+
+		bPressed = 1;
+		
+        /* parse the i2c data */
+        event->x = (eventBuf[GT_X_LOW] & ONE_BYTE_MASK) | ((eventBuf[GT_X_HIGH] & ONE_BYTE_MASK) << ONE_BYTE_OFFSET);
+        event->y = (eventBuf[GT_Y_LOW] & ONE_BYTE_MASK) | ((eventBuf[GT_Y_HIGH] & ONE_BYTE_MASK) << ONE_BYTE_OFFSET);
+		event->pressure = (eventBuf[GT_PRESSURE_LOW] & ONE_BYTE_MASK) | ((eventBuf[GT_PRESSURE_HIGH] & ONE_BYTE_MASK) << ONE_BYTE_OFFSET);
+        event->pointNum = pointNum;
+        event->definedEvent = TOUCH_EVENT_DOWN;
+	
+        if (memcpy_s(&g_touchEventData, sizeof(InputEventData), event, sizeof(InputEventData)) != EOK) {
+            HDF_LOGE("%s: memcpy_s fail", __func__);
+            return HDF_FAILURE;
+        }
+    } else {
+		return HDF_FAILURE;
+    }
+exit:
+    if (TouchCleanBuffer() != HDF_SUCCESS) {
+        return HDF_FAILURE;
+    }
+    return HDF_SUCCESS;
+}
+
+static void TouchHandleEvent(void)
+{
+    InputEventData event;
+    TouchCoreData *cd = GetCoreData();
+    (void)memset_s(&event, sizeof(InputEventData), 0, sizeof(InputEventData));
+
+    while (true) {
+        int ret = LOS_EventRead(&g_touchEventIrq, EVENT_SYNC, LOS_WAITMODE_AND | LOS_WAITMODE_CLR, LOS_WAIT_FOREVER);
+        if (ret != EVENT_SYNC) {
+            OsalMSleep(TASK_SLEEP_MS);
+        } else {
+            if (EventHandler(cd, &event) == HDF_SUCCESS) {
+                TouchWakeupPoll();
+            }
+        }
+
+		gt9xx_irq_clear(cd->intGpioNum);
+        ret = gt9xx_irq_enable(cd->intGpioNum);
+        if (ret != HDF_SUCCESS) {
+            HDF_LOGE("%s: enable irq failed, ret %d", __func__, ret);
+        }
+
+        if (cd->shouldStop) {
+            HDF_LOGE("%s: the event task should be stoped", __func__);
+            break;
+        }
+    }
+}
+
+static int TouchIrqTaskInit(TouchCoreData *cd)
+{
+    /* init event for irq */
+    int ret = LOS_EventInit(&g_touchEventIrq);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: LOS_EventInit failed, ret %d", __func__, ret);
+        return HDF_FAILURE;
+    }
+
+    /* register irq */
+	gt9xx_irq_init(cd);
+
+    /* enable irq */
+    ret = gt9xx_irq_enable(cd->intGpioNum);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: enable irq failed, ret %d", __func__, ret);
+        return HDF_FAILURE;
+    }
+
+    /* set irq task which to handle point event data */
+    TSK_INIT_PARAM_S handleEventTask = {0};
+    UINT32 handleEventTaskID;
+    handleEventTask.pfnTaskEntry = (TSK_ENTRY_FUNC)TouchHandleEvent;
+    handleEventTask.uwStackSize  = TASK_SIZE;
+    handleEventTask.pcName       = "HdfTouchEventHandler";
+    handleEventTask.usTaskPrio   = TASK_PRIO_LEVEL_TWO;
+    handleEventTask.uwResved     = LOS_TASK_STATUS_DETACHED;
+    ret = LOS_TaskCreate(&handleEventTaskID, &handleEventTask);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: create event handle task failed, ret %d", __func__, ret);
+        return HDF_FAILURE;
+    }
+    return HDF_SUCCESS;
+}
+
+static int IoctlReadInputEvent(unsigned long arg)
+{
+    InputEventData *eventData = (InputEventData *)(uintptr_t)arg;
+
+    if (eventData == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    if (LOS_ArchCopyToUser(eventData, &g_touchEventData, sizeof(g_touchEventData)) != 0) {
+        HDF_LOGE("%s:copy chipInfo failed", __func__);
+        return HDF_FAILURE;
+    }
+    return HDF_SUCCESS;
+}
+
+static int IoctlGetDeviceType(unsigned long arg)
+{
+    unsigned int *devType = (unsigned int *)(uintptr_t)arg;
+    TouchCoreData *cd = GetCoreData();
+
+    if (devType == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+
+    if (LOS_ArchCopyToUser(devType, &cd->inputDevType, sizeof(cd->inputDevType)) != 0) {
+        HDF_LOGE("%s:copy devType failed", __func__);
+        return HDF_FAILURE;
+    }
+
+    HDF_LOGI("%s: devType is %u", __func__, cd->inputDevType);
+    return HDF_SUCCESS;
+}
+
+static int IoctlGetChipInfo(unsigned long arg)
+{
+    TouchCoreData *cd = GetCoreData();
+    char *chipInfo = (char *)(uintptr_t)arg;
+
+    if (chipInfo == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+
+    if (LOS_ArchCopyToUser(chipInfo, cd->chipInfo, CHIP_INFO_LEN) != 0) {
+        HDF_LOGE("%s:copy chipInfo failed", __func__);
+        return HDF_FAILURE;
+    }
+
+    HDF_LOGI("%s: chipInfo is %s", __func__, cd->chipInfo);
+    return HDF_SUCCESS;
+}
+
+static int TouchIoctl(FAR struct file *filep, int cmd, unsigned long arg)
+{
+    int ret;
+    if (filep == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+
+    switch (cmd) {
+        case INPUT_IOCTL_GET_EVENT_DATA:
+            ret = IoctlReadInputEvent(arg);
+            break;
+        case INPUT_IOCTL_GET_DEVICE_TYPE:
+            ret = IoctlGetDeviceType(arg);
+            break;
+        case INPUT_IOCTL_GET_CHIP_INFO:
+            ret = IoctlGetChipInfo(arg);
+            break;
+        default:
+            ret = 0;
+            HDF_LOGE("%s: cmd unknown, cmd = 0x%x", __func__, cmd);
+            break;
+    }
+    return ret;
+}
+
+#ifndef CONFIG_DISABLE_POLL
+static int TouchPoll(FAR struct file *filep, poll_table *wait)
+{
+    unsigned int pollMask = 0;
+    TouchCoreData *cd = GetCoreData();
+
+    if (filep == NULL || wait == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    poll_wait(filep, &cd->pollWait, wait);
+    if (cd->readFinishFlag == true) {
+        pollMask |= POLLIN;
+    }
+    cd->readFinishFlag = false;
+    return pollMask;
+}
+#endif
+
+static int TouchOpen(FAR struct file *filep)
+{
+    HDF_LOGI("%s: called", __func__);
+    if (filep == NULL) {
+        HDF_LOGE("%s: fliep is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    return HDF_SUCCESS;
+}
+
+static int TouchClose(FAR struct file *filep)
+{
+    HDF_LOGI("%s: called", __func__);
+    TouchCoreData *cd = GetCoreData();
+
+    if (filep == NULL) {
+        HDF_LOGE("%s: fliep is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    __init_waitqueue_head(&cd->pollWait);
+    return HDF_SUCCESS;
+}
+
+static const struct file_operations_vfs g_touchDevOps = {
+    .open = TouchOpen,
+    .close = TouchClose,
+    .read = NULL,
+    .write = NULL,
+    .seek = NULL,
+    .ioctl = TouchIoctl,
+    .mmap = NULL,
+#ifndef CONFIG_DISABLE_POLL
+    .poll = TouchPoll,
+#endif
+    .unlink = NULL,
+};
+
+
+int32_t Gt911Dispatch(struct HdfDeviceIoClient *client, int cmdId, struct HdfSBuf *data, struct HdfSBuf *reply)
+{
+    (void)client;
+    (void)cmdId;
+    if (data == NULL || reply == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_FAILURE;
+    }
+    return HDF_SUCCESS;
+}
+
+int32_t Gt9xxTouchDriverOpen(struct HdfDeviceObject *object)
+{
+    if (object == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    static struct IDeviceIoService service = {
+        .object = {0},
+        .Dispatch = Gt911Dispatch,
+    };
+    object->service = &service;
+    return HDF_SUCCESS;
+}
+
+int Gt9xxTouchDriverInit(struct HdfDeviceObject *object)
+{
+    (void)object;
+    HDF_LOGI("%s: enter", __func__);
+    g_coreData = (TouchCoreData *)OsalMemAlloc(sizeof(TouchCoreData));
+    if (g_coreData == NULL) {
+        HDF_LOGE("%s: malloc failed", __func__);
+        return HDF_ERR_MALLOC_FAIL;
+    }
+    (void)memset_s(g_coreData, sizeof(TouchCoreData), 0, sizeof(TouchCoreData));
+    TouchConfigInit(g_coreData);
+
+    if (TouchSetupGpio(g_coreData)) {
+        goto ERR_EXIT;
+    }
+
+    if (TouchSetupI2c(g_coreData)) {
+        goto ERR_EXIT;
+    }
+
+    if (TouchIrqTaskInit(g_coreData)) {
+        goto ERR_EXIT;
+    }
+
+    (void)mkdir("/dev/input", DEFAULT_DIR_MODE);
+    int ret = register_driver(TOUCH_DEVICE, &g_touchDevOps, TOUCH_DEVICE_MODE, NULL);
+    if (ret != 0) {
+        HDF_LOGE("%s: register touch dev failed, ret %d", __func__, ret);
+        goto ERR_EXIT;
+    }
+    HDF_LOGI("%s: exit succ", __func__);
+    return HDF_SUCCESS;
+
+ERR_EXIT:
+    if (g_coreData->i2cClient.i2cHandle != NULL) {
+        I2cClose(g_coreData->i2cClient.i2cHandle);
+        g_coreData->i2cClient.i2cHandle = NULL;
+    }
+    OsalMemFree(g_coreData);
+    g_coreData = NULL;
+    return HDF_FAILURE;
+}
+
+struct HdfDriverEntry g_gt9xxTouchDevEntry = {
+    .moduleVersion = 1,
+    .moduleName = "HDF_TOUCHSCREEN",
+    .Bind = Gt9xxTouchDriverOpen,
+    .Init = Gt9xxTouchDriverInit,
+};
+
+HDF_INIT(g_gt9xxTouchDevEntry);
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/driver/touch/touch_gt9xx.h openharmony_100ask/vendor/nxp/imx6ull/driver/touch/touch_gt9xx.h
--- openharmony/vendor/nxp/imx6ull/driver/touch/touch_gt9xx.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/driver/touch/touch_gt9xx.h	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: ft6236 touch driver interface.
+ * Author: zhaihaipeng
+ * Create: 2020-07-25
+ */
+
+#ifndef TOUCH_GT911_H
+#define TOUCH_GT911_H
+
+#include <stdint.h>
+#include <sys/time.h>
+#include <sys/wait.h>
+#include "i2c_if.h"
+
+/* screen resolution */
+#define TOUCH_SOLUTION_X 1024
+#define TOUCH_SOLUTION_Y 600
+/* driver chip i2c address */
+#define DRIVER_CHIP_I2C_ADDR 0x5D
+#define I2C_BUS_NUM 0
+/* pin num of reset and irq */
+#define GPIO_GROUP_SIZE 8
+#define RST_GPIO_GROUP 1
+#define RST_GPIO_OFFSET 5
+#define INT_GPIO_GROUP 1
+#define INT_GPIO_OFFSET 4
+/* the config of reset delay */
+#define RESET_LOW_DELAY 10
+#define RESET_HIGH_DELAY 60
+/* IO config for int-pin and I2C-pin */
+#define I2C6_DATA_REG_ADDR 0x114f004c
+#define I2C6_CLK_REG_ADDR 0x114f0048
+#define INR_REG_ADDR 0x10ff002C
+#define RST_REG_ADDR 0x10ff0030
+#define I2C_REG_CFG 0x403
+#define INT_REG_CFG 0x400
+#define RST_REG_CFG 0x400
+/* length of string about device info */
+#define CHIP_INFO_LEN 10
+#define CHIP_NAME_LEN 10
+#define VENDOR_NAME_LEN 10
+#define SELF_TEST_RESULT_LEN 20
+
+typedef enum {
+    EVENT_DOWN,
+    EVENT_UP,
+    EVENT_CONTACT,
+} EventType;
+
+typedef enum {
+    INPUT_SUCCESS,
+    INPUT_EINVAL,
+    INPUT_EFAULT,
+    INPUT_ENOMEM,
+    INPUT_ETIMEOUT,
+    INPUT_EUNSUPPORT,
+    INPUT_EUNKNOWN,
+} RetStatus;
+
+enum InputDevType {
+    INDEV_TYPE_TOUCH,
+    INDEV_TYPE_KEY,
+    INDEV_TYPE_KEYBOARD,
+    INDEV_TYPE_MOUSE,
+    INDEV_TYPE_BUTTON,
+    INDEV_TYPE_CROWN,
+    INDEV_TYPE_ENCODER, /* Encoder with specific function or event */
+    INDEV_TYPE_MAX,
+};
+
+enum PowerStatus {
+    INPUT_RESUME = 0,
+    INPUT_SUSPEND = 1,
+    INPUT_LOW_POWER = 2,
+    INPUT_POWER_STATUS_UNKNOWN,
+};
+
+/** multi touch info */
+typedef struct {
+    int x;    /* x coordinate */
+    int y;    /* y coordinate */
+    int pressure;
+    int definedEvent;    /* touch event: 0-down; 1-up; 2-contact */
+    int fingerID;        /* touch ID */
+    int pointNum;
+    struct timeval timeStamp;
+    bool moreDataFlag;
+} InputEventData;
+
+
+typedef struct {
+    unsigned int testType;
+    char testResult[SELF_TEST_RESULT_LEN + 1];
+} CapacitanceTestInfo;
+
+typedef struct {
+    const char *cmdCode;
+    const char *cmdValue;
+} InputExtraCmd;
+
+struct InputConfig {
+    unsigned int solutionX;
+    unsigned int solutionY;
+};
+
+typedef struct {
+    unsigned int inputDevType;
+    wait_queue_head_t pollWait;
+    bool readFinishFlag;
+    bool shouldStop;
+    struct InputConfig inputCfg;
+    InputI2cClient i2cClient;
+    int intGpioNum;
+    int rstGpioNum;
+    unsigned int irqFlag;
+    unsigned int powerStatus;
+    char chipInfo[CHIP_INFO_LEN];
+    char vendorName[VENDOR_NAME_LEN];
+    char chipName[CHIP_NAME_LEN];
+} TouchCoreData;
+
+enum TouchIoctlCmd {
+    INPUT_IOCTL_GET_EVENT_DATA,
+    INPUT_IOCTL_SET_POWER_STATUS,
+    INPUT_IOCTL_GET_POWER_STATUS,
+    INPUT_IOCTL_GET_DEVICE_TYPE,
+    INPUT_IOCTL_GET_CHIP_INFO,
+    INPUT_IOCTL_GET_VENDOR_NAME,
+    INPUT_IOCTL_GET_CHIP_NAME,
+    INPUT_IOCTL_SET_GESTURE_MODE,
+    INPUT_IOCTL_RUN_CAPACITANCE_TEST,
+    INPUT_IOCTL_RUN_EXTRA_CMD,
+};
+
+#endif
diff -urN -x .git -x .repo openharmony/vendor/nxp/imx6ull/imx6ull.mk openharmony_100ask/vendor/nxp/imx6ull/imx6ull.mk
--- openharmony/vendor/nxp/imx6ull/imx6ull.mk	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/nxp/imx6ull/imx6ull.mk	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,24 @@
+
+IMX6ULL_BASE_DIR  := $(LITEOSTOPDIR)/../../vendor/nxp/imx6ull
+
+LIB_SUBDIRS     += $(IMX6ULL_BASE_DIR)/board
+LITEOS_BASELIB  += -lboard
+
+LIB_SUBDIRS     += $(IMX6ULL_BASE_DIR)/driver/mtd/common
+LITEOS_BASELIB  += -lmtd_common
+
+LIB_SUBDIRS     += $(IMX6ULL_BASE_DIR)/driver/mtd/spi_nor
+LITEOS_BASELIB  += -lspinor_flash
+
+ifeq ($(LOSCFG_DRIVERS_VIDEO), y)
+LIB_SUBDIRS             += $(IMX6ULL_BASE_DIR)/driver/imx6ull-fb
+LITEOS_BASELIB  += -limx6ull-fb
+endif
+
+LIB_SUBDIRS             += $(IMX6ULL_BASE_DIR)/driver/imx6ull-uart
+LITEOS_BASELIB  += -limx6ull-uart
+
+
+LITEOS_MTD_SPI_NOR_INCLUDE +=   -I$(IMX6ULL_BASE_DIR)/driver/mtd/common/include \
+                                                                -I$(IMX6ULL_BASE_DIR)/driver/mtd/spi_nor/include
+
diff -urN -x .git -x .repo openharmony/vendor/st/hdf/hdf_vendor.mk openharmony_100ask/vendor/st/hdf/hdf_vendor.mk
--- openharmony/vendor/st/hdf/hdf_vendor.mk	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/hdf/hdf_vendor.mk	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,35 @@
+# Copyright (c) 2020 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+    LITEOS_BASELIB += -lhdf_config
+    LIB_SUBDIRS += $(LITEOS_SOURCE_ROOT)/vendor/st/$(LITEOS_PLATFORM)/config
+
+
+VENDOR_HDF_DRIVERS_ROOT := $(LITEOSTOPDIR)/../../vendor/st/hdf
+
+ifeq ($(LOSCFG_PLATFORM_STM32MP157), y)
+#LIB_SUBDIRS             += $(STM32MP157_BASE_DIR)/driver/stm32mp157-i2c
+#LITEOS_BASELIB  += -lstm32mp157-i2c
+endif
+
+#LIB_SUBDIRS             += $(STM32MP157_BASE_DIR)/driver/touch
+#LITEOS_BASELIB  += -ltouch
+
+
+LIB_SUBDIRS             += $(STM32MP157_BASE_DIR)/driver/hello
+LITEOS_BASELIB  += -lhello
+
+# lib path
+LITEOS_LD_PATH += -L$(VENDOR_HDF_DRIVERS_ROOT)/libs/$(LITEOS_PLATFORM)
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/board/board.c openharmony_100ask/vendor/st/stm32mp157/board/board.c
--- openharmony/vendor/st/stm32mp157/board/board.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/board/board.c	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,116 @@
+#include "los_base.h"
+#include "los_config.h"
+#include "los_process_pri.h"
+#include "lwip/init.h"
+#include "lwip/tcpip.h"
+#include "sys/mount.h"
+#include "mtd_partition.h"
+#include "console.h"
+
+UINT32 OsRandomStackGuard(VOID)
+{
+    return 0;
+}
+
+static void imx6ull_mount_rootfs()
+{
+#if 1	
+	int fd;
+    dprintf("register parition ...\n");
+    if (add_mtd_partition("spinor", 0, DDR_RAMFS_REAL_SIZE, 0))
+    {
+        PRINT_ERR("add_mtd_partition fail\n");
+    }
+    
+    dprintf("mount /dev/spinorblk0 / ...\n");
+    //if (mount("/dev/spinorblk0", "/", "jffs2", MS_RDONLY, NULL))
+    if (mount("/dev/spinorblk0", "/", "jffs2", 0, NULL))
+    {
+        PRINT_ERR("mount failed\n");
+    }
+	fd = open("/bin/init", O_RDONLY);
+    dprintf("open /bin/init, fd = %d\n", fd);
+#else
+    dprintf("mount /dev/ramdisk / ...\n");
+    //if (mount("/dev/spinorblk0", "/", "jffs2", MS_RDONLY, NULL))
+    if (mount("/dev/ramdisk", "/", "vfat", 0, NULL))
+    {
+        PRINT_ERR("mount failed\n");
+    }
+#endif
+}
+
+static void imx6ull_driver_init()
+{
+#if 0	
+	extern int my_ramdisk_init(void);
+    if (my_ramdisk_init())
+    {
+        PRINT_ERR("my_ramdisk_init failed\n");
+    }
+
+#else	
+    extern int spinor_init(void);
+    dprintf("spinor_init init ...\n");
+    if (!spinor_init())
+    {
+        PRINT_ERR("spinor_init failed\n");
+    }
+#endif
+
+#ifdef LOSCFG_DRIVERS_VIDEO
+    dprintf("imx6ull_fb_init init ...\n");
+	extern int imx6ull_fb_init(void);
+    if (imx6ull_fb_init())
+    {
+        PRINT_ERR("imx6ull_fb_init failed\n");
+    }
+#endif	
+
+}
+
+
+void SystemInit()
+{
+#ifdef LOSCFG_FS_PROC
+    dprintf("proc fs init ...\n");
+    extern void ProcFsInit(void);
+    ProcFsInit();
+#endif
+
+#ifdef LOSCFG_DRIVERS_MEM
+    dprintf("mem dev init ...\n");
+    extern int mem_dev_register(void);
+    mem_dev_register();
+#endif
+    imx6ull_driver_init();
+    imx6ull_mount_rootfs();
+
+#ifdef LOSCFG_DRIVERS_HDF
+	    extern int DeviceManagerStart(void);
+		PRINT_RELEASE("DeviceManagerStart start ...\n");	
+		if (DeviceManagerStart()) {
+			PRINT_ERR("No drivers need load by hdf manager!");
+		}
+		dprintf("DeviceManagerStart end ...\n");
+#endif
+
+    extern int uart_dev_init(void);
+    uart_dev_init();
+
+    if (virtual_serial_init("/dev/uartdev-0") != 0)
+    {
+        PRINT_ERR("virtual_serial_init failed");
+    }
+
+    if (system_console_init(SERIAL) != 0)
+    {
+        PRINT_ERR("system_console_init failed\n");
+    }
+
+    if (OsUserInitProcess())
+    {
+        PRINT_ERR("Create user init process faialed!\n");
+    }
+}
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/board/bsd_board.c openharmony_100ask/vendor/st/stm32mp157/board/bsd_board.c
--- openharmony/vendor/st/stm32mp157/board/bsd_board.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/board/bsd_board.c	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,83 @@
+#include "asm/platform.h"
+#include "sys/bus.h"
+#include "uart_dev.h"
+//#include "imx6ull_uart.h"
+
+#include "los_hw_pri.h"
+
+
+
+#define UART_IOMEM_COUNT 0xBC
+
+/**************************************************/
+/*        UART Device                      */
+/**************************************************/
+//#if LOSCFG_DRIVERS_UART
+
+#define BAUD_RATE_LOW 9600
+#define BAUD_RATE_HIGH 115200
+
+void dma_cache_clean(UINTPTR start, UINTPTR end)
+{
+    arm_clean_cache_range(start, end);
+}
+void dma_cache_inv(UINTPTR start, UINTPTR end)
+{
+    arm_inv_cache_range(start, end);
+}
+
+static struct uart_driver_data uart0_dw_driver = { /*lint !e121 !e129 !e10 -esym(528, uart0_pl011_driver)*/
+    .num             = 0,
+    .baudrate        = BAUD_RATE_HIGH,
+    .attr.fifo_rx_en = 1,
+    .attr.fifo_tx_en = 1,
+//    .flags           = UART_FLG_RD_BLOCK,
+};
+static struct uart_softc uart0_softc = { /*lint !e10 !e129*/
+    .udd = &uart0_dw_driver,
+};
+
+#define UART_ADD_DEVICE(dev, unit) \
+    do { \
+        dev = device_add_child(nexus, "uart", unit); \
+        if (dev != NULL) { \
+            device_set_softc(dev, &uart ## unit ## _softc); \
+        } \
+    } while (0)
+
+// callback never be null pointer
+static void uart_add_device(add_res_callback_t callback)
+{
+    device_t uart_dev;
+    UART_ADD_DEVICE(uart_dev, 0);
+    callback("uart", SYS_RES_MEMORY, 0, UART4_REG_PBASE,
+        UART4_REG_PBASE + UART_IOMEM_COUNT, UART_IOMEM_COUNT);
+    callback("uart", SYS_RES_IRQ, 0, NUM_HAL_INTERRUPT_UART4,
+        NUM_HAL_INTERRUPT_UART4, 1);
+
+}
+//#endif
+
+//#if defined (LOSCFG_DRIVERS_MTD_SPI_NOR_SUNXI)
+static void imx6ull_spinor_resource_init(add_res_callback_t callback)
+{
+    device_add_child(nexus, "sunxi_spi", 0);
+    callback("sunxi_spi", SYS_RES_MEMORY, 0, FMC_REG_PBASE, FMC_REG_PBASE + FMC_REG_OFFSIZE, FMC_REG_OFFSIZE);
+    //callback("sunxi_spi", SYS_RES_MEMORY, 1, FMC_MEM_PBASE, FMC_MEM_PBASE + FMC_MEM_OFFSIZE, FMC_MEM_OFFSIZE);
+}
+//#endif
+
+void machine_resource_init(add_res_callback_t callback)
+{
+    if (callback == NULL) {
+        return;
+    }
+
+//#if LOSCFG_DRIVERS_UART
+    uart_add_device(callback);
+//#endif
+
+//#if defined (LOSCFG_DRIVERS_MTD_SPI_NOR_SUNXI)
+    imx6ull_spinor_resource_init(callback);
+//#endif
+}
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/board/include/asm/hal_platform_ints.h openharmony_100ask/vendor/st/stm32mp157/board/include/asm/hal_platform_ints.h
--- openharmony/vendor/st/stm32mp157/board/include/asm/hal_platform_ints.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/board/include/asm/hal_platform_ints.h	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef PLATFORM_HAL_PLATFORM_INTS_H
+#define PLATFORM_HAL_PLATFORM_INTS_H
+
+#include"los_typedef.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+/**
+ * Maximum number of supported hardware devices that generate hardware interrupts.
+ * The maximum number of hardware devices that generate hardware interrupts is 128.
+ */
+#define OS_HWI_MAX_NUM                  160
+
+/**
+ * Maximum interrupt number.
+ */
+
+#define OS_HWI_MAX                      ((OS_HWI_MAX_NUM) - 1)
+
+/**
+ * Minimum interrupt number.
+ */
+
+#define OS_HWI_MIN                      0
+
+/**
+ * Maximum usable interrupt number.
+ */
+
+#define OS_USER_HWI_MAX                 OS_HWI_MAX
+
+/**
+ * Minimum usable interrupt number.
+ */
+
+#define OS_USER_HWI_MIN                 OS_HWI_MIN
+
+#define NUM_HAL_INTERRUPT_CNTPSIRQ      29
+#define NUM_HAL_INTERRUPT_CNTPNSIRQ     30
+#define OS_TICK_INT_NUM                 NUM_HAL_INTERRUPT_CNTPSIRQ // use secure physical timer for now
+
+#define NUM_HAL_INTERRUPT_TIMER0        37
+#define NUM_HAL_INTERRUPT_TIMER1        37
+#define NUM_HAL_INTERRUPT_TIMER2        38
+#define NUM_HAL_INTERRUPT_TIMER3        38
+
+#define NUM_HAL_INTERRUPT_UART0         58
+#define NUM_HAL_INTERRUPT_UART1         40
+#define NUM_HAL_INTERRUPT_UART2         41
+
+#define NUM_HAL_INTERRUPT_UART4         84
+
+
+#define NUM_HAL_INTERRUPT_GPIO0         48
+#define NUM_HAL_INTERRUPT_GPIO1         49
+#define NUM_HAL_INTERRUPT_GPIO2         50
+#define NUM_HAL_INTERRUPT_GPIO3         51
+#define NUM_HAL_INTERRUPT_GPIO4         52
+#define NUM_HAL_INTERRUPT_GPIO5         53
+#define NUM_HAL_INTERRUPT_GPIO6         54
+#define NUM_HAL_INTERRUPT_GPIO7         55
+#define NUM_HAL_INTERRUPT_GPIO8         56
+#define NUM_HAL_INTERRUPT_GPIO9         57
+
+#define NUM_HAL_INTERRUPT_SDIO          62
+#define NUM_HAL_INTERRUPT_SDIO1         63
+
+#define NUM_HAL_INTERRUPT_FMC           64
+#define NUM_HAL_INTERRUPT_ETH           65
+
+#define NUM_HAL_INTERRUPT_DMAC          70
+#define NUM_HAL_INTERRUPT_USB_XHCI      71
+#define NUM_HAL_INTERRUPT_USB_DEV       71
+
+#define NUM_HAL_INTERRUPT_TIMER         NUM_HAL_INTERRUPT_TIMER0
+#define NUM_HAL_INTERRUPT_HRTIMER       NUM_HAL_INTERRUPT_TIMER3
+
+#define NUM_HAL_INTERRUPT_NONE          -1
+
+#define NUM_HAL_ISR_MIN                 OS_HWI_MIN
+#define NUM_HAL_ISR_MAX                 1020
+#define NUM_HAL_ISR_COUNT               (NUM_HAL_ISR_MAX - NUM_HAL_ISR_MIN + 1)
+
+#define IO_ADDRESS(x)       (x)
+
+#define HAL_READ_UINT8(addr, data)  READ_UINT8(data, addr)
+
+#define HAL_WRITE_UINT8(addr, data) WRITE_UINT8(data, addr)
+
+#define HAL_READ_UINT32(addr, data) READ_UINT32(data, addr)
+
+#define HAL_WRITE_UINT32(addr, data) WRITE_UINT32(data, addr)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+#endif // PLATFORM_HAL_PLATFORM_INTS_H
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/board/include/asm/platform.h openharmony_100ask/vendor/st/stm32mp157/board/include/asm/platform.h
--- openharmony/vendor/st/stm32mp157/board/include/asm/platform.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/board/include/asm/platform.h	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __ASM_PLATFORM_H__
+#define __ASM_PLATFORM_H__
+
+#include "menuconfig.h"
+#include "los_bitmap.h"
+#include "asm/hal_platform_ints.h"
+//#include "hisoc/timer.h"
+//#include "hisoc/uart.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+/*------------------------------------------------
+ * GIC reg base address
+ *------------------------------------------------*/
+/* GIC_PHY_BASE(0xA0000000) ==> GIC_VIRT_BASE 
+ * GICD(0xA0021000)
+ * GICC(0xA0022000)
+ * so: GIC_BASE_ADDR = vir addr of 0xA0020000
+ */ 
+//#define GIC_BASE_ADDR             IO_DEVICE_ADDR(0x00a00000)
+#define GIC_BASE_ADDR             (GIC_VIRT_BASE + 0x20000)
+#define GICD_OFFSET               0x1000     /* interrupt distributor offset */
+#define GICC_OFFSET               0x2000     /* CPU interface register offset */
+
+#define FMC_MEM_PBASE             0x14000000
+#define FMC_MEM_OFFSIZE           0x8
+#define FMC_REG_PBASE             0x10000000
+#define FMC_REG_OFFSIZE           0xdc
+
+#define PERIPH_REG_BASE           IO_DEVICE_ADDR(0x12000000)
+#define IO_CTL_REG_VBASE          IO_DEVICE_ADDR(0x10F00000)
+
+#define SDIO0_REG_PBASE           0x10010000
+#define SDIO1_REG_PBASE           0x10020000
+#define MMC_REG_OFFSIZE           0x600
+
+#define ETH_REG_PBASE             0x10040000
+#define ETH_REG_BASE              IO_DEVICE_ADDR(0x10040000)
+#define ETH_REG_OFFSIZE           0x2000
+#define DMAC_REG_BASE             IO_DEVICE_ADDR(0x100b0000)
+#define IO_MUX_REG_BASE           IO_DEVICE_ADDR(0x100c0000)
+
+#define IO_CTL_REG_BASE           IO_DEVICE_ADDR(0x10FF0000)
+
+#define GPIO_REG_BASE             IO_DEVICE_ADDR(0x120b0000)
+#define GPIO0_REG_BASE            (GPIO_REG_BASE + 0x0000)
+#define GPIO1_REG_BASE            (GPIO_REG_BASE + 0x1000)
+#define GPIO2_REG_BASE            (GPIO_REG_BASE + 0x2000)
+#define GPIO3_REG_BASE            (GPIO_REG_BASE + 0x3000)
+#define GPIO4_REG_BASE            (GPIO_REG_BASE + 0x4000)
+#define GPIO5_REG_BASE            (GPIO_REG_BASE + 0x5000)
+#define GPIO6_REG_BASE            (GPIO_REG_BASE + 0x6000)
+#define GPIO7_REG_BASE            (GPIO_REG_BASE + 0x7000)
+#define GPIO8_REG_BASE            (GPIO_REG_BASE + 0x8000)
+#define GPIO9_REG_BASE            (GPIO_REG_BASE + 0x9000)
+
+#define SPI0_REG_BASE             IO_DEVICE_ADDR(0x12070000)
+#define SPI1_REG_BASE             IO_DEVICE_ADDR(0x12071000)
+
+#define I2C0_REG_PBASE            0x12060000
+#define I2C1_REG_PBASE            0x12061000
+#define I2C2_REG_PBASE            0x12062000
+#define I2C0_REG_BASE             IO_DEVICE_ADDR(0x12060000)
+#define I2C1_REG_BASE             IO_DEVICE_ADDR(0x12061000)
+#define I2C2_REG_BASE             IO_DEVICE_ADDR(0x12062000)
+
+#define UART4_REG_PBASE           0x40010000  /* stm32mp157 uart4 */
+
+#define UART4_REG_BASE            IO_DEVICE_ADDR(UART4_REG_PBASE)
+
+ 
+#define UART0_REG_BASE            IO_DEVICE_ADDR(UART0_REG_PBASE)
+#define UART1_REG_BASE            IO_DEVICE_ADDR(0x12041000)
+#define UART2_REG_BASE            IO_DEVICE_ADDR(0x12042000)
+
+//#define UART0_REG_PBASE           0x12040000
+#define UART1_REG_PBASE           0x12041000
+#define UART2_REG_PBASE           0x12042000
+
+#if (CONSOLE_UART == UART0)
+    #define UART_BASE             UART0_REG_BASE
+    #define UART0_INT_NUM    NUM_HAL_INTERRUPT_UART0
+#elif (CONSOLE_UART == UART1)
+    #define UART_BASE             UART1_REG_BASE
+    #define UART0_INT_NUM    NUM_HAL_INTERRUPT_UART1
+#elif (CONSOLE_UART == UART2)
+    #define UART_BASE             UART2_REG_BASE
+    #define UART0_INT_NUM    NUM_HAL_INTERRUPT_UART2
+#endif
+
+#define MISC_REG_BASE             IO_DEVICE_ADDR(0x12028000)
+#define SYS_CTRL_REG_BASE         IO_DEVICE_ADDR(0x12020000)
+#define CRG_REG_BASE              IO_DEVICE_ADDR(0x12010000)
+
+#define TIMER0_ENABLE             BIT(16)
+#define TIMER1_ENABLE             BIT(17)
+#define TIMER2_ENABLE             BIT(18)
+#define TIMER3_ENABLE             BIT(19)
+
+#define TIMER0_REG_BASE           IO_DEVICE_ADDR(0x12000000)
+#define TIMER1_REG_BASE           IO_DEVICE_ADDR(0x12000020)
+#define TIMER2_REG_BASE           IO_DEVICE_ADDR(0x12001000)
+#define TIMER3_REG_BASE           IO_DEVICE_ADDR(0x12001020)
+
+#define TIMER_TICK_REG_BASE       TIMER0_REG_BASE   /* timer for tick */
+#define TIMER_TICK_ENABLE         TIMER0_ENABLE
+#define TIMER_TIME_REG_BASE       TIMER1_REG_BASE   /* timer for time */
+#define TIMER_TIME_ENABLE         TIMER1_ENABLE
+#define HRTIMER_TIMER_REG_BASE    TIMER3_REG_BASE /* timer for hrtimer */
+#define HRTIMER_TIMER_ENABLE      TIMER3_ENABLE
+
+#define DDR_MEM_BASE              0x40000000
+#define CACHE_ALIGNED_SIZE        64
+
+#define write_reg_bit(value, offset, addr) ({ \
+        unsigned long t, mask; \
+        mask = 1 << (offset); \
+        t = GET_UINT32(addr); \
+        t &= ~mask;            \
+        t |= (value << (offset)) & mask; \
+        WRITE_UINT32(t, addr);   \
+    })
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/board/include/board.h openharmony_100ask/vendor/st/stm32mp157/board/include/board.h
--- openharmony/vendor/st/stm32mp157/board/include/board.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/board/include/board.h	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __BOARD_CONFIG_H__
+#define __BOARD_CONFIG_H__
+
+#include "menuconfig.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+/* physical memory base and size */
+#define DDR_MEM_ADDR            0xC0000000
+#define DDR_MEM_SIZE            0x1C000000   /* 448M for os, reseved (512-448) for ramfs and framebuffer */
+
+#define DDR_RAMFS_ADDR (DDR_MEM_ADDR + DDR_MEM_SIZE)
+#define DDR_RAMFS_SIZE 0x4000000  /* 60M for ramfs, 4M for lcd */
+
+#define LCD_FB_BASE    (DDR_RAMFS_ADDR + DDR_RAMFS_SIZE)
+#define LCD_FB_SIZE    0x400000  /* 4M */
+
+/* Peripheral register address base and size */
+#define PERIPH_PMM_BASE         0x40000000
+#define PERIPH_PMM_SIZE         0x20000000
+
+/* GIC base and size : 1M-align */
+#define GIC_PHY_BASE         0xA0000000
+#define GIC_PHY_SIZE         0xA0100000
+
+#define KERNEL_VADDR_BASE       0x40000000
+#define KERNEL_VADDR_SIZE       DDR_MEM_SIZE
+
+#define SYS_MEM_BASE            DDR_MEM_ADDR
+#define SYS_MEM_SIZE_DEFAULT    0x2000000
+#define SYS_MEM_END             (SYS_MEM_BASE + SYS_MEM_SIZE_DEFAULT)
+
+#define EXC_INTERACT_MEM_SIZE        0x100000
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/board/include/clock.h openharmony_100ask/vendor/st/stm32mp157/board/include/clock.h
--- openharmony/vendor/st/stm32mp157/board/include/clock.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/board/include/clock.h	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __HISOC_CLOCK_H__
+#define __HISOC_CLOCK_H__
+
+#include "asm/platform.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define    PERI_CRG12        (CRG_REG_BASE + 0x30)
+
+/*-----------------------------------------------------------------------
+ * cpu_init configuration
+ * if bit[13:12] = 1b, AXI = 200M
+ *----------------------------------------------------------------------*/
+/*lint -e160 */
+#define get_bus_clk() 50000000
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/board/include/platform_config.h openharmony_100ask/vendor/st/stm32mp157/board/include/platform_config.h
--- openharmony/vendor/st/stm32mp157/board/include/platform_config.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/board/include/platform_config.h	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __PLATFORM_CONFIG_H__
+#define __PLATFORM_CONFIG_H__
+
+#include "clock.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define LOSCFG_PLATFORM_HWI_LIMIT       96
+#define OS_SYS_CLOCK                    50000000
+#define LOSCFG_BASE_CORE_TICK_HW_TIME   YES
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/board/include/reset_shell.h openharmony_100ask/vendor/st/stm32mp157/board/include/reset_shell.h
--- openharmony/vendor/st/stm32mp157/board/include/reset_shell.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/board/include/reset_shell.h	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _RESET_SHELL_H
+#define _RESET_SHELL_H
+#include "los_task.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+
+typedef VOID* (*STORAGE_HOOK_FUNC)(VOID*);
+
+typedef struct tagHookFuncNode {
+    STORAGE_HOOK_FUNC  pHandler;
+    VOID *pParam;
+    struct tagHookFuncNode *pNext;
+}Hook_Func_Node;
+
+extern Hook_Func_Node *g_hook_func_node;
+
+UINT32 osReHookFuncAdd(STORAGE_HOOK_FUNC handler, VOID *param);
+UINT32 osReHookFuncDel(STORAGE_HOOK_FUNC handler);
+VOID osReHookFuncHandle(VOID);
+extern void cmd_reset(void);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/board/include/spinor.h openharmony_100ask/vendor/st/stm32mp157/board/include/spinor.h
--- openharmony/vendor/st/stm32mp157/board/include/spinor.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/board/include/spinor.h	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __HISOC_SPINOR_H__
+#define __HISOC_SPINOR_H__
+
+#include "asm/platform.h"
+#include "asm/io.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define PERI_CRG48                (CRG_REG_BASE + 0x00C0)
+#define PERI_CRG48_RST            (1 << 0)
+#define PERI_CRG48_CLKEN            (1 << 1)
+#define PERI_CRG48_CLK_24M            (0 << 2)
+#define PERI_CRG48_CLK_75M            ((0 << 3) | (1 << 2))
+#define PERI_CRG48_CLK_125M            ((1 << 2) | (1 << 3))
+
+#define SFC_ADDR_MODE_REG            (0x8C)
+#define SFC_ADDR_MODE_MASK            (0x80)
+#define SFC_CLSEL_MASK                (0xC)
+#define SFC_PERI_CLKDIV1_SHIFT            (28)
+#define SFC_PERI_CLKDIV1_MASK            (0xF)
+
+/*****************************************************************************/
+#undef GET_SFC_ADDR_MODE
+#define GET_SFC_ADDR_MODE ({ \
+    int start_up_mode = 0; \
+    start_up_mode = readl(IO_ADDRESS(SYS_CTRL_REG_BASE + SFC_ADDR_MODE_REG)); \
+    start_up_mode &= SFC_ADDR_MODE_MASK; \
+    start_up_mode; })
+
+/*****************************************************************************/
+static inline void hisfc350_set_system_clock(unsigned clock, int clk_en)
+{
+    unsigned int regval = readl(PERI_CRG48);
+
+    regval = regval & (~SFC_CLSEL_MASK);
+
+    if (clock) {
+        regval &= ~SFC_CLSEL_MASK;
+        regval |= clock & SFC_CLSEL_MASK;
+    } else {
+        regval &= ~SFC_CLSEL_MASK;
+        regval |= PERI_CRG48_CLK_24M; /* Default Clock */
+    }
+
+    if (clk_en)
+        regval |= PERI_CRG48_CLKEN;
+
+    if (regval != readl(PERI_CRG48))
+        writel(regval, (PERI_CRG48));
+}
+
+/*****************************************************************************/
+static inline void hisfc350_get_best_clock(unsigned int *clock)
+{
+    int ix;
+    int clk_reg;
+
+#define CLK_2X(_clk)    (((_clk) + 1) >> 1)
+    unsigned int sysclk[] = {
+        CLK_2X(24),    PERI_CRG48_CLK_24M,
+        CLK_2X(75),    PERI_CRG48_CLK_75M,
+        CLK_2X(125),    PERI_CRG48_CLK_125M,
+        0, 0,
+    };
+#undef CLK_2X
+
+    clk_reg = PERI_CRG48_CLK_24M;
+    for (ix = 0; sysclk[ix]; ix += 2) {
+        if (*clock < sysclk[ix])
+            break;
+        clk_reg = sysclk[ix + 1];
+    }
+
+    *clock = clk_reg;
+}
+
+/*****************************************************************************/
+#ifdef CONFIG_HISFC350_SHOW_CYCLE_TIMING
+static inline char * hisfc350_get_clock_str(unsigned int clk_reg)
+{
+    static char buffer[40];
+
+    /* calculate reference PERI_CLKDIV1[31:28] */
+    SFC_PR(BT_DBG, "clk_reg=0x%0x.\n", clk_reg);
+    clk_reg = 216 / ((clk_reg >> SFC_PERI_CLKDIV1_SHIFT)
+                & SFC_PERI_CLKDIV1_MASK);
+    (VOID)sprintf_s(buffer, sizeof(buffer), "%dM", clk_reg);
+
+    return buffer;
+}
+#endif /* CONFIG_PERI_SHOW_CYCLE_TIMING */
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+
+#endif
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/board/include/uart.h openharmony_100ask/vendor/st/stm32mp157/board/include/uart.h
--- openharmony/vendor/st/stm32mp157/board/include/uart.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/board/include/uart.h	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef __HISOC_UART_H__
+#define __HISOC_UART_H__
+
+#include "asm/platform.h"
+#include "los_typedef.h"
+#include "los_base.h"
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define CONFIG_UART0_BAUDRATE   115200
+#define CONFIG_UART_CLK_INPUT   (24000000) // 24M or 6M
+
+#define UART0                   0
+#define UART1                   1
+#define UART2                   2
+
+#define UART0_ENABLE  1
+#define UART1_ENABLE  1
+#define UART2_ENABLE  1
+
+#define UART0_DMA_RX_PERI       4
+#define UART1_DMA_RX_PERI       6
+#define UART2_DMA_RX_PERI       8
+
+#define uart_pin_mux_cfg(uart_num) ({ \
+        if (UART0 == uart_num) {} \
+        else if (UART1 == uart_num) { \
+        WRITE_UINT16(0x01, IO_MUX_REG_BASE + 0x07C); \
+        WRITE_UINT16(0x01, IO_MUX_REG_BASE + 0x084); \
+        } \
+        else if (UART2 == uart_num) { \
+        WRITE_UINT16(0x01, IO_MUX_REG_BASE + 0x088); \
+        WRITE_UINT16(0x01, IO_MUX_REG_BASE + 0x08C); \
+        } \
+        else if (UART3 ==uart_num) { \
+        WRITE_UINT16(0x02, IO_MUX_REG_BASE + 0x078); \
+        WRITE_UINT16(0x02, IO_MUX_REG_BASE + 0x080); \
+        } \
+        })
+#define  uart_clk_cfg(uart_num, flag)  ({ \
+        unsigned int tmp = 0; \
+        tmp = GET_UINT32(CRG_REG_BASE + 0x0198); \
+        if (flag) \
+            tmp |= (1<<(uart_num + 24)); \
+        else \
+            tmp &= ~(1<<(uart_num + 24)); \
+        WRITE_UINT32(tmp, CRG_REG_BASE + 0x0198); \
+        })
+#define  get_uart_dma_peri(uart_num) ({ \
+        unsigned int peri_num = -1; \
+        if (UART0 == uart_num) \
+        peri_num = UART0_DMA_RX_PERI; \
+        else if (UART1 == uart_num) \
+        peri_num = UART1_DMA_RX_PERI; \
+        else if (UART2 == uart_num) \
+        peri_num = UART2_DMA_RX_PERI; \
+        else if (UART3 == uart_num) \
+        peri_num = UART3_DMA_RX_PERI; \
+        peri_num; \
+        })
+
+
+#define TTYS0                               "/dev/ttyS0"
+
+#define UART4   0
+#define CONSOLE_UART                        UART4
+
+#define CONSOLE_UART_BAUDRATE               115200
+#define UART_NUM    4
+
+#define TTY_DEVICE				  "/dev/uartdev-0"
+#define UART_REG_BASE			  UART4_REG_BASE
+#define NUM_HAL_INTERRUPT_UART	  NUM_HAL_INTERRUPT_UART4  /* TODO,100ask */
+
+
+#ifdef LOSCFG_PLATFORM_HISI_AMP
+#undef TTY_DEVICE
+#define TTY_DEVICE                "/dev/virt-tty"
+#endif
+
+typedef struct {
+    UINT32 base;
+    INT32 msec_timeout;
+    int isr_vector;
+} channel_data_t;
+
+extern void uart_init(void);
+extern void uart_interrupt_unmask(void);
+extern int uart_hwiCreate(void);
+extern UINT8 uart_getc(void);
+extern char uart_fputc(char c, void *f);
+
+extern UINT32 UartPutsReg(UINTPTR base, const CHAR *s, UINT32 len, BOOL isLock);
+extern VOID UartPuts(const CHAR *s, UINT32 len, BOOL isLock);
+
+#define UART_WITHOUT_LOCK 0
+#define UART_WITH_LOCK    1
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/board/Makefile openharmony_100ask/vendor/st/stm32mp157/board/Makefile
--- openharmony/vendor/st/stm32mp157/board/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/board/Makefile	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,9 @@
+include $(LITEOSTOPDIR)/config.mk
+
+MODULE_NAME := $(notdir $(shell pwd))
+
+LOCAL_SRCS :=  board.c bsd_board.c
+
+LOCAL_FLAGS :=  -I$(LITEOSTOPDIR)/../../vendor/st/stm32mp157/driver/stm32mp157-uart
+
+include $(MODULE)
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/config/device_info/device_info.hcs openharmony_100ask/vendor/st/stm32mp157/config/device_info/device_info.hcs
--- openharmony/vendor/st/stm32mp157/config/device_info/device_info.hcs	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/config/device_info/device_info.hcs	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,60 @@
+ root {
+    device_info {
+        match_attr = "hdf_manager";
+        template host {
+            hostName = "";
+            priority = 100;
+            template device{
+                template deviceNode {
+                    policy = 0;
+                    priority = 100;
+                    preload = 0;
+                    permission = 0664;
+                    moduleName = "";
+                    serviceName = "";
+                    deviceMatchAttr = "";
+                }
+            }
+        }
+        platform :: host {
+            hostName = "platform_host";
+            priority = 50;
+
+           device_hello :: device {
+                device0 :: deviceNode {
+                    policy = 2;
+                    priority = 50;
+                    permission = 0644;
+                    moduleName = "HDF_PLATFORM_HELLO";
+                    serviceName = "hello_service";
+                }
+            }
+
+            device_i2c :: device {
+                device0 :: deviceNode {
+                    policy = 1;
+                    priority = 50;
+                    permission = 0644;
+                    moduleName = "HDF_PLATFORM_I2C";
+                    serviceName = "HDF_PLATFORM_I2C_0";
+                    deviceMatchAttr = "nxp_imx6ull_i2c_0";
+                }
+            }
+           device_touchscreen :: device {
+                device0 :: deviceNode {
+                    policy = 2;
+                    priority = 100;
+                    preload = 0;
+                    permission = 0666;
+                    moduleName = "HDF_TOUCHSCREEN";
+                    serviceName = "HDF_TOUCHSCREEN";
+                }
+            }
+
+        }
+        storage :: host {
+        }
+        media :: host {
+        }
+    }
+}
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/config/hdf.hcs openharmony_100ask/vendor/st/stm32mp157/config/hdf.hcs
--- openharmony/vendor/st/stm32mp157/config/hdf.hcs	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/config/hdf.hcs	2020-10-31 00:27:40.764668170 +0800
@@ -0,0 +1,6 @@
+//#include "device_info/device_info.hcs"
+//#include "i2c/i2c_config.hcs"
+
+root {
+    module = "hisilicon,hi35xx_chip";
+}
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/config/i2c/i2c_config.hcs openharmony_100ask/vendor/st/stm32mp157/config/i2c/i2c_config.hcs
--- openharmony/vendor/st/stm32mp157/config/i2c/i2c_config.hcs	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/config/i2c/i2c_config.hcs	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,21 @@
+root {
+    platfrom {
+        i2c_config {
+            template i2c_controller {
+                bus = 0;
+                match_attr = "";
+                reg_pbase = 0x021A4000;
+                reg_size = 0xd1;
+                irq = 0;
+                freq = 400000;
+                clk = 50000000;
+            }
+
+            controller_0x021A4000 :: i2c_controller {
+                bus = 0;
+                match_attr = "nxp_imx6ull_i2c_0";
+            }
+
+        }
+    }
+}
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/config/Makefile openharmony_100ask/vendor/st/stm32mp157/config/Makefile
--- openharmony/vendor/st/stm32mp157/config/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/config/Makefile	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,9 @@
+# Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
+
+include $(LITEOSTOPDIR)/../../drivers/hdf/lite/lite.mk
+
+MODULE_NAME := hdf_config
+
+LOCAL_PLATFORM_HCS_SRC := hdf.hcs
+
+include $(HDF_DRIVER)
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/hello/hello_drv.c openharmony_100ask/vendor/st/stm32mp157/driver/hello/hello_drv.c
--- openharmony/vendor/st/stm32mp157/driver/hello/hello_drv.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/hello/hello_drv.c	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,124 @@
+
+
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: ft6236 touch driver implement.
+ * Author: zhaihaipeng
+ * Create: 2020-07-25
+ */
+
+#include <stdlib.h>
+#include <asm/io.h>
+#include <fs/fs.h>
+#include <fs_poll_pri.h>
+#include <los_queue.h>
+#include <poll.h>
+#include <user_copy.h>
+#include <securec.h>
+#include "gpio_if.h"
+#include "hdf_device_desc.h"
+#include "hdf_log.h"
+#include "osal_irq.h"
+#include "osal_mem.h"
+#include "osal_time.h"
+
+
+static int g_hello_val = 0x12345678;
+
+
+static int hello_open(FAR struct file *filep)
+{
+    HDF_LOGI("%s: called", __func__);
+    if (filep == NULL) {
+        HDF_LOGE("%s: fliep is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    return HDF_SUCCESS;
+}
+
+static int hello_close(FAR struct file *filep)
+{
+    HDF_LOGI("%s: called", __func__);
+
+    if (filep == NULL) {
+        HDF_LOGE("%s: fliep is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    return HDF_SUCCESS;
+}
+
+static ssize_t hello_read(FAR struct file *filep, FAR char *buffer, size_t buflen)
+{
+	if (buflen == 4) {
+		LOS_ArchCopyToUser(buffer, &g_hello_val, 4);
+		return 4;
+	}
+	return 0;
+}
+
+static const struct file_operations_vfs g_helloDevOps = {
+    .open   = hello_open,
+    .close  = hello_close,
+    .read   = hello_read,
+    .write  = NULL,
+    .seek   = NULL,
+    .ioctl  = NULL,
+    .mmap   = NULL,
+    .unlink = NULL,
+};
+
+
+int32_t hello_dispatch(struct HdfDeviceIoClient *client, int cmdId, struct HdfSBuf *data, struct HdfSBuf *reply)
+{
+    (void)client;
+    (void)cmdId;
+    if (data == NULL || reply == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_FAILURE;
+    }
+
+	if (!HdfSbufWriteInt32(reply, g_hello_val))
+	{
+        HDF_LOGE("%s: reply int32 fail", __func__);
+	}
+	
+    return HDF_SUCCESS;
+}
+
+int32_t hello_bind(struct HdfDeviceObject *object)
+{
+    if (object == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    static struct IDeviceIoService service = {
+        .object = {0},
+        .Dispatch = hello_dispatch,
+    };
+    object->service = &service;
+    return HDF_SUCCESS;
+}
+
+int hello_init(struct HdfDeviceObject *object)
+{
+    (void)object;
+    HDF_LOGI("%s: enter", __func__);
+    int ret = register_driver("/dev/hello", &g_helloDevOps, 0666, NULL);
+    if (ret != 0) {
+        HDF_LOGE("%s: register hello dev failed, ret %d", __func__, ret);
+        return HDF_FAILURE;
+    }
+    HDF_LOGI("%s: exit succ", __func__);
+    return HDF_SUCCESS;
+
+}
+
+struct HdfDriverEntry g_HelloDevEntry = {
+    .moduleVersion = 1,
+    .moduleName = "HDF_PLATFORM_HELLO",
+    .Bind = hello_bind,
+    .Init = hello_init,
+};
+
+HDF_INIT(g_HelloDevEntry);
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/hello/Makefile openharmony_100ask/vendor/st/stm32mp157/driver/hello/Makefile
--- openharmony/vendor/st/stm32mp157/driver/hello/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/hello/Makefile	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,17 @@
+include $(LITEOSTOPDIR)/config.mk
+include $(LITEOSTOPDIR)/../../drivers/hdf/lite/lite.mk
+
+MODULE_NAME := $(notdir $(shell pwd))
+
+LOCAL_SRCS :=  hello_drv.c
+
+LOCAL_FLAGS :=  -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/osal \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/core \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/ability/sbuf/include \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/utils/include \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/lite/include/host
+
+LOCAL_CFLAGS += -fstack-protector-strong
+
+include $(HDF_DRIVER)
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/common/BUILD.gn openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/BUILD.gn
--- openharmony/vendor/st/stm32mp157/driver/mtd/common/BUILD.gn	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/BUILD.gn	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,42 @@
+# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("drivers_mtd_common") {
+
+    sources = [
+        "src/common.c",
+        "src/mtd_list.c",
+        "src/mtdblock.c",
+        "src/mtdchar.c",
+    ]
+
+    include_dirs = [
+        "include",
+    ]
+}
\ No newline at end of file
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/common/include/hifmc_common.h openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/include/hifmc_common.h
--- openharmony/vendor/st/stm32mp157/driver/mtd/common/include/hifmc_common.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/include/hifmc_common.h	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,306 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __HIFMC_COMMON_H__
+#define __HIFMC_COMMON_H__
+
+/* HIFMC ECCTYPE REG CONFIG */
+enum hifmc_ecc_reg {
+    hifmc_ecc_0bit   = 0x00,
+    hifmc_ecc_8bit   = 0x01,
+    hifmc_ecc_16bit  = 0x02,
+    hifmc_ecc_24bit  = 0x03,
+    hifmc_ecc_28bit  = 0x04,
+    hifmc_ecc_40bit  = 0x05,
+    hifmc_ecc_64bit  = 0x06,
+};
+
+/* HIFMC PAGESIZE REG CONFIG */
+enum hifmc_page_reg {
+    hifmc_pagesize_2K    = 0x0,
+    hifmc_pagesize_4K    = 0x1,
+    hifmc_pagesize_8K    = 0x2,
+    hifmc_pagesize_16K   = 0x3,
+};
+
+enum hifmc_page_reg hifmc_page_type2reg(int type);
+int hifmc_page_reg2type(enum hifmc_page_reg reg);
+enum hifmc_ecc_reg hifmc_ecc_type2reg(int type);
+int hifmc_ecc_reg2type(enum hifmc_ecc_reg reg);
+
+/* HIFMC REG */
+/*****************************************************************************/
+#define FMC_CFG                             0x00
+#define FMC_CFG_SPI_NAND_SEL(_type)         (((_size) & 0x3) << 11)
+#define FMC_CFG_SPI_NOR_ADDR_MODE(_mode)    ((_mode) << 10)
+#define FMC_CFG_BLOCK_SIZE(_size)           (((_size) & 0x3) << 8)
+#define FMC_CFG_ECC_TYPE(_type)             (((_type) & 0x7) << 5)
+#define FMC_CFG_PAGE_SIZE(_size)            (((_size) & 0x3) << 3)
+#define FMC_CFG_FLASH_SEL(_type)            (((_type) & 0x3) << 1)
+#define FMC_CFG_OP_MODE(_mode)              ((_mode) & 0x1)
+
+#define SPI_NOR_ADDR_MODE_3_BYTES           0x0
+#define SPI_NOR_ADDR_MODE_4_BYTES           0x1
+
+#define FMC_SPI_NOR_ADDR_MODE_SHIFT             10
+#define FMC_SPI_NOR_ADDR_MODE_MASK              (0x1 << FMC_SPI_NOR_ADDR_MODE_SHIFT)
+
+#define ECC_TYPE_SHIFT                      5
+#define ECC_TYPE_MASK                       (0x7 << ECC_TYPE_SHIFT)
+
+#define HFMC_PAGE_SHIFT                     3
+#define PAGE_SIZE_MASK                      (0x3 << HFMC_PAGE_SHIFT)
+
+#define FLASH_TYPE_SPI_NOR                  0x0
+#define FLASH_TYPE_SPI_NAND                 0x1
+#define FLASH_TYPE_NAND                     0x2
+#define FLASH_TYPE_DEFAULT                  0x3
+#define FLASH_SEL_SHIFT                     1
+#define FLASH_SEL_MASK                      (0x3 << FLASH_SEL_SHIFT)
+
+#define OP_MODE_BOOT                        0x0
+#define OP_MODE_NORMAL                      0x1
+#define OP_MODE_MASK                        0x1
+
+/*****************************************************************************/
+#define FMC_GLOBAL_CFG                      0x04
+#define FMC_GLOBAL_CFG_WP_ENABLE            (1 << 6)
+#define FMC_GLOBAL_CFG_RANDOMIZER_EN        (1 << 2)
+#define FMC_GLOBAL_CFG_EDO_EN               (1 << 9)
+
+/*****************************************************************************/
+#define FMC_SPI_TIMING_CFG                  0x08
+#define TIMING_CFG_TCSH(_n)                 (((_n) & 0xf) << 8)
+#define TIMING_CFG_TCSS(_n)                 (((_n) & 0xf) << 4)
+#define TIMING_CFG_TSHSL(_n)                ((_n) & 0xf)
+
+#define CS_HOLD_TIME                        0x6
+#define CS_SETUP_TIME                       0x6
+#define CS_DESELECT_TIME                    0xf
+
+/*****************************************************************************/
+#define FMC_PND_PWIDTH_CFG                  0x0c
+#define PWIDTH_CFG_RW_HCNT(_n)              (((_n) & 0xf) << 8)
+#define PWIDTH_CFG_R_LCNT(_n)               (((_n) & 0xf) << 4)
+#define PWIDTH_CFG_W_LCNT(_n)               ((_n) & 0xf)
+#define RW_H_WIDTH                          (0x2)
+#define R_L_WIDTH                           (0x3)
+#define W_L_WIDTH                           (0x2)
+
+/*****************************************************************************/
+#define FMC_INT                             0x18
+#define FMC_INT_AHB_OP                      (1 << 7)
+#define FMC_INT_WR_LOCK                     (1 << 6)
+#define FMC_INT_DMA_ERR                     (1 << 5)
+#define FMC_INT_ERR_ALARM                   (1 << 4)
+#define FMC_INT_ERR_INVALID                 (1 << 3)
+#define FMC_INT_ERR_VALID                   (1 << 2)
+#define FMC_INT_OP_FAIL                     (1 << 1)
+#define FMC_INT_OP_DONE                     (1 << 0)
+
+/*****************************************************************************/
+#define FMC_INT_EN                          0x1c
+#define FMC_INT_EN_AHB_OP                   (1 << 7)
+#define FMC_INT_EN_WR_LOCK                  (1 << 6)
+#define FMC_INT_EN_DMA_ERR                  (1 << 5)
+#define FMC_INT_EN_ERR_ALARM                (1 << 4)
+#define FMC_INT_EN_ERR_INVALID              (1 << 3)
+#define FMC_INT_EN_ERR_VALID                (1 << 2)
+#define FMC_INT_EN_OP_FAIL                  (1 << 1)
+#define FMC_INT_EN_OP_DONE                  (1 << 0)
+
+/*****************************************************************************/
+#define FMC_INT_CLR                         0x20
+#define FMC_INT_CLR_AHB_OP                  (1 << 7)
+#define FMC_INT_CLR_WR_LOCK                 (1 << 6)
+#define FMC_INT_CLR_DMA_ERR                 (1 << 5)
+#define FMC_INT_CLR_ERR_ALARM               (1 << 4)
+#define FMC_INT_CLR_ERR_INVALID             (1 << 3)
+#define FMC_INT_CLR_ERR_VALID               (1 << 2)
+#define FMC_INT_CLR_OP_FAIL                 (1 << 1)
+#define FMC_INT_CLR_OP_DONE                 (1 << 0)
+#define FMC_INT_CLR_ALL                     0xff
+
+/*****************************************************************************/
+#define FMC_CMD                             0x24
+#define FMC_CMD_CMD2(_cmd)                  (((_cmd) & 0xff) << 8)
+#define FMC_CMD_CMD1(_cmd)                  ((_cmd) & 0xff)
+
+/*****************************************************************************/
+#define FMC_ADDRH                           0x28
+#define FMC_ADDRL                           0x2c
+
+/*****************************************************************************/
+#define FMC_OP_CFG                          0x30
+#define OP_CFG_FM_CS(_cs)                   ((_cs) << 11)
+#define OP_CFG_FORCE_CS_EN(_en)             ((_en) << 10)
+#define OP_CFG_MEM_IF_TYPE(_type)           (((_type) & 0x7) << 7)
+#define OP_CFG_ADDR_NUM(_addr)              (((_addr) & 0x7) << 4)
+#define OP_CFG_DUMMY_NUM(_dummy)            ((_dummy) & 0xf)
+
+/*****************************************************************************/
+#define FMC_SPI_OP_ADDR                     0x34
+
+/*****************************************************************************/
+#define FMC_DATA_NUM                        0x38
+#define FMC_DATA_NUM_CNT(_n)                ((_n) & 0x3fff)
+
+/*****************************************************************************/
+#define FMC_OP                              0x3c
+#define FMC_OP_DUMMY_EN(_en)                ((_en) << 8)
+#define FMC_OP_CMD1_EN(_en)                 ((_en) << 7)
+#define FMC_OP_ADDR_EN(_en)                 ((_en) << 6)
+#define FMC_OP_WRITE_DATA_EN(_en)           ((_en) << 5)
+#define FMC_OP_CMD2_EN(_en)                 ((_en) << 4)
+#define FMC_OP_WAIT_READY_EN(_en)           ((_en) << 3)
+#define FMC_OP_READ_DATA_EN(_en)            ((_en) << 2)
+#define FMC_OP_READ_STATUS_EN(_en)          ((_en) << 1)
+#define FMC_OP_REG_OP_START                 1
+
+/*****************************************************************************/
+#define FMC_DMA_LEN                         0x40
+#define FMC_DMA_LEN_SET(_len)               ((_len) & 0x0fffffff)
+
+/*****************************************************************************/
+#define FMC_DMA_AHB_CTRL                    0x48
+#define FMC_DMA_AHB_CTRL_DMA_PP_EN          (1 << 3)
+#define FMC_DMA_AHB_CTRL_BURST16_EN         (1 << 2)
+#define FMC_DMA_AHB_CTRL_BURST8_EN          (1 << 1)
+#define FMC_DMA_AHB_CTRL_BURST4_EN          1
+#define ALL_BURST_ENABLE                    (FMC_DMA_AHB_CTRL_BURST16_EN \
+                                            | FMC_DMA_AHB_CTRL_BURST8_EN \
+                                            | FMC_DMA_AHB_CTRL_BURST4_EN)
+
+/*****************************************************************************/
+#define FMC_DMA_SADDR_D0                    0x4c
+#define FMC_DMA_SADDRH_D0                   0x200
+#define FMC_DMA_SADDR_D1                    0x50
+#define FMC_DMA_SADDRH_D1                   0x204
+#define FMC_DMA_SADDR_D2                    0x54
+#define FMC_DMA_SADDRH_D2                   0x208
+#define FMC_DMA_SADDR_D3                    0x58
+#define FMC_DMA_SADDRH_D3                   0x20c
+#define FMC_DMA_SADDR_OOB                   0x5c
+#define FMC_DMA_SADDRH_OOB                  0x210
+#define FMC_DMA_ADDR_OFFSET                 4096
+
+/*****************************************************************************/
+#define FMC_DMA_BLK_SADDR                   0x60
+#define FMC_DMA_BLK_SADDR_SET(_addr)        ((_addr) & 0xffffff)
+
+/*****************************************************************************/
+#define FMC_DMA_BLK_LEN                     0x64
+#define FMC_DMA_BLK_LEN_SET(_len)           ((_len) & 0xffff)
+
+/*****************************************************************************/
+#define FMC_OP_CTRL                         0x68
+#define OP_CTRL_RD_OPCODE(_code)            (((_code) & 0xff) << 16)
+#define OP_CTRL_WR_OPCODE(_code)            (((_code) & 0xff) << 8)
+#define OP_CTRL_RD_OP_SEL(_op)              (((_op) & 0x3) << 4)
+#define OP_CTRL_DMA_OP(_type)               ((_type) << 2)
+#define OP_CTRL_RW_OP(_op)                  ((_op) << 1)
+#define OP_CTRL_DMA_OP_READY                1
+
+#define RD_OP_READ_ALL_PAGE                 0x0
+#define RD_OP_READ_OOB                      0x1
+#define RD_OP_BLOCK_READ                    0x2
+
+#define RD_OP_SHIFT                         4
+#define RD_OP_MASK                          (0x3 << RD_OP_SHIFT)
+
+#define OP_TYPE_DMA                         0x0
+#define OP_TYPE_REG                         0x1
+
+#define RW_OP_READ                          0x0
+#define RW_OP_WRITE                         0x1
+
+/*****************************************************************************/
+#define FMC_OP_PARA                         0x70
+#define FMC_OP_PARA_RD_OOB_ONLY             (1 << 1)
+
+/*****************************************************************************/
+#define FMC_BOOT_SET                        0x74
+#define FMC_BOOT_SET_DEVICE_ECC_EN          (1 << 3)
+#define FMC_BOOT_SET_BOOT_QUAD_EN           (1 << 1)
+
+/*****************************************************************************/
+#define FMC_STATUS                          0xac
+
+#define GET_OP                              0
+#define SET_OP                              1
+
+/*****************************************************************************/
+#define FMC_VERSION                         0xbc
+
+/*****************************************************************************/
+#define FMC_CPU_WAIT_TIMEOUT        0x800000
+#define FMC_DMA_WAIT_TIMEOUT        0xf0000000
+
+#define FMC_CMD_WAIT_CPU_FINISH(_host) \
+    do { \
+        unsigned regval, timeout = FMC_CPU_WAIT_TIMEOUT; \
+        do { \
+            regval = reg_read((_host), FMC_OP); \
+            --timeout; \
+        } while ((regval & FMC_OP_REG_OP_START) && timeout); \
+        if (!timeout) \
+            ERR_MSG(" Wait cmd cpu finish timeout!\n"); \
+    } while (0)
+
+/*****************************************************************************/
+#define FMC_DMA_WAIT_INT_FINISH(_host) \
+    do { \
+        unsigned regval, timeout = FMC_DMA_WAIT_TIMEOUT; \
+        do { \
+            regval = reg_read((_host), FMC_INT); \
+            --timeout; \
+        } while ((!(regval & FMC_INT_OP_DONE) && timeout)); \
+        if (!timeout) { \
+            ERR_MSG(" Wait dma int finish timeout!\n"); \
+        } \
+    } while (0)
+
+/*****************************************************************************/
+#define FMC_DMA_WAIT_CPU_FINISH(_host) \
+    do { \
+        unsigned regval, timeout = FMC_CPU_WAIT_TIMEOUT; \
+        do { \
+            regval = reg_read((_host), FMC_OP_CTRL); \
+            --timeout; \
+        } while ((regval & OP_CTRL_DMA_OP_READY) && timeout); \
+        if (!timeout) { \
+            ERR_MSG(" Wait dma cpu finish timeout!\n"); \
+        } \
+    } while (0)
+
+/*****************************************************************************/
+#endif /* End of __HIFMC_COMMON_H__ */
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/common/include/mtd_common.h openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/include/mtd_common.h
--- openharmony/vendor/st/stm32mp157/driver/mtd/common/include/mtd_common.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/include/mtd_common.h	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,183 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MTD_COMMON_H__
+#define __MTD_COMMON_H__
+
+#include "stdint.h"
+
+/*---------------------------------------------------------------------------*/
+/* base type macros */
+/*---------------------------------------------------------------------------*/
+#ifndef u16
+#define u16         unsigned short
+#endif
+#ifndef u32
+#define u32         unsigned int
+#endif
+#ifndef ulong
+#define ulong       unsigned long
+#endif
+
+/*---------------------------------------------------------------------------*/
+/* frequently-used macros */
+/*---------------------------------------------------------------------------*/
+#ifndef min
+#define min(x,y) (x<y?x:y)
+#endif
+#ifndef max
+#define max(x,y) (x<y?y:x)
+#endif
+#ifndef min_t
+#define min_t(t, x,y) ((t)x<(t)y?(t)x:(t)y)
+#endif
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+#endif
+
+/*---------------------------------------------------------------------------*/
+/* mtd device capacity mcaros */
+/*---------------------------------------------------------------------------*/
+#define _256B       (256)
+#define _512B       (512)
+#define _1K         (1024)
+#define _2K         (2048)
+#define _4K         (4096)
+#define _8K         (8192)
+#define _16K        (16384)
+#define _32K        (32768)
+#define _64K        (0x10000UL)
+#define _128K       (0x20000UL)
+#define _256K       (0x40000UL)
+#define _512K       (0x80000UL)
+#define _1M         (0x100000UL)
+#define _2M         (0x200000UL)
+#define _4M         (0x400000UL)
+#define _8M         (0x800000UL)
+#define _16M        (0x1000000UL)
+#define _32M        (0x2000000UL)
+#define _64M        (0x4000000UL)
+#define _128M       (0x8000000UL)
+#define _256M       (0x10000000UL)
+#define _512M       (0x20000000UL)
+#define _1G         (0x40000000ULL)
+#define _2G         (0x80000000ULL)
+#define _4G         (0x100000000ULL)
+#define _8G         (0x200000000ULL)
+#define _16G        (0x400000000ULL)
+#define _64G        (0x1000000000ULL)
+#define INFINITE    (0xFFFFFFFF)
+/*---------------------------------------------------------------------------*/
+/* mtd device print control mcaros */
+/*---------------------------------------------------------------------------*/
+#include "los_printf.h"
+#include "asm/io.h"
+
+#define DISABLE     0
+#define ENABLE      1
+
+#define READ        0
+#define WRITE       1
+
+#define MTD_REG_DEBUG DISABLE
+//#define MTD_REG_DEBUG ENABLE
+
+#define mtd_trace(debug, msg...) do { \
+    if (debug == ENABLE) { \
+        dprintf("%s:%d: ", __func__, __LINE__); \
+        dprintf(msg); \
+        dprintf("\n"); \
+    } \
+} while (0)
+
+#define mtd_readl(addr) ({unsigned int reg = readl((UINTPTR)addr); \
+        mtd_trace(MTD_REG_DEBUG, "readl(0x%p) = 0x%08X", (UINTPTR)addr, reg); \
+        reg; })
+
+#define mtd_writel(v, addr) do { \
+    writel(v, (UINTPTR)addr); \
+    mtd_trace(MTD_REG_DEBUG, "writel(0x%p) = 0x%08X",\
+            (UINTPTR)addr, (unsigned int)(v)); \
+} while (0)
+
+/*****************************************************************************/
+#define INIT_DBG      0        /* Init  debug print */
+#define ER_DBG        0        /* Erase debug print */
+#define WR_DBG        0        /* Write debug print */
+#define RD_DBG        0        /* Read  debug print */
+
+#define DB_BUG(fmt, args...) \
+    do { \
+        dprintf("%s(%d): BUG: " fmt, __FILE__, __LINE__, ##args); \
+        __asm("b ."); \
+    } while (0)
+
+#define DBG_MSG(_fmt, arg...) \
+    dprintf("%s(%d): " _fmt, __func__, __LINE__, ##arg);
+
+#define ERR_MSG(_fmt, arg...) \
+    dprintf("%s(%d): Error:" _fmt, __func__, __LINE__, ##arg);
+
+#define WARN_MSG(_fmt, arg...) \
+    dprintf("%s(%d): Warning:" _fmt, __func__, __LINE__, ##arg);
+
+#define INFO_MSG(_fmt, arg...) \
+    dprintf(_fmt, ##arg);
+
+#define MTD_PR(_type, _fmt, arg...) \
+    do { \
+        if (_type) \
+            DBG_MSG(_fmt, ##arg) \
+    } while (0)
+
+/* function and variable declaration */
+
+char *ulltostr(unsigned long long size);
+int ffs(int x);
+void mtd_dma_cache_inv(void *addr, unsigned int size);
+void mtd_dma_cache_clean(void *addr, unsigned int size);
+
+extern const struct file_operations_vfs g_mtdchar_fops;
+extern const struct block_operations g_dev_spinor_ops;
+extern const struct block_operations g_dev_nand_ops;
+
+static inline const struct file_operations_vfs * GetMtdCharFops(void)
+{
+    return &g_mtdchar_fops;
+}
+static inline const struct block_operations * GetDevSpinorOps(void)
+{
+	return &g_dev_spinor_ops;
+}
+
+#endif /* End of __MTD_COMMON_H__ */
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/common/include/spi_common.h openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/include/spi_common.h
--- openharmony/vendor/st/stm32mp157/driver/mtd/common/include/spi_common.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/include/spi_common.h	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,402 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SPI_COMMON_H__
+#define __SPI_COMMON_H__
+
+#define FEATURE_ECC_ENABLE                  (1 << 4)
+#define FEATURE_QE_ENABLE                   (1 << 0)
+/*****************************************************************************/
+
+#define STATUS_P_FAIL_MASK                  (1 << 3)
+#define STATUS_E_FAIL_MASK                  (1 << 2)
+#define STATUS_WEL_MASK                     (1 << 1)
+#define STATUS_OIP_MASK                     (1 << 0)
+
+/*****************************************************************************/
+#define FEATURES_OP_ADDR_NUM                1
+#define STD_OP_ADDR_NUM                     3
+
+/*****************************************************************************/
+#define SPI_IF_TYPE_STD         0x0
+#define SPI_IF_TYPE_DUAL        0x1
+#define SPI_IF_TYPE_DIO         0x2
+#define SPI_IF_TYPE_QUAD        0x3
+#define SPI_IF_TYPE_QIO         0x4
+
+#define SPI_IF_READ_STD         (0x01)
+#define SPI_IF_READ_FAST        (0x02)
+#define SPI_IF_READ_DUAL        (0x04)
+#define SPI_IF_READ_DUAL_ADDR       (0x08)
+#define SPI_IF_READ_QUAD        (0x10)
+#define SPI_IF_READ_QUAD_ADDR       (0x20)
+#define SPI_IF_READ_QUAD_DTR        (0x40)
+#define  spi_is_quad(spi) \
+        (((SPI_IF_TYPE_QUAD == spi->read->iftype) \
+        || (SPI_IF_TYPE_QIO == spi->read->iftype) \
+        || (SPI_IF_TYPE_QUAD == spi->write->iftype) \
+        || (SPI_IF_TYPE_QIO == spi->write->iftype))?1:0)
+
+#define SPI_IF_WRITE_STD        (0x01)
+#define SPI_IF_WRITE_DUAL       (0x02)
+#define SPI_IF_WRITE_DUAL_ADDR      (0x04)
+#define SPI_IF_WRITE_QUAD       (0x08)
+#define SPI_IF_WRITE_QUAD_ADDR      (0x10)
+
+#define SPI_IF_ERASE_SECTOR_4K      (0x01)
+#define SPI_IF_ERASE_SECTOR_32K     (0x02)
+#define SPI_IF_ERASE_SECTOR_64K     (0x04)
+#define SPI_IF_ERASE_SECTOR_128K    (0x08)
+#define SPI_IF_ERASE_SECTOR_256K    (0x10)
+
+/*****************************************************************************/
+
+/*****************************************************************************/
+#define SPI_CMD_READ_STD        0x03    /* Standard read cache */
+#define SPI_CMD_READ_STD4B      0x13    /* Standard read cache 4byte mode */
+#define SPI_CMD_READ_FAST       0x0B    /* Higher speed read cache */
+#define SPI_CMD_READ_FAST4B     0x0C /* Higher speed read cache 4byte mode */
+#define SPI_CMD_READ_DUAL       0x3B    /* 2 IO read cache only date */
+#define SPI_CMD_READ_DUAL4B     0x3C /* 2 IO read cache only date 4byte mode*/
+#define SPI_CMD_READ_DUAL_ADDR  0xBB    /* 2 IO read cache date&addr */
+#define SPI_CMD_READ_DUAL_ADDR4B 0xBC /* 2 IO read cache date&addr 4byte mode */
+#define SPI_CMD_READ_QUAD       0x6B    /* 4 IO read cache only date */
+#define SPI_CMD_READ_QUAD4B     0x6C /* 4 IO read cache only date 4byte mode */
+#define SPI_CMD_READ_QUAD_ADDR  0xEB    /* 4 IO read cache date&addr */
+#define SPI_CMD_READ_QUAD_ADDR4B 0xEC /* 4 IO read cache date&addr 4byte mode */
+#define SPI_CMD_READ_QUAD_DTR       0xED    /* 4DTR MODE */
+#define SPI_CMD_READ_QUAD_DTR4B     0xEE    /* 4DTR MODE 4byte mode */
+#define SPI_CMD_READ_QUAD_DTR4B_WINBOND     0xEC    /* 4DTR MODE */
+
+#define SPI_CMD_WRITE_STD       0x02    /* Standard page program */
+#define SPI_CMD_WRITE_STD4B     0x12    /* Standard page program 4byte mode */
+#define SPI_CMD_WRITE_DUAL      0xA2    /* 2 IO program only date */
+#define SPI_CMD_WRITE_DUAL4B    0xA2    /* 2 IO program only date 4byte mode*/
+#define SPI_CMD_WRITE_DUAL_ADDR     0xD2    /* 2 IO program date&addr */
+#define SPI_CMD_WRITE_DUAL_ADDR4B   0xD2 /* 2 IO program date&addr 4byte mode */
+#define SPI_CMD_WRITE_QUAD      0x32    /* 4 IO program only date */
+#define SPI_CMD_WRITE_QUAD4B    0x34    /* 4 IO program only date 4byte mode */
+#define SPI_CMD_WRITE_QUAD_ADDR     0x38    /* 4 IO program date&addr */
+#define SPI_CMD_WRITE_QUAD_ADDR4B   0x3E /* 4 IO program date&addr 4byte mode*/
+
+#define SPI_CMD_SE_4K           0x20    /* 4KB sector Erase */
+#define SPI_CMD_SE_4K4B         0x21    /* 4KB sector Erase 4byte mode */
+#define SPI_CMD_SE_32K          0x52    /* 32KB sector Erase */
+#define SPI_CMD_SE_32K4B        0x5C    /* 32KB sector Erase 4byte mode */
+#define SPI_CMD_SE_64K          0xD8    /* 64KB sector Erase */
+#define SPI_CMD_SE_64K4B        0xDC    /* 64KB sector Erase 4byte mode */
+#define SPI_CMD_SE_128K         0xD8    /* 128KB sector Erase */
+#define SPI_CMD_SE_128K4B       0xD8    /* 128KB sector Erase 4byte mode */
+#define SPI_CMD_SE_256K         0xD8    /* 256KB sector Erase */
+#define SPI_CMD_SE_256K4B       0xD8    /* 256KB sector Erase 4byte mode */
+
+/*****************************************************************************/
+#define SET_READ_STD(_dummy_, _size_, _clk_) \
+    static struct spi_op read_std_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_STD, SPI_CMD_READ_STD, _dummy_, _size_, _clk_ }
+
+#define SET_READ_STD4B(_dummy_, _size_, _clk_) \
+    static struct spi_op read_std4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_STD, SPI_CMD_READ_STD4B, _dummy_, _size_, _clk_ }
+
+#define SET_READ_FAST(_dummy_, _size_, _clk_) \
+    static struct spi_op read_fast_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_FAST, SPI_CMD_READ_FAST, _dummy_, _size_, _clk_ }
+
+#define SET_READ_FAST4B(_dummy_, _size_, _clk_) \
+    static struct spi_op read_fast4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_FAST, SPI_CMD_READ_FAST4B, _dummy_, _size_, _clk_ }
+
+#define SET_READ_DUAL(_dummy_, _size_, _clk_) \
+    static struct spi_op read_dual_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_DUAL, SPI_CMD_READ_DUAL, _dummy_, _size_, _clk_ }
+
+#define SET_READ_DUAL4B(_dummy_, _size_, _clk_) \
+    static struct spi_op read_dual4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_DUAL, SPI_CMD_READ_DUAL4B, _dummy_, _size_, _clk_ }
+
+#define SET_READ_DUAL_ADDR(_dummy_, _size_, _clk_) \
+    static struct spi_op read_dual_addr_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_DUAL_ADDR, SPI_CMD_READ_DUAL_ADDR, _dummy_, _size_, _clk_ }
+
+#define SET_READ_DUAL_ADDR4B(_dummy_, _size_, _clk_) \
+    static struct spi_op read_dual_addr4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_DUAL_ADDR, SPI_CMD_READ_DUAL_ADDR4B, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_QUAD, SPI_CMD_READ_QUAD, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD4B(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_QUAD, SPI_CMD_READ_QUAD4B, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD_ADDR(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad_addr_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_QUAD_ADDR, SPI_CMD_READ_QUAD_ADDR, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD_ADDR4B(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad_addr4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_QUAD_ADDR, SPI_CMD_READ_QUAD_ADDR4B, _dummy_, _size_, _clk_ }
+
+#ifdef CONFIG_DTR_MODE_SUPPORT
+#define SET_READ_QUAD_DTR(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad_dtr_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_QUAD_DTR, SPI_CMD_READ_QUAD_DTR, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD_DTR4B(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad_dtr4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_READ_QUAD_DTR, SPI_CMD_READ_QUAD_DTR4B, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD_DTR4B_WINBOND(_dummy_, _size_, _clk_) \
+    static struct spi_op read_quad_dtr_winbond_##_dummy_##_size_##_clk_ = \
+    {SPI_IF_READ_QUAD_DTR, SPI_CMD_READ_QUAD_DTR4B_WINBOND, \
+        _dummy_, _size_, _clk_ }
+#endif
+
+/*****************************************************************************/
+#define SET_WRITE_STD(_dummy_, _size_, _clk_) \
+    static struct spi_op write_std_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_WRITE_STD, SPI_CMD_WRITE_STD, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_STD4B(_dummy_, _size_, _clk_) \
+    static struct spi_op write_std4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_WRITE_STD, SPI_CMD_WRITE_STD4B, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_DUAL(_dummy_, _size_, _clk_) \
+    static struct spi_op write_dual_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_WRITE_DUAL, SPI_CMD_WRITE_DUAL, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_DUAL4B(_dummy_, _size_, _clk_) \
+    static struct spi_op write_dual4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_WRITE_DUAL, SPI_CMD_WRITE_DUAL4B, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_DUAL_ADDR(_dummy_, _size_, _clk_) \
+    static struct spi_op write_dual_addr_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_DUAL_ADDR, SPI_CMD_WRITE_DUAL_ADDR, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_DUAL_ADDR4B(_dummy_, _size_, _clk_) \
+    static struct spi_op write_dual_addr4b_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_DUAL_ADDR, SPI_CMD_WRITE_DUAL_ADDR4B, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_QUAD(_dummy_, _size_, _clk_) \
+    static struct spi_op write_quad_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_WRITE_QUAD, SPI_CMD_WRITE_QUAD, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_QUAD4B(_dummy_, _size_, _clk_) \
+    static struct spi_op write_quad4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_WRITE_QUAD, SPI_CMD_WRITE_QUAD4B, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_QUAD_ADDR(_dummy_, _size_, _clk_) \
+    static struct spi_op write_quad_addr_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_QUAD_ADDR, SPI_CMD_WRITE_QUAD_ADDR, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_QUAD_ADDR4B(_dummy_, _size_, _clk_) \
+    static struct spi_op write_quad_addr4b_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_QUAD_ADDR, SPI_CMD_WRITE_QUAD_ADDR4B, _dummy_, _size_, _clk_ }
+
+/*****************************************************************************/
+#define SET_ERASE_SECTOR_4K(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_4k_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_4K, SPI_CMD_SE_4K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_4K4B(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_4k4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_4K, SPI_CMD_SE_4K4B, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_32K(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_32k_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_32K, SPI_CMD_SE_32K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_32K4B(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_32k4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_32K, SPI_CMD_SE_32K4B, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_64K(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_64k_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_64K, SPI_CMD_SE_64K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_64K4B(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_64k4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_64K, SPI_CMD_SE_64K4B, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_128K(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_128k_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_128K, SPI_CMD_SE_128K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_128K4B(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_128k4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_128K, SPI_CMD_SE_128K4B, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_256K(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_256k_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_256K, SPI_CMD_SE_256K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_256K4B(_dummy_, _size_, _clk_) \
+    static struct spi_op erase_sector_256k4b_##_dummy_##_size_##_clk_ = { \
+    SPI_IF_ERASE_SECTOR_256K, SPI_CMD_SE_256K4B, _dummy_, _size_, _clk_ }
+
+/*****************************************************************************/
+#define READ_STD(_dummy_, _size_, _clk_) read_std_##_dummy_##_size_##_clk_
+#define READ_STD4B(_dummy_, _size_, _clk_) read_std4b_##_dummy_##_size_##_clk_
+#define READ_FAST(_dummy_, _size_, _clk_) read_fast_##_dummy_##_size_##_clk_
+#define READ_FAST4B(_dummy_, _size_, _clk_) read_fast4b_##_dummy_##_size_##_clk_
+#define READ_DUAL(_dummy_, _size_, _clk_) read_dual_##_dummy_##_size_##_clk_
+#define READ_DUAL4B(_dummy_, _size_, _clk_) read_dual4b_##_dummy_##_size_##_clk_
+#define READ_DUAL_ADDR(_dummy_, _size_, _clk_) \
+        read_dual_addr_##_dummy_##_size_##_clk_
+#define READ_DUAL_ADDR4B(_dummy_, _size_, _clk_) \
+        read_dual_addr4b_##_dummy_##_size_##_clk_
+#define READ_QUAD(_dummy_, _size_, _clk_) read_quad_##_dummy_##_size_##_clk_
+#define READ_QUAD4B(_dummy_, _size_, _clk_) read_quad4b_##_dummy_##_size_##_clk_
+#define READ_QUAD_ADDR(_dummy_, _size_, _clk_) \
+        read_quad_addr_##_dummy_##_size_##_clk_
+#define READ_QUAD_ADDR4B(_dummy_, _size_, _clk_) \
+        read_quad_addr4b_##_dummy_##_size_##_clk_
+#ifdef CONFIG_DTR_MODE_SUPPORT
+#define READ_QUAD_DTR(_dummy_, _size_, _clk_) \
+        read_quad_dtr_##_dummy_##_size_##_clk_
+#define READ_QUAD_DTR4B(_dummy_, _size_, _clk_) \
+        read_quad_dtr4b_##_dummy_##_size_##_clk_
+#define READ_QUAD_DTR4B_WINBOND(_dummy_, _size_, _clk_) \
+        read_quad_dtr4b_winbond_##_dummy_##_size_##_clk_
+#endif
+
+/*****************************************************************************/
+#define WRITE_STD(_dummy_, _size_, _clk_) write_std_##_dummy_##_size_##_clk_
+#define WRITE_STD4B(_dummy_, _size_, _clk_) write_std4b_##_dummy_##_size_##_clk_
+#define WRITE_DUAL(_dummy_, _size_, _clk_) write_dual_##_dummy_##_size_##_clk_
+#define WRITE_DUAL4B(_dummy_, _size_, _clk_) write_dual4b_##_dummy_##_size_##_clk_
+#define WRITE_DUAL_ADDR(_dummy_, _size_, _clk_) \
+        write_dual_addr_##_dummy_##_size_##_clk_
+#define WRITE_DUAL_ADDR4B(_dummy_, _size_, _clk_) \
+        write_dual_addr4b_##_dummy_##_size_##_clk_
+#define WRITE_QUAD(_dummy_, _size_, _clk_) write_quad_##_dummy_##_size_##_clk_
+#define WRITE_QUAD4B(_dummy_, _size_, _clk_) write_quad4b_##_dummy_##_size_##_clk_
+#define WRITE_QUAD_ADDR(_dummy_, _size_, _clk_) \
+        write_quad_addr_##_dummy_##_size_##_clk_
+#define WRITE_QUAD_ADDR4B(_dummy_, _size_, _clk_) \
+        write_quad_addr4b_##_dummy_##_size_##_clk_
+
+/*****************************************************************************/
+#define ERASE_SECTOR_4K(_dummy_, _size_, _clk_) \
+        erase_sector_4k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_4K4B(_dummy_, _size_, _clk_) \
+        erase_sector_4k4b_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_32K(_dummy_, _size_, _clk_) \
+        erase_sector_32k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_32K4B(_dummy_, _size_, _clk_) \
+        erase_sector_32k4b_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_64K(_dummy_, _size_, _clk_) \
+        erase_sector_64k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_64K4B(_dummy_, _size_, _clk_) \
+        erase_sector_64k4b_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_128K(_dummy_, _size_, _clk_) \
+        erase_sector_128k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_128K4B(_dummy_, _size_, _clk_) \
+        erase_sector_128k4b_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_256K(_dummy_, _size_, _clk_) \
+        erase_sector_256k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_256K4B(_dummy_, _size_, _clk_) \
+        erase_sector_256k4b_##_dummy_##_size_##_clk_
+
+/*****************************************************************************/
+#define SPI_CMD_WREN            0x06    /* Write Enable */
+#define SPI_CMD_WRDI            0x04    /* Write Disable */
+
+/*****************************************************************************/
+#define SPI_CMD_WRSR            0x01    /* Write Status Register */
+#define SPI_CMD_WRSR2           0x31    /* Write Status Register-2 */
+#define SPI_CMD_WRSR3           0x11    /* Write Status Register-3 */
+
+#define SPI_CMD_RDSR            0x05    /* Read Status Register */
+#define SPI_CMD_RDSR2           0x35    /* Read Status Register-2 */
+#define SPI_CMD_RDSR3           0x15    /* Read Status Register-3 */
+
+#define SPI_CMD_RDCR            0x35    /* Read Config Register */
+
+#define SPI_CMD_RDID            0x9F    /* Read Identification */
+
+#define SPI_CMD_RD_SFDP         0x5A    /* Read SFDP */
+/*****************************************************************************/
+#define SPI_CMD_GET_FEATURES        0x0F    /* Get Features */
+#define SPI_CMD_SET_FEATURE     0x1F    /* Set Feature */
+
+#define SPI_CMD_PAGE_READ       0x13    /* Page Read to Cache */
+
+#define SPI_CMD_RESET           0xff    /* Reset the device */
+
+/*****************************************************************************/
+#define SPI_CMD_EN4B    0xB7 /* enter 4 bytes mode and set 4 byte bit as '1' */
+#define SPI_CMD_EX4B    0xE9    /* exit 4 bytes mode and clear 4 byte bit */
+
+/*****************************************************************************/
+#define MAX_SPI_OP          8
+
+/*****************************************************************************/
+/* SPI general operation parameter */
+struct spi_op {
+    unsigned char iftype;
+    unsigned char cmd;
+    unsigned char dummy;
+    unsigned int size;
+    unsigned int clock;
+};
+
+struct spi;
+/* SPI interface special operation function hook */
+struct spi_drv {
+    int (*wait_ready)(struct spi *spi);
+    int (*write_enable)(struct spi *spi);
+    int (*qe_enable)(struct spi *spi);
+    int (*bus_prepare)(struct spi *spi, int op);
+    int (*entry_4addr)(struct spi *spi, int en);
+};
+
+/* SPI interface all operation */
+struct spi {
+    char *name;
+    unsigned int cs;
+    unsigned long long chipsize;
+    unsigned long long  erasesize;
+    unsigned int addrcycle;
+
+    struct spi_op read[MAX_SPI_OP];
+    struct spi_op write[MAX_SPI_OP];
+    struct spi_op erase[MAX_SPI_OP];
+
+    void *host;
+
+    struct spi_drv *driver;
+};
+
+#endif /* __SPI_COMMON_H__ */
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/common/Makefile openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/Makefile
--- openharmony/vendor/st/stm32mp157/driver/mtd/common/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/Makefile	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,36 @@
+# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+include $(LITEOSTOPDIR)/config.mk
+
+MODULE_NAME := mtd_common
+
+LOCAL_SRCS := $(wildcard src/*.c)
+
+include $(MODULE)
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/common/src/common.c openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/src/common.c
--- openharmony/vendor/st/stm32mp157/driver/mtd/common/src/common.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/src/common.c	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "stdio.h"
+#include "los_typedef.h"
+#include "asm/platform.h"
+#include "los_base.h"
+#include "los_vm_phys.h"
+//#include "asm/dma.h"
+
+extern int snprintf_s(char *str, size_t sizeOfBuffer, size_t n, const char *fmt, ...);
+/*----------------------------------------------------------------------------*/
+/* ulltostr */
+/*----------------------------------------------------------------------------*/
+char *ulltostr(unsigned long long size)
+{
+    int ix;
+    static char buffer[20];
+    unsigned long size_long;
+    char *fmt[] = {"%u", "%uK", "%uM", "%uG", "%uT", "%uP"};
+
+    for (ix = 0; (ix < 5) && !(size & 0x3FF) && size; ix++) {
+        size = (size >> 10);
+    }
+
+    size_long = (unsigned long)size;
+
+    snprintf_s(buffer, sizeof(buffer), sizeof(buffer) - 1, fmt[ix], size_long);
+
+    return buffer;
+}
+
+/*----------------------------------------------------------------------------*/
+/* ffs */
+/*----------------------------------------------------------------------------*/
+int ffs(int x)
+{
+    int r = 1;
+    unsigned int f = (unsigned int)x;
+
+    if (!f) {
+        return 0;
+    }
+
+    if (!(f & 0xffff)) {
+        f >>= 16;
+        r += 16;
+    }
+    if (!(f & 0xff)) {
+        f >>= 8;
+        r += 8;
+    }
+    if (!(f & 0xf)) {
+        f >>= 4;
+        r += 4;
+    }
+    if (!(f & 3)) {
+        f >>= 2;
+        r += 2;
+    }
+    if (!(f & 1)) {
+        r += 1;
+    }
+    return r;
+}
+#if 0
+/*----------------------------------------------------------------------------*/
+/* mtd_dma_cache_inv */
+/*----------------------------------------------------------------------------*/
+void mtd_dma_cache_inv(void *addr, unsigned int size)
+{
+    addr = (void *)(UINTPTR)LOS_PaddrToKVaddr((PADDR_T)(UINTPTR)addr);
+
+    UINTPTR start = (UINTPTR)addr & ~(CACHE_ALIGNED_SIZE - 1);
+    UINTPTR end = (UINTPTR)addr + size;
+
+    end = ALIGN(end, CACHE_ALIGNED_SIZE);
+
+    dma_cache_inv(start, end);
+}
+
+/*----------------------------------------------------------------------------*/
+/* mtd_dma_cache_clean */
+/*----------------------------------------------------------------------------*/
+void mtd_dma_cache_clean(void *addr, unsigned int size)
+{
+    addr = (void *)(UINTPTR)LOS_PaddrToKVaddr((PADDR_T)(UINTPTR)addr);
+    UINTPTR start = (UINTPTR)addr & ~(CACHE_ALIGNED_SIZE - 1);
+    UINTPTR end = (UINTPTR)addr + size;
+
+    end = ALIGN(end, CACHE_ALIGNED_SIZE);
+
+    dma_cache_clean(start, end);
+}
+#endif
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/common/src/mtdblock.c openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/src/mtdblock.c
--- openharmony/vendor/st/stm32mp157/driver/mtd/common/src/mtdblock.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/src/mtdblock.c	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "fs/fs.h"
+#include "inode/inode.h"
+
+#include "mtd_common.h"
+static int mtdblock_open(FAR struct inode *inode_p)
+{
+    return 0;
+}
+
+static int mtdblock_close(FAR struct inode *inode_p)
+{
+    return 0;
+}
+
+static ssize_t mtdblock_read(FAR struct inode *inode_p, FAR unsigned char *buffer,
+                             unsigned long long start_sector, unsigned int nsectors)
+{
+    return 0;
+}
+
+static ssize_t mtdblock_write(FAR struct inode *inode_p, FAR const unsigned char *buffer,
+                              unsigned long long start_sector, unsigned int nsectors)
+{
+    return 0;
+}
+
+static int mtdblock_geometry(FAR struct inode *inode_p, FAR struct geometry *geometry_p)
+{
+    return 0;
+}
+
+static int mtdblock_ioctl(FAR struct inode *inode_p, int cmd, unsigned long arg)
+{
+    return 0;
+}
+
+const struct block_operations g_dev_nand_ops = {
+    .open       = mtdblock_open,
+    .close      = mtdblock_close,
+    .read       = mtdblock_read,
+    .write      = mtdblock_write,
+    .geometry   = mtdblock_geometry,
+    .ioctl      = mtdblock_ioctl,
+    .unlink     = NULL
+};
+
+const struct block_operations g_dev_spinor_ops = {
+    .open       = mtdblock_open,
+    .close      = mtdblock_close,
+    .read       = mtdblock_read,
+    .write      = mtdblock_write,
+    .geometry   = mtdblock_geometry,
+    .ioctl      = mtdblock_ioctl,
+    .unlink     = NULL
+};
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/common/src/mtdchar.c openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/src/mtdchar.c
--- openharmony/vendor/st/stm32mp157/driver/mtd/common/src/mtdchar.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/src/mtdchar.c	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,235 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_config.h"
+#if defined(LOSCFG_FS_YAFFS) || defined(LOSCFG_FS_JFFS)
+
+#include "fs/fs.h"
+#include "stdio.h"
+#include "string.h"
+#include "errno.h"
+
+#include "los_mux.h"
+#include "mtd_dev.h"
+
+#include "mtd_partition.h"
+#include "user_copy.h"
+
+/*
+ * open device interface
+ */
+static int mtdchar_open(FAR struct file *filep)
+{
+    struct inode *inode_p = filep->f_inode;
+    mtd_partition *partition = (mtd_partition *)(inode_p->i_private);
+
+    if (partition->user_num != 0) { // be opened
+        return -EBUSY;
+    }
+
+    struct MtdDev *mtd = (struct MtdDev *)(partition->mtd_info);
+    size_t block_size = mtd->eraseSize;
+
+    (void)LOS_MuxLock(&partition->lock, LOS_WAIT_FOREVER);
+
+    partition->user_num = 1;
+    filep->f_pos = partition->start_block * block_size;
+
+    (void)LOS_MuxUnlock(&partition->lock);
+
+    return ENOERR;
+}
+
+/*
+ * close device interface
+ */
+static int mtdchar_close(FAR struct file *filep)
+{
+    struct inode *inode_p = filep->f_inode;
+    mtd_partition *partition = (mtd_partition *)(inode_p->i_private);
+
+    (void)LOS_MuxLock(&partition->lock, LOS_WAIT_FOREVER);
+
+    partition->user_num = 0;
+
+    (void)LOS_MuxUnlock(&partition->lock);
+
+    return ENOERR;
+}
+
+/*
+ * read device interface
+ */
+static ssize_t mtdchar_read(FAR struct file *filep, FAR char *buffer, size_t buflen)
+{
+    struct inode *inode_p = filep->f_inode;
+    mtd_partition *partition = (mtd_partition *)(inode_p->i_private);
+
+    (void)LOS_MuxLock(&partition->lock, LOS_WAIT_FOREVER);
+
+    struct MtdDev *mtd = (struct MtdDev *)(partition->mtd_info);
+    uint64_t block_size = mtd->eraseSize;
+    uint64_t start_addr = partition->start_block * block_size;
+    uint64_t end_addr = (partition->end_block + 1) * block_size;
+
+    uint64_t retlen;
+    ssize_t ret = 0;
+
+
+    if (!buflen) {
+        ret = 0;
+        goto out1;
+    }
+
+    retlen = mtd->read(mtd, start_addr, end_addr - start_addr, buffer);
+
+    if (retlen < 0) {
+        goto out1;
+    }
+
+    filep->f_pos += retlen;
+
+    ret = (ssize_t)retlen;
+
+out1:
+    (void)LOS_MuxUnlock(&partition->lock);
+    return ret;
+}
+
+/*
+ * write device interface
+ */
+static ssize_t mtdchar_write(FAR struct file *filep, FAR const char *buffer, size_t buflen)
+{
+    struct inode *inode_p = filep->f_inode;
+    mtd_partition *partition = (mtd_partition *)(inode_p->i_private);
+
+    (void)LOS_MuxLock(&partition->lock, LOS_WAIT_FOREVER);
+
+    struct MtdDev *mtd = (struct MtdDev *)(partition->mtd_info);
+    uint64_t block_size = mtd->eraseSize;
+    uint64_t start_addr = partition->start_block * block_size;
+    uint64_t end_addr = (partition->end_block + 1) * block_size;
+    uint64_t retlen;
+    int ret = 0;
+
+    if (!buflen) {
+        ret = 0;
+        goto out1;
+    }
+
+    retlen = mtd->write(mtd, start_addr, end_addr - start_addr, buffer);
+
+    if (retlen < 0) {
+        goto out1;
+    }
+
+    filep->f_pos += retlen;
+
+    ret = (ssize_t)retlen;
+
+out1:
+    (void)LOS_MuxUnlock(&partition->lock);
+    return ret;
+}
+
+/*
+ * lseek device interface
+ */
+static off_t mtdchar_lseek(FAR struct file *filep, off_t offset, int whence)
+{
+    struct inode *inode_p = filep->f_inode;
+    mtd_partition *partition = (mtd_partition *)(inode_p->i_private);
+
+    (void)LOS_MuxLock(&partition->lock, LOS_WAIT_FOREVER);
+
+    struct MtdDev *mtd = (struct MtdDev *)(partition->mtd_info);
+    size_t block_size = mtd->eraseSize;
+    size_t end_addr = (partition->end_block + 1) * block_size;
+    size_t start_addr = partition->start_block * block_size;
+
+    switch (whence) {
+        case SEEK_SET:
+            if (offset >= 0 && (size_t)offset < end_addr - start_addr) {
+                filep->f_pos = start_addr + offset;
+                goto out1;
+            } else {
+                goto err1;
+            }
+
+        case SEEK_CUR:
+            if (offset + (size_t)filep->f_pos >= start_addr &&
+                    (size_t)(offset + filep->f_pos) < end_addr) {
+                filep->f_pos += offset;
+                goto out1;
+            } else {
+                goto err1;
+            }
+
+        case SEEK_END:
+            if (offset < 0 && offset + end_addr >= start_addr) {
+                filep->f_pos = (off_t)(offset + end_addr);
+                goto out1;
+            } else {
+                goto err1;
+            }
+
+        default:
+            goto err1;
+    }
+err1:
+    (void)LOS_MuxUnlock(&partition->lock);
+    return -EINVAL;
+out1:
+    (void)LOS_MuxUnlock(&partition->lock);
+    return filep->f_pos;
+}
+
+static ssize_t mtdchar_map(FAR struct file* filep, FAR LosVmMapRegion *region)
+{
+    PRINTK("%s %d, mmap is not support\n", __FUNCTION__, __LINE__);
+    return 0;
+}
+
+const struct file_operations_vfs g_mtdchar_fops = {
+    .open   =   mtdchar_open,
+    .close  =   mtdchar_close,
+    .read   =   mtdchar_read,
+    .write  =   mtdchar_write,
+    .seek   =   mtdchar_lseek,
+    .mmap   =   mtdchar_map,
+#ifndef CONFIG_DISABLE_POLL
+    .poll   =   NULL,
+#endif
+    .unlink =   NULL,
+};
+
+#endif
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/common/src/mtd_list.c openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/src/mtd_list.c
--- openharmony/vendor/st/stm32mp157/driver/mtd/common/src/mtd_list.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/common/src/mtd_list.c	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,114 @@
+#include "stdio.h"
+#include "stdlib.h"
+#include "string.h"
+
+typedef struct Node {
+    char *type;           /* flash type */
+    int status;           /* flash status */
+    struct MtdDev *mtd; /* mtd_info struct */
+    struct Node *next;    /* next mtd_info struct */
+} Lnode, *linklist;
+
+linklist head;
+#if 0 
+struct MtdDev *GetMtd(const char *type)
+{
+    linklist p;
+    if ((!type) || (!head)) {
+        return NULL;
+    }
+    p = head->next;
+    while (p) {
+        if (strcmp(type, p->type) == 0) {
+            p->status++;
+            return p->mtd;
+        }
+        p = p->next;
+    }
+    return NULL;
+}
+#endif
+int get_mtd_info(const char *type)
+{
+    linklist p;
+    if ((!type) || (!head)) {
+        return -1;
+    }
+    p = head->next;
+    while (p) {
+        if (strcmp(type, p->type) == 0) {
+            return 0;
+        }
+        p = p->next;
+    }
+    return -1;
+}
+int FreeMtd(struct MtdDev *mtd)
+{
+    linklist p;
+    if ((!mtd) || (!head)) {
+        return -1;
+    }
+    p = head->next;
+    while (p) {
+        if (p->mtd == mtd) {
+            p->status--;
+            return 0;
+        }
+        p = p->next;
+    }
+    return -1;
+}
+
+int del_mtd_list(struct MtdDev *mtd)
+{
+    linklist p, q;
+    if ((!mtd) || (!head)) {
+        return -1;
+    }
+    p = head->next;
+    q = head;
+    while (p) {
+        if (p->mtd == mtd) {
+            if (!p->status) {
+                q->next = p->next;
+                free(p);
+                return 0;
+            } else {
+                return -1;
+            }
+        }
+        q = p;
+        p = p->next;
+    }
+    return -1;
+}
+void add_mtd_list(char *type, struct MtdDev *mtd)
+{
+    linklist p, q;
+    if ((!mtd) || (!type) || (!head)) {
+        return;
+    }
+    p = head->next;
+    q = (linklist)zalloc(sizeof(Lnode));
+    if (!q) {
+        return;
+    }
+    q->type = type;
+    q->mtd = mtd;
+    q->status = 0;
+    head->next = q;
+    q->next = p;
+}
+int mtd_init_list(void)
+{
+    head = (linklist)zalloc(sizeof(Lnode));
+    if (!head) {
+        return -1;
+    }
+    head->next = NULL;
+    head->mtd = NULL;
+    head->type = NULL;
+    head->status = 0;
+    return 0;
+}
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/BUILD.gn openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/BUILD.gn
--- openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/BUILD.gn	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/BUILD.gn	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,44 @@
+# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+static_library("drivers_mtd_spinor") {
+
+    sources = [
+        "src/common/spinor.c",
+        "src/common/spinor_common.c",
+        "src/common/spinor_ids.c",
+        "src/common/spinor_scan.c",
+    ]
+
+    include_dirs = [
+        "../common/include",
+        "src/common",
+        "include",
+    ]
+}
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/include/spinor.h openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/include/spinor.h
--- openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/include/spinor.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/include/spinor.h	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SPINOR_H__
+#define __SPINOR_H__
+
+// #include "linux/mtd/mtd.h"
+
+struct erase_info {
+    int scrub;
+    struct erase_info *next;
+    unsigned char state;
+    unsigned long priv;
+    void (*callback) (struct erase_info *self);
+    unsigned int cell;
+    unsigned int dev;
+    unsigned long retries;
+    unsigned long time;
+    uint64_t fail_addr;
+    uint64_t len;
+    uint64_t addr;
+    struct MtdDev *mtd;
+};
+
+// int spinor_init(void);
+// void spinor_register(struct mtd_info *mtd);
+
+#endif
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/Kconfig openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/Kconfig
--- openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/Kconfig	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,29 @@
+config LOSCFG_DRIVERS_MTD_SPI_NOR
+    bool "Enable MTD spi_nor flash"
+    default y
+    depends on LOSCFG_DRIVERS_MTD
+    help
+      Answer Y to support spi_nor flash.
+choice
+    depends on  LOSCFG_DRIVERS_MTD_SPI_NOR
+    prompt "SpiNorFlash Chips"
+    default LOSCFG_DRIVERS_MTD_SPI_NOR_HISFC350
+
+config LOSCFG_DRIVERS_MTD_SPI_NOR_HISFC350
+    depends on LOSCFG_PLATFORM_HI3516A || LOSCFG_PLATFORM_HI3731
+    bool "Enable hisfc350"
+    help
+      Answer Y to support hisfc350.
+
+config LOSCFG_DRIVERS_MTD_SPI_NOR_HIFMC100
+    depends on LOSCFG_PLATFORM_HI3518EV200 || LOSCFG_PLATFORM_HI3519 || LOSCFG_PLATFORM_HI3519V101 || LOSCFG_PLATFORM_HI3559  || LOSCFG_PLATFORM_HI3516CV300 || LOSCFG_PLATFORM_HI3559AV100ES || LOSCFG_PLATFORM_HI3559AV100 || LOSCFG_PLATFORM_HI3516CV500 || LOSCFG_PLATFORM_HI3516DV300 || LOSCFG_PLATFORM_HI3516EV200 || LOSCFG_PLATFORM_HI3516EV300 || LOSCFG_PLATFORM_HI3518EV300 || LOSCFG_PLATFORM_HI3556V200 || LOSCFG_PLATFORM_HI3559V200
+    bool "Enable hifmc100"
+    help
+      Answer Y to support hifmc100.
+	  
+config LOSCFG_DRIVERS_MTD_SPI_NOR_SUNXI
+    depends on LOSCFG_PLATFORM_SUN8I
+    bool "Enable spinor sunxi"
+    help
+      Answer Y to support spinor sunxi.	 
+endchoice
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/Makefile openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/Makefile
--- openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/Makefile	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,43 @@
+# Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+include $(LITEOSTOPDIR)/config.mk
+
+MODULE_NAME := spinor_flash
+
+SRCS_HOST = $(wildcard src/$(NOR_DRIVER_DIR)/*.c)
+
+SRCS_COMMON_TMP0 = $(wildcard src/common/*.c)
+SRCS_COMMON = $(subst $(SRCS_COMMON_DEL0),,$(SRCS_COMMON_TMP0))
+LOCAL_SRCS := $(SRCS_COMMON) $(SRCS_HOST)
+
+LOCAL_FLAGS := 	-I$(LITEOSTOPDIR)/../../vendor/allwinner/sun8i/driver/mtd/common/include \
+				-I$(LITEOSTOPDIR)/../../vendor/allwinner/sun8i/driver/mtd/spi_nor/include
+
+include $(MODULE)
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/host_common.h openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/host_common.h
--- openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/host_common.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/host_common.h	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __HOST_COMMON_H__
+#define __HOST_COMMON_H__
+
+#include "sys/types.h"
+#include "los_mux.h"
+
+#include "mtd_common.h"
+#include "spinor_common.h"
+#include "spi_common.h"
+
+#define reg_read(_host, _reg) \
+        mtd_readl((UINTPTR)((char *)_host->regbase + (_reg)))
+
+#define reg_write(_host, _value, _reg) \
+        mtd_writel((unsigned)(_value), (UINTPTR)((char *)_host->regbase + (_reg)))
+
+#define get_host(_host) \
+        if(LOS_OK != LOS_MuxLock(&(_host)->lock, LOS_WAIT_FOREVER)) \
+            return -1;
+
+#define put_host(_host) \
+        if(LOS_OK != LOS_MuxUnlock(&(_host)->lock)) \
+            return -1;
+struct spinor_host {
+    struct spinor_info *spinor;
+
+    char     *regbase;
+    char     *membase;
+
+    void (*set_system_clock)(unsigned clock, int clk_en);
+    void (*set_host_addr_mode)(struct spinor_host *host, int enable);
+
+    char *buffer;
+    char *dma_buffer;
+    char *dma_buffer_bak;
+
+    int num_chip;
+    struct spi spi[1];
+
+    LosMux lock;
+};
+
+#endif /* End of __HOST_COMMON_H__ */
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/ramdisk.c.bak2 openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/ramdisk.c.bak2
--- openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/ramdisk.c.bak2	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/ramdisk.c.bak2	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,59 @@
+
+
+static int sector_size = 512;
+static int ramdisk_base =  DDR_RAMFS_VBASE;
+static int ramdisk_size =  DDR_RAMFS_SIZE;
+
+
+static int	ramdisk_open(FAR struct inode *inode)
+{
+	return 0;
+}
+
+static int	ramdisk_close(FAR struct inode *inode)
+{
+	return 0;
+}
+
+ssize_t ramdisk_read(FAR struct inode *inode, FAR unsigned char *buffer,
+		  unsigned long long start_sector, unsigned int nsectors)
+{
+	const char *addr = (const char *)(ramdisk_base + start_sector * sector_size);
+	memcpy(buffer, addr, nsectors * sector_size);
+	return nsectors;
+}
+		  
+ssize_t ramdisk_write(FAR struct inode *inode, FAR const unsigned char *buffer,
+		  unsigned long long start_sector, unsigned int nsectors)
+{
+	char *addr = (const char *)(ramdisk_base + start_sector * sector_size;)
+	memcpy(addr, buffer, nsectors * sector_size);
+	return nsectors;
+}
+
+		  
+static int 	ramdisk_geometry(FAR struct inode *inode, FAR struct geometry *geometry)
+{
+	geometry->geo_available    = true;	 /* true: The device is available */
+	geometry->geo_writeenabled = true; /* true: It is okay to write to this device */
+	geometry->geo_nsectors     = ramdisk_size / sector_size;	 /* Number of sectors on the device */
+	geometry->geo_sectorsize   = sector_size;	 /* Size of one sector */
+	return 0;
+}
+
+static int 	ramdisk_ioctl(FAR struct inode *inode, int cmd, unsigned long arg)
+{
+	return 0;
+}
+
+static int 	ramdisk_unlink(FAR struct inode *inode)
+{
+	return 0;
+}
+
+
+struct block_operations g_ramdisk_opr = {
+};
+
+
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/ramdisk.c.ok openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/ramdisk.c.ok
--- openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/ramdisk.c.ok	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/ramdisk.c.ok	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "errno.h"
+#include "fs/fs.h"
+#include "stdio.h"
+#include "stdlib.h"
+#include "spinor.h"
+#include "fs/fs.h"
+#include "inode/inode.h"
+
+static int sector_size = 512;
+static unsigned int ramdisk_start_addr = DDR_RAMFS_VBASE;
+static unsigned int ramdisk_size       = DDR_RAMFS_SIZE;
+
+static int ramdisk_open(FAR struct inode *inode_p)
+{
+    return 0;
+}
+
+static int ramdisk_close(FAR struct inode *inode_p)
+{
+    return 0;
+}
+
+static ssize_t ramdisk_read(FAR struct inode *inode_p, FAR unsigned char *buffer,
+                             unsigned long long start_sector, unsigned int nsectors)
+{
+	unsigned char * addr = (unsigned char *)(ramdisk_start_addr + sector_size * start_sector);
+	memcpy(buffer, addr, nsectors * sector_size);
+    return nsectors;
+}
+
+static ssize_t ramdisk_write(FAR struct inode *inode_p, FAR const unsigned char *buffer,
+                              unsigned long long start_sector, unsigned int nsectors)
+{
+	unsigned char * addr = (unsigned char *)(ramdisk_start_addr + sector_size * start_sector);
+	memcpy(addr, buffer, nsectors * sector_size);
+    return nsectors;
+}
+
+static int ramdisk_geometry(FAR struct inode *inode_p, FAR struct geometry *geometry_p)
+{
+	geometry_p->geo_available    = true;	 /* true: The device is available */
+	//bool   geo_mediachanged; /* true: The media has changed since last query */
+	geometry_p->geo_writeenabled = true; /* true: It is okay to write to this device */
+	geometry_p->geo_nsectors     = ramdisk_size / sector_size;	 /* Number of sectors on the device */
+	geometry_p->geo_sectorsize   = sector_size;	 /* Size of one sector */
+    return 0;
+}
+
+static int ramdisk_ioctl(FAR struct inode *inode_p, int cmd, unsigned long arg)
+{
+    return 0;
+}
+
+const struct block_operations g_dev_ramdisk_ops = {
+    .open       = ramdisk_open,
+    .close      = ramdisk_close,
+    .read       = ramdisk_read,
+    .write      = ramdisk_write,
+    .geometry   = ramdisk_geometry,
+    .ioctl      = ramdisk_ioctl,
+    .unlink     = NULL
+};
+
+
+extern INT32 los_alloc_diskid_byname(const CHAR *diskName);
+extern INT32 los_disk_init(const CHAR *diskName, const struct block_operations *bops,
+                    VOID *priv, INT32 diskID, VOID *info);
+
+int my_ramdisk_init(void)
+{
+#if 1	
+	char *node_name = "/dev/ramdisk";
+
+	INT32 diskId = los_alloc_diskid_byname(node_name);
+	if (diskId < 0) {
+		PRINT_ERR("Failed to alloc disk %s!\n", node_name);
+		return -1;
+	}
+	if (los_disk_init(node_name, &g_dev_ramdisk_ops, NULL, diskId, NULL) != ENOERR) {
+		PRINT_ERR("Failed to init my ramdisk disk!\n");
+		return -1;
+	}
+#else
+	int ret = register_blockdriver("/dev/ramdisk", &g_dev_ramdisk_ops, 0755, NULL);
+	if (ret)
+		PRINT_ERR("Failed to iregister_blockdriver!\n");
+#endif
+	return 0;
+}
+
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/spinor.c openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/spinor.c
--- openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/spinor.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/spinor.c	2020-10-31 00:27:40.768668070 +0800
@@ -0,0 +1,162 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "errno.h"
+#include "fs/fs.h"
+#include "stdio.h"
+#include "stdlib.h"
+#include "spinor.h"
+#include "mtd_common.h"
+#include "spinor_common.h"
+#include "mtd_dev.h"
+
+struct MtdDev spinor_mtd;
+void AddMtdList(char *type, struct MtdDev *mtd);
+
+extern int get_mtd_info(const char *type);
+
+void* GetMtd(const char *type)
+{
+	(void)type;
+	return &spinor_mtd;
+}
+
+static int ramnor_erase(struct MtdDev *mtd, UINT64 start, UINT64 len, UINT64 *failAddr)
+{
+	unsigned char * rambase = (unsigned char *)mtd->priv;
+
+    uint32_t offset = start;
+    uint32_t length = len;
+
+    if (offset + length > mtd->size) {
+        return -EINVAL;
+    }
+
+    if (offset & (mtd->eraseSize - 1)) {
+        return -EINVAL;
+    }
+
+    if (length & (mtd->eraseSize - 1)) {
+        return -EINVAL;
+    }
+
+	memset((void *)(rambase+offset), 0xff, length);
+    return 0;
+}
+
+static int ramnor_write(struct MtdDev *mtd, UINT64 start, UINT64 len, const char *buf)
+{
+	unsigned char * rambase = (unsigned char *)mtd->priv;
+    uint32_t offset = start;
+    uint32_t length = len;
+
+    if ((offset + length) > mtd->size) {
+        return -EINVAL;
+    }
+
+    if (!length) {
+        return 0;
+    }
+
+    memcpy((void *)(rambase+offset), buf, length);
+	return len;
+}
+
+static int ramnor_read(struct MtdDev *mtd, UINT64 start, UINT64 len, char *buf)
+{
+	unsigned char * rambase = (unsigned char *)mtd->priv;
+    uint32_t offset = start;
+    uint32_t length = len;
+	//int i;
+
+    if ((offset + length) > mtd->size) {
+		PRINT_RELEASE("%s %s %d, memcpy: 0x%x, 0x%x, 0x%x\n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)buf, (unsigned int)(rambase+start), (unsigned int)len); 	
+        return -EINVAL;
+    }
+
+    if (!length) {
+		PRINT_RELEASE("%s %s %d, memcpy: 0x%x, 0x%x, 0x%x\n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)buf, (unsigned int)(rambase+start), (unsigned int)len); 	
+        return 0;
+    }
+
+	//PRINT_RELEASE("%s %s %d, memcpy: 0x%x, 0x%x, 0x%x\n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)buf, (unsigned int)(rambase+start), (unsigned int)len);		
+
+    //return spinor->read(spinor, (uint32_t)from, (uint32_t)len, buf);
+    memcpy(buf, (void *)(rambase+offset), length);
+
+	return len;
+}
+
+
+void ramnor_register(struct MtdDev *mtd)
+{
+    //mtd->priv = (void *)DDR_RAMFS_VBASE;
+
+    //mtd->size = DDR_RAMFS_SIZE;
+    mtd->eraseSize = 0x10000;
+
+    mtd->type = MTD_NORFLASH;
+
+    mtd->erase = ramnor_erase;
+    mtd->read = ramnor_read;
+    mtd->write = ramnor_write;
+
+}
+
+/*---------------------------------------------------------------------------*/
+/* spinor_node_register- spinor node register */
+/*---------------------------------------------------------------------------*/
+int spinor_node_register(struct MtdDev *mtd)
+{
+    int ret = 0;
+    ret = register_blockdriver("/dev/spinor", &g_dev_spinor_ops, 0755, mtd);
+    if (ret) {
+        ERR_MSG("register spinor err %d!\n", ret);
+    }
+
+    return ret;
+}
+
+int spinor_init(void)
+{
+    spinor_mtd.priv = (void *)DDR_RAMFS_VBASE;
+	spinor_mtd.size = DDR_RAMFS_SIZE;
+
+    /* ramnor register */
+    ramnor_register(&spinor_mtd);
+	PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);		
+//    AddMtdList("spinor", &spinor_mtd);
+    if (spinor_node_register(&spinor_mtd)) {
+        PRINT_RELEASE("spinor node register fail!\n");
+        return -1;
+    }
+    return get_mtd_info("spinor") ;
+}
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/spinor_common.h openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/spinor_common.h
--- openharmony/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/spinor_common.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/mtd/spi_nor/src/common/spinor_common.h	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SPINOR_COMMON_H__
+#define __SPINOR_COMMON_H__
+
+#include "spinor_common.h"
+
+/*****************************************************************************/
+#define SPI_NOR_SR_WIP_MASK             (1 << 0)
+#define SPI_NOR_SR_LEN                  1    /* Status Register length(byte) */
+
+#define SPI_NOR_CR_LEN                  1    /* Config Register length(byte) */
+#define SPI_NOR_CR_SHIFT                8    /* Config Register shift(bit) */
+#define SPI_NOR_CR_4BYTE_SHIFT          5
+#define SPI_NOR_CR_4BYTE_MASK           (1 << SPI_NOR_CR_4BYTE_SHIFT)
+#define SPI_NOR_GET_4BYTE_BY_CR(cr)     (((cr) & SPI_NOR_CR_4BYTE_MASK) \
+                                            >> SPI_NOR_CR_4BYTE_SHIFT)
+#define SPI_NOR_CR_QE_SHIFT             1
+#define SPI_NOR_CR_QE_MASK              (1 << SPI_NOR_CR_QE_SHIFT)
+#define SPI_NOR_GET_QE_BY_CR(cr)        (((cr) & SPI_NOR_CR_QE_MASK) \
+                                        >> SPI_NOR_CR_QE_SHIFT)
+
+#define SPI_4BYTE_ADDR_LEN              (4)
+#define SPI_3BYTE_ADDR_LEN              (3)
+
+#define SPI_CMD_SR_WIP                  1    /* Write in Progress */
+#define SPI_CMD_SR_WEL                  2    /* Write Enable Latch */
+
+#define SPI_CMD_SR_QE                   (1 << 9)    /* quad enable */
+#define SPI_CMD_SR_XQE                  (0 << 9)    /* quad disable */
+
+#define SPI_NOR_SR_LEN                  1 /* Status Register length */
+#define SPI_NOR_CR_LEN                  1 /* Config Register length */
+
+#define SPI_NOR_MAX_ID_LEN 8
+/*---------------------------------------------------------------------------*/
+/* struct spinor_dev_info - spinor device information structure */
+/*---------------------------------------------------------------------------*/
+struct spinor_dev_info {
+    char *name;/* Human-readable label */
+    union {
+        char id[SPI_NOR_MAX_ID_LEN];/* The full ID array */
+        struct {
+            uint8_t mfr_id;/* id[0]: Manufacturer ID */
+            uint8_t dev_id;/* id[1]: Device ID */
+        };
+    };
+    uint16_t id_len;/* The valid length of ID */
+
+    uint32_t blocksize;/* Size of an erase block */
+
+    uint64_t chipsize;/* Total size of the device */
+
+    void *priv;
+};
+
+/*---------------------------------------------------------------------------*/
+/* struct spinor_info - spinor various interface and information structure */
+/*---------------------------------------------------------------------------*/
+struct spinor_info {
+    struct spinor_dev_info dev;
+    int numchips;
+
+    void *priv;
+
+    int (*erase)(struct spinor_info *spinor, uint32_t addr, uint32_t len);
+    int (*write)(struct spinor_info *spinor,
+                 uint32_t to, uint32_t len, const char *buf);
+    int (*read)(struct spinor_info *spinor,
+                uint32_t from, uint32_t len, const char *buf);
+    void (*read_id)(struct spinor_info *spinor, char *id);
+    void (*ids_probe)(struct spinor_info *spinor);
+    int (*resume)(struct spinor_info *spinor);
+
+    uint8_t cur_cs;
+};
+
+#endif /* End of __SPINOR_COMMON_H__ */
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/stm32mp157-fb/Makefile openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-fb/Makefile
--- openharmony/vendor/st/stm32mp157/driver/stm32mp157-fb/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-fb/Makefile	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,7 @@
+include $(LITEOSTOPDIR)/config.mk
+
+MODULE_NAME := $(notdir $(shell pwd))
+
+LOCAL_SRCS :=  stm32mp157_lcd.c  stm32mp157_lcdc.c
+
+include $(MODULE)
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcd.c openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcd.c
--- openharmony/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcd.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcd.c	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,87 @@
+/****************************************************************************
+ * boards/arm/am335x/beaglebone-black/src/am335x_lcd.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <stdint.h>
+#include <assert.h>
+#include <errno.h>
+#include <debug.h>
+
+#include "fb.h"
+
+#include "stm32mp157_lcdc.h"
+#include "stm32mp157_lcd.h"
+
+
+static lcd_params lcd_7_0_params = {
+	.name = "lcd_7.0",
+	.pins_pol = {
+		.de    = INVERT,	/* normal: 低电平表示使能输出 */
+		.vclk  = INVERT,	/* normal: 在上升降沿获取数据*/
+		.hsync = NORMAL,    /* normal: 低脉冲*/
+		.vsync = NORMAL, 	/* normal: 低脉冲*/
+	},
+	.time_seq = {
+		/* 垂直方向 */
+		.tvp=	3, /* vysnc脉冲宽度 */
+		.tvb=	20,  /* 上边黑框, Vertical Back porch */
+		.tvf=	12,  /* 下边黑框, Vertical Front porch */
+
+		/* 水平方向 */
+		.thp=	20, /* hsync脉冲宽度 */
+		.thb=	140,  /* 左边黑框, Horizontal Back porch */
+		.thf=	160,  /* 右边黑框, Horizontal Front porch */
+
+		.vclk=	51,  /* MHz */
+	},
+	.xres = 1024,
+	.yres = 600,
+	.bpp  = 16,       
+	.fb_base = LCD_FB_BASE,
+	.fb_vbase = LCD_FB_VBASE,
+};
+
+
+int up_fbinitialize(int display)
+{
+	PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+	Imx6ull_lcd_controller_init(&lcd_7_0_params);
+	PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+	return 0;
+}
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcdc.c openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcdc.c
--- openharmony/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcdc.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcdc.c	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,581 @@
+/****************************************************************************
+ * arch/arm/src/imx6/imx6ull_lcdc.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * This driver derives from the LPC54xx LCD driver but also includes
+ * information from the FreeBSD AM335x LCD driver which was released under
+ * a two-clause BSD license:
+ *
+ *   Copyright 2013 Oleksandr Tymoshenko <gonzo@freebsd.org>
+ *   All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+
+#include <stdint.h>
+#include <string.h>
+#include <semaphore.h>
+#include <errno.h>
+#include <debug.h>
+//#include <nuttx/nx/nxglib.h>
+
+#include "fb.h"
+
+#include "stm32mp157_lcdc.h"
+#include "stm32mp157_lcd.h"
+
+typedef uint16_t nxgl_mxpixel_t;
+
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+
+void imx6ull_lcdclear(nxgl_mxpixel_t color);
+
+/* Get information about the video controller configuration and the
+ * configuration of each color plane.
+ */
+
+static int getvideoinfo(FAR struct fb_vtable_s *vtable,
+             FAR struct fb_videoinfo_s *vinfo);
+static int getplaneinfo(FAR struct fb_vtable_s *vtable, int planeno,
+             FAR struct fb_planeinfo_s *pinfo);
+static int getoverlayinfo(struct fb_vtable_s *vtable, int overlayno,  struct fb_overlayinfo_s *oinfo);
+
+static ssize_t fb_mmap(struct fb_vtable_s *vtable, LosVmMapRegion *region);
+
+/* The following is provided only if the video hardware supports RGB color
+ * mapping
+ */
+
+#ifdef CONFIG_FB_CMAP
+static int imx6ull_getcmap(FAR struct fb_vtable_s *vtable,
+             FAR struct fb_cmap_s *cmap);
+static int imx6ull_putcmap(FAR struct fb_vtable_s *vtable,
+             FAR const struct fb_cmap_s *cmap);
+#endif
+
+static int fb_open(struct fb_vtable_s *vtable)
+{
+	return 0;
+}
+
+static int fb_ioctl(struct fb_vtable_s *vtable, int cmd, unsigned long arg)
+{
+	
+	//PRINT_RELEASE("%s %s %d. cmd = 0x%x\n", __FILE__, __FUNCTION__, __LINE__, cmd);
+	return 0;
+}
+
+
+/* The framebuffer object -- There is no private state information in this
+ * framebuffer driver.
+ */
+
+struct fb_vtable_s g_fbinterface =
+{
+  .getvideoinfo  = getvideoinfo,
+  .getplaneinfo  = getplaneinfo,
+  .getoverlayinfo = getoverlayinfo,
+  .fb_mmap = fb_mmap,
+  .fb_ioctl = fb_ioctl,
+  .fb_open  = fb_open,
+#ifdef CONFIG_FB_CMAP
+  .getcmap       = imx6ull_getcmap,
+  .putcmap       = imx6ull_putcmap,
+#endif
+};
+
+
+static p_lcd_params g_lcd_params;
+
+
+static ssize_t fb_mmap(struct fb_vtable_s *vtable, LosVmMapRegion *region)
+{
+	VADDR_T vaddr = region->range.base;
+	LosVmSpace *space = LOS_SpaceGet(vaddr);
+	size_t size;
+	uint32_t flag;
+	size_t fblen  = (g_lcd_params->xres * g_lcd_params->bpp + 7) >> 3; 		
+	fblen *= g_lcd_params->yres;
+	
+		
+    size = region->range.size;
+    if (size == 0 || (size & ~PAGE_MASK) || size > fblen || region->pgOff != 0) 
+	{
+        return -EINVAL;
+    }
+
+    flag = region->regionFlags;
+    flag &= (~VM_MAP_REGION_FLAG_CACHED);
+    flag |= VM_MAP_REGION_FLAG_UNCACHED;
+
+    if (LOS_ArchMmuMap(&space->archMmu, vaddr, g_lcd_params->fb_base, size >> PAGE_SHIFT, flag) <= 0)
+	{
+        return -EAGAIN;
+    }
+
+    return 0;
+}
+
+
+/****************************************************************************
+ * Name: getvideoinfo
+ ****************************************************************************/
+static unsigned char fake_gram[64];
+
+static int getvideoinfo(struct fb_vtable_s *vtable, struct fb_videoinfo_s *vinfo)
+{
+        vinfo->nplanes = 1;
+        return 0;
+}
+
+static int getplaneinfo(struct fb_vtable_s *vtable, int planeno, struct fb_planeinfo_s *pinfo)
+{
+        pinfo->fbmem = fake_gram;
+        pinfo->fblen = 64;
+        pinfo->bpp = 16;
+        return 0;
+}
+
+static int getoverlayinfo(struct fb_vtable_s *vtable, int overlayno,  struct fb_overlayinfo_s *oinfo)
+{
+        oinfo->fbmem = fake_gram;
+        oinfo->fblen = 64;
+        return 0;
+}
+/****************************************************************************
+ * Name: imx6ull_getcmap
+ ****************************************************************************/
+
+#ifdef CONFIG_FB_CMAP
+static int imx6ull_getcmap(FAR struct fb_vtable_s *vtable,
+                          FAR struct fb_cmap_s *cmap)
+{
+  return -ENOSYS;
+}
+#endif
+
+/****************************************************************************
+ * Name: imx6ull_putcmap
+ ****************************************************************************/
+
+#ifdef CONFIG_FB_CMAP
+static int imx6ull_putcmap(FAR struct fb_vtable_s *vtable,
+                          FAR const struct fb_cmap_s *cmap)
+{
+  return -ENOSYS;
+}
+#endif
+
+
+/*LCD控制器基地址*/
+#define LCD_CONTROLLER_BASE 		IO_DEVICE_ADDR(0x21C8000) 
+
+/*时钟相关基地址*/
+#define CCM_BASE                    IO_DEVICE_ADDR(0x20C4000)
+#define CCM_ANALOG_BASE             IO_DEVICE_ADDR(0x20C8000)
+
+/*LCD管脚复用相关基地址*/
+#define SW_MUX_PART_LCD_BASE		IO_DEVICE_ADDR(0x20E0104)
+
+/*LCD管脚硬件属性相关基地址*/
+#define SW_PAD_PART_LCD_BASE		IO_DEVICE_ADDR(0x20E0390)
+
+#define SW_MUX			  (SW_MUX_CTL_Type*)SW_MUX_PART_LCD_BASE
+#define SW_PAD            (SW_PAD_CTL_Type*)SW_PAD_PART_LCD_BASE
+#define CCM               ((CCM_Type *)CCM_BASE)
+#define CCM_ANALOG        ((CCM_ANALOG_Type *)CCM_ANALOG_BASE)
+#define LCDIF             ((LCDIF_Type *)LCD_CONTROLLER_BASE)
+
+
+
+/*背光GPIO相关寄存器*/
+static volatile unsigned int* GPIO1_IO08_PAD =  (volatile unsigned int*)IO_DEVICE_ADDR(0x20E0308);  /*背光引脚硬件属性地址*/; 
+static volatile unsigned int* GPIO1_GDIR     =   (volatile unsigned int*)IO_DEVICE_ADDR(0x209C000);
+static volatile unsigned int* GPIO1_DR        =   (volatile unsigned int*)IO_DEVICE_ADDR(0x209C004); 
+
+static void imx6ull_delay(volatile int d)
+{
+	while (d--);
+}
+
+static void Imx6ull_lcd_controller_enable(void)
+{	
+	LCDIF->CTRL |= 1<<0; /* 使能6ULL的LCD控制器 */
+}
+static void Imx6ull_lcd_controller_disable(void)
+{
+	LCDIF->CTRL &= ~(1<<0); /* 关闭6ULL的LCD控制器 */
+}
+
+static void Imx6ull_lcd_io_init(void)
+{
+	unsigned int* p_tmp;
+	unsigned int i = 0 ;
+
+	p_tmp = (unsigned int*)(SW_MUX);
+	for(i = 0 ; i < 29 ; i++)		       /*共29个信号需要复用设置*/
+	{
+		*p_tmp = 0;		   /*29个寄存器设置为0表示LCD复用功能*/
+		p_tmp++;
+	}	
+	/*LCD引脚硬件属性关键bit
+     * [16]     :   0  : 施密特特性关闭  
+	 * [15:14]  :   0  : 内部上拉22K电阻（默认）
+	 * [13]     :   0  : Keeper
+	 * [12]     :   0  : 关闭KEEP
+	 * [11]     :   0  : 关闭开漏输出
+	 * [7:6]    :   2  : 输出频率100Mhz
+	 * [5:3]    :   7  : 驱动能力为R0/7 
+	 * [0]      :   1  : 适用于高频信号
+	 */
+	
+    p_tmp = (unsigned int*)(SW_PAD);
+	for(i = 0 ; i < 29 ; i++)	
+	{
+		*p_tmp = 0;
+		*p_tmp |= 0xB9;
+		 p_tmp++;
+	}
+
+	/* 背光GPIO初始化 */
+
+	
+	*GPIO1_IO08_PAD     = 0xB9  ;							/*背光引脚硬件属性设置*/
+
+    *GPIO1_GDIR        |= (1<<8);                             /*背光GPIO设置为输出模式*/
+
+	*GPIO1_DR          |= (1<<8);                             /*背光默认关闭*/
+
+
+}
+
+
+void Imx6ull_lcd_controller_init(p_lcd_params plcdparams)
+{	
+     int bpp_mode;
+
+	 g_lcd_params = plcdparams;
+	 
+	 //PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+	 Imx6ull_lcd_io_init();  /*LCD控制器占据的GPIO引脚初始化*/
+	 //PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+
+	 /* 时钟计算公式如下
+	  * Video PLL output frequency(PLL5)= Fref * (DIV_SELECT + NUM/DENOM)
+	  * PLL5_MAIN_CLK                    = PLL5 / POST_DIV_SELECT / VIDEO_DIV
+	  * LCDIF1_CLK_ROOT                  = PLL5_MAIN_CLK /LCDIF1_PRED / LCDIF1_PODF
+      * 
+      * 输出LCDIF1_CLK_ROOT七寸屏：51.2Mhz
+      * DIV_SELECT             = 32 （寄存器相应位设置为32）
+      * NUM                    = 0  （寄存器相应位设置为0）
+      * DENOM                  = 0  （寄存器相应位设置为0）
+      * POST_DIV_SELECT        = 1  （寄存器相应位设置为2）
+      * VIDEO_DIV              = 1  （寄存器相应位设置为0）
+      * LCDIF1_PRED			   = 3  （寄存器相应位设置为2）
+      * LCDIF1_PODF            = 5  （寄存器相应位设置为4）
+      *
+	  */ 
+	  
+	 /*
+	  *为方便使用 ，不使用小数分频器
+	  *NUM	   = 0
+	  *DENOM = 0
+	  *公式简化为：
+	  * Video PLL output frequency(PLL5)= Fref * DIV_SELECT
+	  * PLL5_MAIN_CLK                    = PLL5 / POST_DIV_SELECT / VIDEO_DIV
+	  * LCDIF1_CLK_ROOT                  = PLL5_MAIN_CLK /LCDIF1_PRED / LCDIF1_PODF
+	  */
+	  CCM_ANALOG->PLL_VIDEO_NUM   = 0; 	 
+	  CCM_ANALOG->PLL_VIDEO_DENOM = 0;	 
+
+	  
+	 /* 初始化寄存器：CCM_ANALOG_PLL_VIDEOn
+	  * [20:19 ] :  2  : 不分频  
+	  * [15:14]  :  0  : PLL5的时钟源为外部24Mhz晶振，默认为零无需设置
+	  * [13]	 :  1  : 使能VIDEO PLL时钟
+	  * [6:0]	 : 32  : 倍频值（DIV_SELECT）
+	  *公式简化为：
+	  * Video PLL output frequency(PLL5)= 24Mhz * 32  = 768Mhz
+	  * PLL5_MAIN_CLK                    = 768Mhz   / POST_DIV_SELECT / 1
+	  * LCDIF1_CLK_ROOT                  = PLL5_MAIN_CLK /LCDIF1_PRED / LCDIF1_PODF
+	  */
+		 CCM_ANALOG->PLL_VIDEO =  (2 << 19) | (1 << 13) | (32<< 0); 
+	 
+	 /* 初始化寄存器：CCM_ANALOG_MISC2n
+	  * [31:30 ] :  0  : 不分频  
+	  *公式简化为：
+	  * Video PLL output frequency(PLL5)= 24Mhz * 32  = 768Mhz
+	  * PLL5_MAIN_CLK                    = 768Mhz   / 1 / 1
+	  * LCDIF1_CLK_ROOT                  = 768Mhz /LCDIF1_PRED / LCDIF1_PODF 
+	  * 默认已为零，不需设置
+	  * CCM_ANALOG->MISC2 &= ~(3 << 30);
+	  */
+	  
+	 /*
+	  *初始化寄存器：CCM_CSCDR2
+      * [17:15] :	2  : PLL5_MAIN_CLK为驱动时钟源  
+      * [12:14] :	2  : 分频系数为3
+      * [11-9 ] :	0  : 时钟源选择LCDIF1_PRED分频后的时钟
+      *公式简化为：
+	  * Video PLL output frequency(PLL5)= 24Mhz * 32  = 768Mhz
+	  * PLL5_MAIN_CLK                    = 768Mhz   / 1 / 1
+	  * LCDIF1_CLK_ROOT                  = 768Mhz /3 / LCDIF1_PODF 
+	  */
+		 CCM->CSCDR2 &= ~(7 << 15); 	   
+		 CCM->CSCDR2 |=  (2 << 15);  
+		 
+		 CCM->CSCDR2 &= ~(7 << 12); 	 
+		 CCM->CSCDR2 |=  (2 << 12); 						 
+	 
+		 CCM->CSCDR2 &= ~(7 << 9);
+
+	 /*
+	  *初始化寄存器：CCM_CBCMR
+	  *[25:23] :  4  :分频系数LCDIF1_PODF设置为5  
+	  *公式简化为：
+	  * Video PLL output frequency(PLL5)= 24Mhz * 32  = 768Mhz
+	  * PLL5_MAIN_CLK                    = 768Mhz   / 1 / 1
+	  * LCDIF1_CLK_ROOT                  = 768Mhz /3 / 5  
+	  *
+	  *最终得到F1_CLK_ROOT     =51.2Mhz
+	  * 
+	  */
+		 CCM->CBCMR &= ~(7 << 23);					 
+		 CCM->CBCMR |=	4 << 23;	/*[25:23] :4 : 表示5分频*/
+
+   	  /* 重新设置时钟后，需要软复位LCD控制器，让LCD控制器像素时钟同步*/
+		 LCDIF->CTRL  = 1<<31;   
+
+	  /*软复位需要花费好几个时钟周期，这里需要一些时间等待*/
+	  imx6ull_delay(100);
+
+	  /*同步像素时钟结束*/
+		LCDIF->CTRL  = 0<<31; /* 取消复位 */
+
+
+	/*LCD控制寄存器初始化*/
+		
+	/* 
+     * 初始化LCD控制器的CTRL寄存器
+     * [19]       :  1      : DOTCLK和DVI modes需要设置为1 
+     * [17]       :  1      : 设置为1工作在DOTCLK模式
+     * [15:14]    : 00      : 输入数据不交换（小端模式）默认就为0，不需设置
+     * [13:12]    : 00      : CSC数据不交换（小端模式）默认就为0，不需设置
+     * [11:10]    : 11		: 数据总线为24bit
+     * [9:8]    根据显示屏资源文件bpp来设置：8位0x1 ， 16位0x0 ，24位0x3
+     * [5]        :  1      : 设置elcdif工作在主机模式
+     * [1]        :  0      : 24位数据均是有效数据，默认就为0，不需设置
+	 */
+     bpp_mode = plcdparams->bpp == 8  ? 0x1 :(plcdparams->bpp == 16 ? 0x0 : 0x3);  /* 0x3: 24bpp or 32bpp */
+     
+	 LCDIF->CTRL |= (1 << 19) | (1 << 17) |(3 << 10) | (bpp_mode << 8) | (1 << 5) ;
+
+     /* [3]当bpp为16时，数据格式为ARGB555*/
+	 if(plcdparams->bpp == 16)
+	 {
+	 	LCDIF->CTRL |= 1<<3;
+	 }
+	 /*
+      * 设置ELCDIF的寄存器CTRL1
+      * 根据bpp设置，bpp为24或32才设置
+      * [19:16]  : 111  :表示ARGB传输格式模式下，传输24位无压缩数据，A通道不用传输）
+	  */	
+	 if(plcdparams->bpp == 24 || plcdparams->bpp == 32)
+	 {		
+	 		LCDIF->CTRL1 &= ~(0xf << 16); 
+		 	LCDIF->CTRL1 |=  (0x7 << 16); 
+	 }
+	 	
+	  /*
+      * 设置ELCDIF的寄存器TRANSFER_COUNT寄存器
+      * [31:16]  : 垂直方向上的像素个数  
+      * [15:0]   : 水平方向上的像素个数
+	  */
+	LCDIF->TRANSFER_COUNT  = (plcdparams->yres << 16) | (plcdparams->xres << 0);
+
+	/*
+	 * 设置ELCDIF的VDCTRL0寄存器
+	 * [29] 0 : VSYNC输出  ，默认为0，无需设置
+	 * [28] 1 : 在DOTCLK模式下，设置1硬件会产生使能ENABLE输出
+	 * [27] 0 : VSYNC低电平有效  ,根据屏幕配置文件将其设置为0
+	 * [26] 0 : HSYNC低电平有效 , 根据屏幕配置文件将其设置为0
+	 * [25] 1 : DOTCLK下降沿有效 ，根据屏幕配置文件将其设置为1
+	 * [24] 1 : ENABLE信号高电平有效，根据屏幕配置文件将其设置为1
+	 * [21] 1 : 帧同步周期单位，DOTCLK mode设置为1
+	 * [20] 1 : 帧同步脉冲宽度单位，DOTCLK mode设置为1
+	 * [17:0] :  vysnc脉冲宽度 
+	 */
+		LCDIF->VDCTRL0 = (1 << 28)|( plcdparams->pins_pol.vsync << 27)\
+						|( plcdparams->pins_pol.hsync << 26)\
+						|( plcdparams->pins_pol.vclk << 25)\
+						|(plcdparams->pins_pol.de << 24)\
+						|(1 << 21)|(1 << 20)|( plcdparams->time_seq.tvp << 0);
+
+	/*
+	 * 设置ELCDIF的VDCTRL1寄存器
+	 * 设置垂直方向的总周期:上黑框tvb+垂直同步脉冲tvp+垂直有效高度yres+下黑框tvf
+	 */  	
+	  LCDIF->VDCTRL1 = plcdparams->time_seq.tvb + plcdparams->time_seq.tvp + plcdparams->yres + plcdparams->time_seq.tvf;  
+
+    /*
+	 * 设置ELCDIF的VDCTRL2寄存器
+	 * [18:31]  : 水平同步信号脉冲宽度
+	 * [17: 0]   : 水平方向总周期
+	 * 设置水平方向的总周期:左黑框thb+水平同步脉冲thp+水平有效高度xres+右黑框thf
+	 */ 
+
+	 LCDIF->VDCTRL2 = (plcdparams->time_seq.thp << 18) | (plcdparams->time_seq.thb + plcdparams->time_seq.thp + plcdparams->xres + plcdparams->time_seq.thf);
+
+	 /*
+	  * 设置ELCDIF的VDCTRL3寄存器
+	  * [27:16] ：水平方向上的等待时钟数 =thb + thp
+      * [15:0]  : 垂直方向上的等待时钟数 = tvb + tvp
+      */ 
+      
+     LCDIF->VDCTRL3 = ((plcdparams->time_seq.thb + plcdparams->time_seq.thp) << 16) | (plcdparams->time_seq.tvb + plcdparams->time_seq.tvp);
+
+	 /*
+	  * 设置ELCDIF的VDCTRL4寄存器
+	  * [18]     使用VSHYNC、HSYNC、DOTCLK模式此为置1
+      * [17:0]  : 水平方向的宽度
+      */ 
+
+	 LCDIF->VDCTRL4 = (1<<18) | (plcdparams->xres);
+
+	 /*
+      * 设置ELCDIF的CUR_BUF和NEXT_BUF寄存器
+      * CUR_BUF    :  当前显存地址
+	  * NEXT_BUF :    下一帧显存地址
+	  * 方便运算，都设置为同一个显存地址
+	  */ 
+	  
+	LCDIF->CUR_BUF  =  plcdparams->fb_base;
+    LCDIF->NEXT_BUF =  plcdparams->fb_base;
+	//PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+
+	imx6ull_lcdclear(0xF800);
+	//PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+	Imx6ull_lcd_controller_enable();
+	//PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+	
+}
+
+/****************************************************************************
+ * Name: up_fbgetvplane
+ *
+ * Description:
+ *   Return a a reference to the framebuffer object for the specified video
+ *   plane of the specified plane.  Many OSDs support multiple planes of video.
+ *
+ * Input Parameters:
+ *   display - In the case of hardware with multiple displays, this
+ *     specifies the display.  Normally this is zero.
+ *   vplane - Identifies the plane being queried.
+ *
+ * Returned Value:
+ *   A non-NULL pointer to the frame buffer access structure is returned on
+ *   success; NULL is returned on any failure.
+ *
+ ****************************************************************************/
+
+FAR struct fb_vtable_s *up_fbgetvplane(int display, int vplane)
+{
+  //PRINT_RELEASE("vplane: %d\n", vplane);
+  if (vplane == 0)
+    {
+      return &g_fbinterface;
+    }
+  else
+    {
+      return NULL;
+    }
+}
+
+/****************************************************************************
+ * Name: up_fbuninitialize
+ *
+ * Description:
+ *   Uninitialize the framebuffer support for the specified display.
+ *
+ * Input Parameters:
+ *   display - In the case of hardware with multiple displays, this
+ *     specifies the display.  Normally this is zero.
+ *
+ * Returned Value:
+ *   None
+ *
+ ****************************************************************************/
+
+void up_fbuninitialize(int display)
+{
+	Imx6ull_lcd_controller_disable();
+}
+
+/****************************************************************************
+ * Name:  imx6ull_lcdclear
+ *
+ * Description:
+ *   This is a non-standard LCD interface just for the AM335x.  Clearing
+ *   the display in the normal way by writing a sequences of runs that
+ *   covers the entire display can be slow.  Here the display is cleared by
+ *   simply setting all VRAM memory to the specified color.
+ *
+ ****************************************************************************/
+
+void imx6ull_lcdclear(nxgl_mxpixel_t color)
+{
+  uint16_t *dest = (uint16_t *)g_lcd_params->fb_vbase;
+
+  int x, y;
+  //PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+
+  for (y = 0; y < g_lcd_params->yres; y++)
+  	for (x = 0; x < g_lcd_params->xres; x++)
+    {
+      *dest++ = color;
+    }
+	//PRINT_RELEASE("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
+	
+}
+
+int imx6ull_fb_init(void)
+{
+	return fb_register(0, 0);	
+}
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcdc.h openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcdc.h
--- openharmony/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcdc.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcdc.h	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,313 @@
+/****************************************************************************
+ * arch/arm/src/imx6ull/imx6ull_lcdc.h
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * The LCD driver derives from the LPC54xx LCD driver but also includes
+ * information from the FreeBSD AM335x LCD driver which was released under
+ * a two-clause BSD license:
+ *
+ *   Copyright 2013 Oleksandr Tymoshenko <gonzo@freebsd.org>
+ *   All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/* The LPC54 LCD driver uses the common framebuffer interfaces declared in
+ * include/nuttx/video/fb.h.
+ */
+
+#ifndef _IMX6ULL_LCDC_H
+#define _IMX6ULL_LCDC_H
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "stm32mp157_lcd.h"
+
+/*根据IMX6ULL芯片手册<<18.6 CCM Memory Map/Register Definition>>658页，定义CCM Memory的结构体,*/
+typedef struct {
+  volatile unsigned int CCR;                              
+  volatile unsigned int CCDR;                            
+  volatile  unsigned int CSR;                            
+  volatile unsigned int CCSR;                           
+  volatile unsigned int CACRR;                             
+  volatile unsigned int CBCDR;                            
+  volatile unsigned int CBCMR;                            
+  volatile unsigned int CSCMR1;                            
+  volatile unsigned int CSCMR2;                            
+  volatile unsigned int CSCDR1;                            
+  volatile unsigned int CS1CDR;                            
+  volatile unsigned int CS2CDR;                            
+  volatile unsigned int CDCDR;                             
+  volatile unsigned int CHSCCDR;                          
+  volatile unsigned int CSCDR2;                            
+  volatile unsigned int CSCDR3;                            
+       unsigned char RESERVED_0[8];
+  volatile  unsigned int CDHIPR;                          
+       unsigned char RESERVED_1[8];
+  volatile unsigned int CLPCR;                             
+  volatile unsigned int CISR;                            
+  volatile unsigned int CIMR;                             
+  volatile unsigned int CCOSR;                            
+  volatile unsigned int CGPR;                             
+  volatile unsigned int CCGR0;                           
+  volatile unsigned int CCGR1;                            
+  volatile unsigned int CCGR2;                           
+  volatile unsigned int CCGR3;                            
+  volatile unsigned int CCGR4;                            
+  volatile unsigned int CCGR5;                            
+  volatile unsigned int CCGR6;                             
+       unsigned char RESERVED_2[4];
+  volatile unsigned int CMEOR;                            
+} CCM_Type;
+
+
+typedef struct 	{
+  volatile unsigned int IOMUXC_SW_MUX_CTL_PAD_LCD_CLK;
+  volatile unsigned int IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE;
+  volatile unsigned int IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC;
+  volatile unsigned int IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC;
+  volatile unsigned int IOMUXC_SW_MUX_CTL_PAD_LCD_RESET;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA00;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA01;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA02;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA03;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA04;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA05;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA06;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA07;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA08;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA09;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA10;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA11;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA12;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA13;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA14;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA15;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA16;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA17;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA18;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA19;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA20;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA21;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA22;
+  volatile unsigned int SW_MUX_CTL_PAD_LCD_DATA23;
+}SW_MUX_CTL_Type;
+		  			 		  						  					  				 	   		  	  	 	  
+typedef struct   {
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_CLK;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_RESET;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA00;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA01;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA02;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA03;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA04;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA05;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA06;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA07;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA08;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA09;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA10;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA11;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA12;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA13;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA14;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA15;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA16;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA17;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA18;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA19;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA20;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA21;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA22;
+  volatile unsigned int IOMUXC_SW_PAD_CTL_PAD_LCD_DATA23;
+}SW_PAD_CTL_Type;
+
+/*根据IMX6ULL芯片手册<<18.7 CCM Analog Memory Map/Register Definition>>的710页，定义CCM Analog Memory的结构体,*/
+typedef struct {
+  volatile unsigned int PLL_ARM;                         
+  volatile unsigned int PLL_ARM_SET;                       
+  volatile unsigned int PLL_ARM_CLR;                       
+  volatile unsigned int PLL_ARM_TOG;                       
+  volatile unsigned int PLL_USB1;                         
+  volatile unsigned int PLL_USB1_SET;                     
+  volatile unsigned int PLL_USB1_CLR;                     
+  volatile unsigned int PLL_USB1_TOG;                      
+  volatile unsigned int PLL_USB2;                          
+  volatile unsigned int PLL_USB2_SET;                     
+  volatile unsigned int PLL_USB2_CLR;                      
+  volatile unsigned int PLL_USB2_TOG;                     
+  volatile unsigned int PLL_SYS;                           
+  volatile unsigned int PLL_SYS_SET;                      
+  volatile unsigned int PLL_SYS_CLR;                     
+  volatile unsigned int PLL_SYS_TOG;                     
+  volatile unsigned int PLL_SYS_SS;                      
+       unsigned char RESERVED_0[12];
+  volatile unsigned int PLL_SYS_NUM;                      
+       unsigned char RESERVED_1[12];
+  volatile unsigned int PLL_SYS_DENOM;                     
+       unsigned char RESERVED_2[12];
+  volatile unsigned int PLL_AUDIO;                         
+  volatile unsigned int PLL_AUDIO_SET;                     
+  volatile unsigned int PLL_AUDIO_CLR;                    
+  volatile unsigned int PLL_AUDIO_TOG;                   
+  volatile unsigned int PLL_AUDIO_NUM;                   
+       unsigned char RESERVED_3[12];
+  volatile unsigned int PLL_AUDIO_DENOM;                 
+       unsigned char RESERVED_4[12];
+  volatile unsigned int PLL_VIDEO;                        
+  volatile unsigned int PLL_VIDEO_SET;                     
+  volatile unsigned int PLL_VIDEO_CLR;                     
+  volatile unsigned int PLL_VIDEO_TOG;                    
+  volatile unsigned int PLL_VIDEO_NUM;                     
+       unsigned char RESERVED_5[12];
+  volatile unsigned int PLL_VIDEO_DENOM;                   
+       unsigned char RESERVED_6[28];
+  volatile unsigned int PLL_ENET;                         
+  volatile unsigned int PLL_ENET_SET;                    
+  volatile unsigned int PLL_ENET_CLR;                      
+  volatile unsigned int PLL_ENET_TOG;                      
+  volatile unsigned int PFD_480;                           
+  volatile unsigned int PFD_480_SET;                       
+  volatile unsigned int PFD_480_CLR;                    
+  volatile unsigned int PFD_480_TOG;                      
+  volatile unsigned int PFD_528;                        
+  volatile unsigned int PFD_528_SET;                     
+  volatile unsigned int PFD_528_CLR;                   
+  volatile unsigned int PFD_528_TOG;                     
+       unsigned char RESERVED_7[64];
+  volatile unsigned int MISC0;                            
+  volatile unsigned int MISC0_SET;                        
+  volatile unsigned int MISC0_CLR;                       
+  volatile unsigned int MISC0_TOG;                        
+  volatile unsigned int MISC1;                             
+  volatile unsigned int MISC1_SET;                        
+  volatile unsigned int MISC1_CLR;                        
+  volatile unsigned int MISC1_TOG;                         
+  volatile unsigned int MISC2;                             
+  volatile unsigned int MISC2_SET;                         
+  volatile unsigned int MISC2_CLR;                       
+  volatile unsigned int MISC2_TOG;                         
+} CCM_ANALOG_Type;
+
+/*根据IMX6ULL芯片手册<<34.6 eLCDIF Memory Map/Register Definition>>2165页，定义eLCDIF的结构体,*/
+typedef struct {
+  volatile unsigned int CTRL;                              
+  volatile unsigned int CTRL_SET;                        
+  volatile unsigned int CTRL_CLR;                         
+  volatile unsigned int CTRL_TOG;                         
+  volatile unsigned int CTRL1;                             
+  volatile unsigned int CTRL1_SET;                         
+  volatile unsigned int CTRL1_CLR;                       
+  volatile unsigned int CTRL1_TOG;                       
+  volatile unsigned int CTRL2;                            
+  volatile unsigned int CTRL2_SET;                       
+  volatile unsigned int CTRL2_CLR;                        
+  volatile unsigned int CTRL2_TOG;                        
+  volatile unsigned int TRANSFER_COUNT;   
+       unsigned char RESERVED_0[12];
+  volatile unsigned int CUR_BUF;                          
+       unsigned char RESERVED_1[12];
+  volatile unsigned int NEXT_BUF;                        
+       unsigned char RESERVED_2[12];
+  volatile unsigned int TIMING;                          
+       unsigned char RESERVED_3[12];
+  volatile unsigned int VDCTRL0;                         
+  volatile unsigned int VDCTRL0_SET;                      
+  volatile unsigned int VDCTRL0_CLR;                     
+  volatile unsigned int VDCTRL0_TOG;                     
+  volatile unsigned int VDCTRL1;                          
+       unsigned char RESERVED_4[12];
+  volatile unsigned int VDCTRL2;                          
+       unsigned char RESERVED_5[12];
+  volatile unsigned int VDCTRL3;                          
+       unsigned char RESERVED_6[12];
+  volatile unsigned int VDCTRL4;                           
+       unsigned char RESERVED_7[12];
+  volatile unsigned int DVICTRL0;    
+  	   unsigned char RESERVED_8[12];
+  volatile unsigned int DVICTRL1;                         
+       unsigned char RESERVED_9[12];
+  volatile unsigned int DVICTRL2;                        
+       unsigned char RESERVED_10[12];
+  volatile unsigned int DVICTRL3;                        
+       unsigned char RESERVED_11[12];
+  volatile unsigned int DVICTRL4;                          
+       unsigned char RESERVED_12[12];
+  volatile unsigned int CSC_COEFF0;  
+  	   unsigned char RESERVED_13[12];
+  volatile unsigned int CSC_COEFF1;                        
+       unsigned char RESERVED_14[12];
+  volatile unsigned int CSC_COEFF2;                        
+       unsigned char RESERVED_15[12];
+  volatile unsigned int CSC_COEFF3;                        
+       unsigned char RESERVED_16[12];
+  volatile unsigned int CSC_COEFF4;   
+  	   unsigned char RESERVED_17[12];
+  volatile unsigned int CSC_OFFSET;  
+       unsigned char RESERVED_18[12];
+  volatile unsigned int CSC_LIMIT;  
+       unsigned char RESERVED_19[12];
+  volatile unsigned int DATA;                              
+       unsigned char RESERVED_20[12];
+  volatile unsigned int BM_ERROR_STAT;                     
+       unsigned char RESERVED_21[12];
+  volatile unsigned int CRC_STAT;                        
+       unsigned char RESERVED_22[12];
+  volatile  unsigned int STAT;                             
+       unsigned char RESERVED_23[76];
+  volatile unsigned int THRES;                             
+       unsigned char RESERVED_24[12];
+  volatile unsigned int AS_CTRL;                           
+       unsigned char RESERVED_25[12];
+  volatile unsigned int AS_BUF;                            
+       unsigned char RESERVED_26[12];
+  volatile unsigned int AS_NEXT_BUF;                     
+       unsigned char RESERVED_27[12];
+  volatile unsigned int AS_CLRKEYLOW;                    
+       unsigned char RESERVED_28[12];
+  volatile unsigned int AS_CLRKEYHIGH;                   
+       unsigned char RESERVED_29[12];
+  volatile unsigned int SYNC_DELAY;                      
+} LCDIF_Type;
+
+
+void Imx6ull_lcd_controller_init(p_lcd_params plcdparams);
+
+#endif /* __ARCH_ARM_SRC_AM335X_AM335X_LCDC_H */
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcd.h openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcd.h
--- openharmony/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcd.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-fb/stm32mp157_lcd.h	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,58 @@
+
+#ifndef _IMX6ULL_LCD_H
+#define _IMX6ULL_LCD_H
+
+enum {
+	NORMAL = 0,
+	INVERT = 1,
+};
+
+/* NORMAL : 正常
+ * INVERT : 取反
+ */
+typedef struct pins_polarity {
+	int de;    /* normal: 高电平使能数据 */
+	int vclk;  /* normal: 在下降沿获取数据 */
+	int hsync; /* normal:高脉冲 */
+	int vsync; /* normal:高脉冲  */
+}pins_polarity, *p_pins_polarity;
+
+typedef struct time_sequence {
+	/* 垂直方向 */
+	int tvp; /*  vysnc脉冲宽度 */
+	int tvb; /*上边黑框 , Vertical Back porch */
+	int tvf; /*下边黑框, Vertical Front porch */
+
+	/* 水平方向 */
+	int thp; /* hsync脉冲宽度 */
+	int thb; /* 左边黑框 ,Horizontal Back porch */
+	int thf; /* 右边黑框,Horizontal Front porch */
+
+	int vclk;
+}time_sequence, *p_time_sequence;
+
+
+typedef struct lcd_params {
+	
+	char *name;
+	
+	/*引脚极性参数*/
+	pins_polarity pins_pol;
+
+	/*时序参数*/
+	time_sequence time_seq;
+
+	/*分辨率*/
+	int xres;
+	int yres;
+	int bpp;
+
+	/*显存*/
+	unsigned int fb_base;
+	unsigned int fb_vbase;
+	
+}lcd_params, *p_lcd_params;
+
+
+#endif
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/stm32mp157-i2c/i2c_dev.c openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-i2c/i2c_dev.c
--- openharmony/vendor/st/stm32mp157/driver/stm32mp157-i2c/i2c_dev.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-i2c/i2c_dev.c	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,466 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: hi35xx i2c driver user support.
+ * Author: yanghaizhou
+ * Create: 2020-08-11
+ */
+
+#include "i2c_dev.h"
+#include <fs/fs.h> /* from Nuttx */
+#include <limits.h>
+#include <stdio.h>
+#include "hdf_base.h"
+#include "hdf_device_desc.h"
+#include "hdf_log.h"
+#include "i2c_core.h"
+#include "i2c_if.h"
+#include "osal_mem.h"
+#include "user_copy.h"
+
+#define I2C_FS_MODE                 0660
+#define I2C_RDWR_IOCTL_MAX_MSGS     42
+#define I2C_BUF_MAX                 8192
+#define I2C_NAME_SIZE               32
+#define I2C_CNTLR_MAX               32
+
+struct I2cClient {
+    struct DevHandle *handle;
+    struct I2cHost *host;
+    uint16_t addr;
+    uint16_t flags;
+};
+
+static inline int32_t I2cMsgInitFromUser(struct I2cMsg *kMsgs, struct i2c_msg *uMsgs)
+{
+    int32_t ret;
+
+    kMsgs->len = uMsgs->len;
+    kMsgs->addr = uMsgs->addr;
+    kMsgs->flags = uMsgs->flags;
+    if ((uMsgs->flags & I2C_M_RD) != 0) {
+        return HDF_SUCCESS;
+    }
+    ret = LOS_CopyToKernel((void *)(kMsgs->buf), kMsgs->len, (void *)(uMsgs->buf), uMsgs->len);
+    return (ret == LOS_OK) ? HDF_SUCCESS : HDF_ERR_IO;
+}
+
+static inline int32_t I2cMsgBackToUser(struct I2cMsg *kMsgs, struct i2c_msg *uMsgs)
+{
+    int32_t ret;
+
+    if ((kMsgs->flags & I2C_M_RD) == 0) {
+        return HDF_SUCCESS;
+    }
+    ret = LOS_CopyFromKernel((void *)(uMsgs->buf), uMsgs->len, (void *)(kMsgs->buf), kMsgs->len);
+    return (ret == LOS_OK) ? HDF_SUCCESS : HDF_ERR_IO;
+}
+
+static inline int32_t I2cMsgsCopyBackToUser(I2cIoctlWrap *wrap,
+    struct I2cMsg *kMsgs, struct i2c_msg *uMsgs)
+{
+    int ret;
+    unsigned int i;
+
+    for (i = 0; i < wrap->nmsgs; i++) {
+        ret = I2cMsgBackToUser(&kMsgs[i], &uMsgs[i]);
+        if (ret != HDF_SUCCESS) {
+            break;
+        }
+    }
+    return ret;
+}
+
+static void I2cMsgsDestroy(struct I2cMsg *kMsgs, struct i2c_msg *uMsgs)
+{
+    if (kMsgs != NULL) {
+        if (kMsgs[0].buf != NULL) {
+            OsalMemFree(kMsgs[0].buf);
+            kMsgs[0].buf = NULL;
+        }
+    }
+    if (uMsgs != NULL) {
+        OsalMemFree(uMsgs);
+    }
+}
+
+static int32_t I2cMsgsCreateFromUser(I2cIoctlWrap *wrap,
+    struct I2cMsg **kMsgsPp, struct i2c_msg **uMsgsPp)
+{
+    int32_t ret;
+    size_t i;
+    size_t bufLen;
+    struct i2c_msg *uMsgs = NULL;
+    struct I2cMsg *kMsgs = NULL;
+    uint8_t *dataBuf = NULL;
+
+    uMsgs = (struct i2c_msg *)OsalMemCalloc((sizeof(*uMsgs) + sizeof(*kMsgs)) * wrap->nmsgs);
+    if (uMsgs == NULL) {
+        return HDF_ERR_MALLOC_FAIL;
+    }
+    kMsgs = (struct I2cMsg *)((uint8_t *)uMsgs + sizeof(*uMsgs) * wrap->nmsgs);
+
+    ret = LOS_CopyToKernel((void *)uMsgs, sizeof(*uMsgs) * wrap->nmsgs,
+        (void *)wrap->msgs, sizeof(*uMsgs) * wrap->nmsgs);
+    if (ret != LOS_OK) {
+        HDF_LOGE("%s: copy msgs from user fail!\n", __func__);
+        goto __ERR__;
+    }
+
+    for (i = 0, bufLen = 0; i < wrap->nmsgs; i++) {
+        if (uMsgs[i].buf == NULL || uMsgs[i].len == 0) {
+            ret = HDF_ERR_INVALID_PARAM;
+            goto __ERR__;
+        }
+        bufLen += uMsgs[i].len;
+    }
+    if (bufLen >= I2C_BUF_MAX) {
+        HDF_LOGE("%s: buf too long:%u\n", __func__, bufLen);
+        ret = HDF_ERR_INVALID_PARAM;
+        goto __ERR__;
+    }
+
+    dataBuf = (uint8_t *)OsalMemCalloc(bufLen);
+    if (dataBuf == NULL) {
+        ret = HDF_ERR_MALLOC_FAIL;
+        goto __ERR__;
+    }
+
+    for (i = 0; i < wrap->nmsgs; i++) {
+        kMsgs[i].buf = dataBuf;
+        dataBuf += uMsgs[i].len;
+        ret = I2cMsgInitFromUser(&kMsgs[i], &uMsgs[i]);
+        if (ret != HDF_SUCCESS) {
+            goto __ERR__;
+        }
+    }
+
+    *kMsgsPp = kMsgs;
+    *uMsgsPp = uMsgs;
+    return HDF_SUCCESS;
+
+__ERR__:
+    I2cMsgsDestroy(kMsgs, uMsgs);
+    return ret;
+}
+
+static int32_t I2cCntlrRead(struct DevHandle *handle, uint16_t addr,
+    uint8_t *buf, int16_t len, uint16_t flags)
+{
+    int32_t ret;
+    struct I2cMsg msg;
+
+    msg.addr = addr;
+    msg.buf = buf;
+    msg.len = len;
+    msg.flags = flags | I2C_FLAG_READ;
+
+    ret = I2cTransfer(handle, &msg, 1);
+    return (ret == 1) ? HDF_SUCCESS : ret;
+}
+
+ssize_t I2cFsRead(struct file *filep, char *buf, size_t count)
+{
+    int32_t ret;
+    uint8_t *kbuf = NULL;
+    struct I2cClient *client = filep->f_priv;
+
+    if (client == NULL) {
+        HDF_LOGE("%s: client is null!", __func__);
+        return 0;
+    }
+
+    kbuf = (uint8_t *)OsalMemCalloc(count);
+    if (kbuf == NULL) {
+        HDF_LOGE("%s: malloc kbuf fail!", __func__);
+        return 0;
+    }
+
+    ret = I2cCntlrRead(client->handle, client->addr, kbuf, count, client->flags);
+    HDF_LOGD("%s: I2cRead called, ret:%d", __func__, ret);
+
+    if (ret == HDF_SUCCESS) {
+        if (LOS_CopyFromKernel(buf, count, kbuf, count) != LOS_OK) {
+            HDF_LOGE("%s: copy from kernel fail:%d", __func__, ret);
+            ret = HDF_ERR_IO;
+        }
+    }
+    OsalMemFree(kbuf);
+    return (ret == HDF_SUCCESS) ? count : 0;
+}
+
+static int32_t I2cCntlrWrite(struct DevHandle *handle, uint16_t addr,
+    const uint8_t *buf, int16_t len, uint16_t flags)
+{
+    int32_t ret;
+    struct I2cMsg msg;
+
+    msg.addr = addr;
+    msg.buf = (uint8_t *)buf;
+    msg.len = len;
+    msg.flags = flags & (~I2C_FLAG_READ);
+
+    ret = I2cTransfer(handle, &msg, 1);
+    return (ret == 1) ? HDF_SUCCESS : ret;
+}
+
+
+ssize_t I2cFsWrite(struct file *filep, const char *buf, size_t count)
+{
+    int32_t ret;
+    uint8_t *kbuf = NULL;
+    struct I2cClient *client = filep->f_priv;
+
+    if (client == NULL) {
+        HDF_LOGE("%s: client is null!", __func__);
+        return 0;
+    }
+
+    kbuf = (uint8_t *)OsalMemCalloc(count);
+    if (kbuf == NULL) {
+        HDF_LOGE("%s: malloc kbuf fail!", __func__);
+        return 0;
+    }
+    if (LOS_CopyToKernel(kbuf, count, buf, count) != LOS_OK) {
+        HDF_LOGE("%s: copy to kernel fail!", __func__);
+        OsalMemFree(kbuf);
+        return 0;
+    }
+
+    ret = I2cCntlrWrite(client->handle, client->addr, kbuf, count, client->flags);
+    HDF_LOGD("%s: I2cWrite called, ret:%d", __func__, ret);
+
+    OsalMemFree(kbuf);
+    return (ret == HDF_SUCCESS) ? count : 0;
+}
+
+static int I2cIoctlReadWrite(const struct I2cClient *client, const void *arg)
+{
+    int ret;
+    I2cIoctlWrap wrap;
+    struct i2c_msg *uMsgs = NULL;
+    struct I2cMsg *kMsgs = NULL;
+
+    if (arg == NULL) {
+        HDF_LOGE("%s: arg is null!", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+
+    ret = LOS_CopyToKernel(&wrap, sizeof(wrap), (void *)arg, sizeof(wrap));
+    if (ret != LOS_OK) {
+        HDF_LOGE("%s: copy wrap fail!", __func__);
+        return HDF_ERR_IO;
+    }
+
+    if (wrap.msgs == NULL || wrap.nmsgs == 0 || wrap.nmsgs > I2C_RDWR_IOCTL_MAX_MSGS) {
+        HDF_LOGE("%s: wrap msgs is null or invalid num:%u!", __func__, wrap.nmsgs);
+        return HDF_ERR_INVALID_PARAM;
+    }
+
+    ret = I2cMsgsCreateFromUser(&wrap, &kMsgs, &uMsgs);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: recreate msgs fail!\n", __func__);
+        return ret;
+    }
+
+    ret = I2cTransfer(client->handle, kMsgs, wrap.nmsgs);
+    HDF_LOGD("%s: I2cTransfer called, ret:%d", __func__, ret);
+    if ((unsigned int)ret == wrap.nmsgs) {
+        ret = I2cMsgsCopyBackToUser(&wrap, kMsgs, uMsgs);
+        if (ret != HDF_SUCCESS) {
+            HDF_LOGE("%s: copy back fail! ret:%d", __func__, ret);
+        }
+    } else {
+        HDF_LOGD("%s: transfer fail, ret:%d, nmsgs:%u", __func__, ret, wrap.nmsgs);
+    }
+
+    I2cMsgsDestroy(kMsgs, uMsgs);
+    return ret;
+}
+
+static int I2cFsIoctl(struct file *filep, int cmd, unsigned long arg)
+{
+    int retval = ENOERR;
+    struct I2cClient *client = filep->f_priv;
+
+    switch (cmd) {
+        case IOCTL_SLAVE_FORCE:
+        case IOCTL_SLAVE:
+            if ((((client->flags & I2C_M_TEN) == 0) && arg > 0xfe) || (arg > 0x3ff)) {
+                HDF_LOGE("%s:Not support arg(%0d)!!!", __func__, arg);
+                retval = -EINVAL;
+                break;
+            }
+            client->addr = arg;
+            break;
+        case IOCTL_RDWR: {
+            retval = I2cIoctlReadWrite(client, (void *)(uintptr_t)arg);
+            break;
+        }
+        case IOCTL_16BIT_REG:
+            if (arg == 0) {
+                client->flags &= ~I2C_M_16BIT_REG;
+            } else {
+                client->flags |= I2C_M_16BIT_REG;
+            }
+            break;
+        case IOCTL_16BIT_DATA:
+            if (arg == 0) {
+                client->flags &= ~I2C_M_16BIT_DATA;
+            } else {
+                client->flags |= I2C_M_16BIT_DATA;
+            }
+            break;
+        case IOCTL_TENBIT:
+            if (arg == 0) {
+                client->flags &= ~I2C_M_TEN;
+            } else {
+                client->flags |= I2C_M_TEN;
+            }
+            break;
+        case IOCTL_PEC:
+        case IOCTL_RETRIES:
+        case IOCTL_TIMEOUT:
+        default:
+            HDF_LOGE("Not support cmd(%0d)!!!", cmd);
+            retval = -EINVAL;
+    }
+    return retval;
+}
+
+static int I2cFsOpen(struct file *filep)
+{
+    struct DevHandle *handle = NULL;
+    struct I2cClient *client = NULL;
+    struct inode *inode = filep->f_inode;
+    int16_t id = (int16_t)((uintptr_t)inode->i_private);
+
+    handle = I2cOpen(id);
+    if (handle == NULL) {
+        HDF_LOGE("%s:Fail to get host:%d handle!\n", __func__, id);
+        return -1;
+    }
+
+    client = (struct I2cClient *)OsalMemCalloc(sizeof(*client));
+    if (client == NULL) {
+        HDF_LOGE("%s:Fail to malloc client-%d!\n", __func__, id);
+        return -1;
+    }
+    client->handle = handle;
+
+    /* record the client as file private data */
+    filep->f_priv = client;
+    return 0;
+}
+
+static int I2cFsClose(struct file *filep)
+{
+    struct I2cClient *client = filep->f_priv;
+
+    if (client == NULL) {
+        HDF_LOGE("%s: has't opened!\n", __func__);
+        return 0;
+    }
+
+    if (client->handle == NULL) {
+        return 0;
+    }
+    I2cClose(client->handle);
+    client->handle = NULL;
+    OsalMemFree(client);
+    client = NULL;
+
+    filep->f_priv = NULL;
+    return 0;
+}
+
+static ssize_t I2cFsMap(FAR struct file* filep, FAR LosVmMapRegion *region)
+{
+    size_t size = region->range.size;
+
+    (void)filep;
+    PADDR_T paddr = region->pgOff << PAGE_SHIFT;
+    VADDR_T vaddr = region->range.base;
+    LosVmSpace *space = LOS_SpaceGet(vaddr);
+
+    if ((space == NULL) || ((paddr >= SYS_MEM_BASE) && (paddr < SYS_MEM_END))) {
+        return -EINVAL;
+    }
+
+    if (LOS_ArchMmuMap(&space->archMmu, vaddr, paddr, size >> PAGE_SHIFT, region->regionFlags) <= 0) {
+        return -EAGAIN;
+    }
+
+    return 0;
+}
+
+static const struct file_operations_vfs g_i2cFops = {
+    .open = I2cFsOpen,
+    .close = I2cFsClose,
+    .read = I2cFsRead,
+    .write = I2cFsWrite,
+    .ioctl = I2cFsIoctl,
+    .mmap = I2cFsMap,
+};
+
+int32_t I2cAddVfsById(int16_t id)
+{
+#ifdef LOSCFG_FS_VFS
+    int32_t ret;
+    char *name = NULL;
+
+    if (id < 0 || id >= I2C_CNTLR_MAX) {
+        HDF_LOGE("%s: id:%d exceed max:%d", __func__, id);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    name = (char *)OsalMemCalloc(I2C_NAME_SIZE);
+    if (name == NULL) {
+        HDF_LOGE("%s: malloc name fail!", __func__);
+        return HDF_ERR_MALLOC_FAIL;
+    }
+    /* create /dev/i2c-x device files for the i2c adatpers */
+    ret = snprintf_s(name, I2C_NAME_SIZE, I2C_NAME_SIZE - 1, "/dev/i2c-%d", id);
+    if (ret < 0) {
+        HDF_LOGE("I2cAddVfsById: format name fail! ret:%d\n", ret);
+        OsalMemFree(name);
+        return ret;
+    }
+    ret = register_driver(name, &g_i2cFops, I2C_FS_MODE, (void *)((uintptr_t)id));
+    if (ret != 0) {
+        HDF_LOGE("I2cAddVfsById: register %s fail! ret:%d\n", name, ret);
+    }
+    OsalMemFree(name);
+    return ret;
+#else /* LOSCFG_FS_VFS */
+    return HDF_SUCCESS;
+#endif
+}
+
+void I2cRemoveVfsById(int16_t id)
+{
+#ifdef LOSCFG_FS_VFS
+    int32_t ret;
+    char *name = NULL;
+
+    if (id < 0 || id >= I2C_CNTLR_MAX) {
+        HDF_LOGE("%s: id:%d exceed max:%d", __func__, id);
+        return;
+    }
+    name = (char *)OsalMemCalloc(I2C_NAME_SIZE);
+    if (name == NULL) {
+        HDF_LOGE("%s: malloc name fail!", __func__);
+        return;
+    }
+    /* create /dev/i2c-x device files for the i2c controllers */
+    ret = snprintf_s(name, I2C_NAME_SIZE, I2C_NAME_SIZE - 1, "/dev/i2c-%d", id);
+    if (ret < 0) {
+        HDF_LOGE("I2cAddVfsById: format name fail! ret:%d\n", ret);
+        OsalMemFree(name);
+        return;
+    }
+    ret = unregister_driver(name);
+    if (ret != 0) {
+        HDF_LOGE("I2cRegisterFs: unregister %s fail!\n", name);
+    }
+    OsalMemFree(name);
+#endif /* LOSCFG_FS_VFS */
+}
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/stm32mp157-i2c/i2c_dev.h openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-i2c/i2c_dev.h
--- openharmony/vendor/st/stm32mp157/driver/stm32mp157-i2c/i2c_dev.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-i2c/i2c_dev.h	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: hi35xx i2c driver user support.
+ * Author: yanghaizhou
+ * Create: 2020-08-11
+ */
+
+#ifndef I2C_USER_H
+#define I2C_USER_H
+
+#include "hdf_base.h"
+
+enum I2cIoctlCmd {
+    IOCTL_RETRIES      = 0x0701,
+    IOCTL_TIMEOUT      = 0x0702,
+    IOCTL_SLAVE        = 0x0703,
+    IOCTL_SLAVE_FORCE  = 0x0706,
+    IOCTL_TENBIT       = 0x0704,
+    IOCTL_FUNCS        = 0x0705,
+    IOCTL_RDWR         = 0x0707,
+    IOCTL_PEC          = 0x0708,
+    IOCTL_SMBUS        = 0x0720,
+    IOCTL_16BIT_REG    = 0x0709,  /* 16BIT REG WIDTH */
+    IOCTL_16BIT_DATA   = 0x070a,  /* 16BIT DATA WIDTH */
+};
+
+enum I2cMsgFlag {
+    I2C_M_RD           = 0x0001,
+    I2C_M_TEN          = 0x0010,
+    I2C_M_RECV_LEN     = 0x0400,
+    I2C_M_NO_RD_ACK    = 0x0800,
+    I2C_M_IGNORE_NAK   = 0x1000,
+    I2C_M_REV_DIR_ADDR = 0x2000,
+    I2C_M_NOSTART      = 0x4000,
+    I2C_M_STOP         = 0x8000,
+#ifdef __LITEOS__
+    I2C_M_16BIT_DATA   = 0x0008,
+    I2C_M_16BIT_REG    = 0x0002,
+#endif
+};
+
+typedef struct i2c_msg {
+    uint16_t addr;
+    uint16_t flags;
+    uint16_t len;
+    uint8_t *buf;
+} I2cMsgUser;
+
+typedef struct i2c_rdwr_ioctl_data {
+    struct i2c_msg *msgs;
+    unsigned int nmsgs;
+} I2cIoctlWrap;
+
+int32_t I2cAddVfsById(int16_t id);
+
+void I2cRemoveVfsById(int16_t id);
+
+#endif /* I2C_USER_H */
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/stm32mp157-i2c/i2c_stm32mp157.c openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-i2c/i2c_stm32mp157.c
--- openharmony/vendor/st/stm32mp157/driver/stm32mp157-i2c/i2c_stm32mp157.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-i2c/i2c_stm32mp157.c	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,634 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: hi35xx i2c driver implement.
+ * Author: yanghaizhou
+ * Create: 2020-07-25
+ */
+
+#include "asm/platform.h"
+#include "device_resource_if.h"
+#include "hdf_device_desc.h"
+#include "hdf_log.h"
+#include "i2c_core.h"
+#include "i2c_dev.h"
+#include "los_hwi.h"
+#include "osal_io.h"
+#include "osal_mem.h"
+#include "osal_time.h"
+
+/* 
+ *IC2状态码，方便通过返回值对程序返回处进行定位
+ */
+#define I2C_OK				     (0)
+#define I2C_ERROR                (1)
+#define I2C_BUSY				 (2)
+#define I2C_IDLE				 (3)
+#define I2C_NAK				     (4)
+#define I2C_ARBITRATIONLOST	     (5)
+#define I2C_TIMEOUT			     (6)
+#define I2C_ADDRNAK			     (7)
+
+
+/* 寄存器地址的宏结构体定义，此种方式仅定义入口地址即可 */
+/* all registers address is Base address + xh offset*/
+typedef struct tagRegisters{
+  volatile uint16_t IADR;                              /*I2C Address Register, offset: 0x0 */
+           uint8_t ReservedIADR[2];
+  volatile uint16_t IFDR;                              /*I2C Frequency Divider Register, offset: 0x4 */
+           uint8_t ReservedIFDR[2];
+  volatile uint16_t I2CR;                              /*I2C Control Register, offset: 0x8 */
+           uint8_t ReservedI2CR[2];
+  volatile uint16_t I2SR;                              /*I2C Status Register, offset: 0xC */
+           uint8_t ReservedI2SR[2];
+  volatile uint16_t I2DR;                              /*I2C Data I/O Register, offset: 0x10 */
+} I2C_REGISTERS;
+
+/*
+ * IC2操作码定义
+ */
+typedef enum enI2C_OPCODE
+{
+    I2C_WRITE = 0,            /* 主机向从机写数据 */
+    I2C_READ  = 1,  		/* 主机从从机读数据 */
+    I2C_DONOTHING_BULL
+} I2C_OPCODE;
+
+/*
+ * 主机传输结构体
+ */
+typedef struct tagI2cTransfer
+{
+    uint8_t  ucSlaveAddress;      	     /* 7位从机地址 */
+    uint32_t ulOpcode  ; 		     /* 操作码*/
+    uint32_t ulSubAddress;       		/* 目标寄存器地址 */
+    uint8_t  ulSubAddressLen;    	     /* 寄存器地址长度 */
+    volatile uint32_t ulLenth;  	     /* 数据长度 */
+    uint8_t *volatile pbuf;    	     /* 数据*/
+} I2C_TRANSFER;
+
+
+#define HDF_LOG_TAG i2c_imx6ull
+
+#define USER_VFS_SUPPORT
+
+
+struct Imx6ullI2cCntlr {
+    struct I2cCntlr cntlr;
+    volatile unsigned char  *regBase;
+    int16_t regSize;
+    int16_t bus;
+    uint32_t clk;
+    uint32_t freq;
+    uint32_t irq;
+    uint32_t regBasePhy;
+};
+
+struct Imx6ullTransferData {
+    struct I2cMsg *msgs;
+    int16_t index;
+    int16_t count;
+};
+
+/*! @name SW_MUX_CTL_PAD - SW_MUX_CTL_PAD_JTAG_MOD SW MUX Control Register..SW_MUX_CTL_PAD_CSI_DATA07 SW MUX Control Register */
+#define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_MASK      (0xFU)  /* Merged from fields with different position or width, of widths (3, 4), largest definition used */
+#define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_SHIFT     (0U)
+#define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE(x)        (((uint32_t)(((uint32_t)(x)) << IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_SHIFT)) & IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_MASK)  /* Merged from fields with different position or width, of widths (3, 4), largest definition used */
+#define IOMUXC_SW_MUX_CTL_PAD_SION_MASK          (0x10U)
+#define IOMUXC_SW_MUX_CTL_PAD_SION_SHIFT         (4U)
+#define IOMUXC_SW_MUX_CTL_PAD_SION(x)            (((uint32_t)(((uint32_t)(x)) << IOMUXC_SW_MUX_CTL_PAD_SION_SHIFT)) & IOMUXC_SW_MUX_CTL_PAD_SION_MASK)
+/*! @name SELECT_INPUT - USB_OTG1_ID_SELECT_INPUT DAISY Register..USDHC2_WP_SELECT_INPUT DAISY Register */
+#define IOMUXC_SELECT_INPUT_DAISY_MASK           (0x7U)  /* Merged from fields with different position or width, of widths (1, 2, 3), largest definition used */
+#define IOMUXC_SELECT_INPUT_DAISY_SHIFT          (0U)
+#define IOMUXC_SELECT_INPUT_DAISY(x)             (((uint32_t)(((uint32_t)(x)) << IOMUXC_SELECT_INPUT_DAISY_SHIFT)) & IOMUXC_SELECT_INPUT_DAISY_MASK)  /* Merged from fields with different position or width, of widths (1, 2, 3), largest definition used */
+
+#define IOMUXC_UART4_TX_DATA_I2C1_SCL                        IO_DEVICE_ADDR(0x020E00B4), 0x2U, IO_DEVICE_ADDR(0x020E05A4), 0x1U, IO_DEVICE_ADDR(0x020E0340)
+#define IOMUXC_UART4_RX_DATA_I2C1_SDA                        IO_DEVICE_ADDR(0x020E00B8), 0x2U, IO_DEVICE_ADDR(0x020E05A8), 0x2U, IO_DEVICE_ADDR(0x020E0344)
+
+#define IOMUXC_UART5_TX_DATA_I2C2_SCL                        IO_DEVICE_ADDR(0x020E00BCU), 0x2U, IO_DEVICE_ADDR(0x020E05ACU), 0x2U, IO_DEVICE_ADDR(0x020E0348U)
+#define IOMUXC_UART5_RX_DATA_I2C2_SDA                        IO_DEVICE_ADDR(0x020E00C0U), 0x2U, IO_DEVICE_ADDR(0x020E05B0U), 0x2U, IO_DEVICE_ADDR(0x020E034CU)
+
+static inline void IOMUXC_SetPinMux(uint32_t muxRegister,
+                                    uint32_t muxMode,
+                                    uint32_t inputRegister,
+                                    uint32_t inputDaisy,
+                                    uint32_t configRegister,
+                                    uint32_t inputOnfield)
+{
+	(void)configRegister;
+	
+    *((volatile uint32_t *)muxRegister) =
+        IOMUXC_SW_MUX_CTL_PAD_MUX_MODE(muxMode) | IOMUXC_SW_MUX_CTL_PAD_SION(inputOnfield);
+
+    if (inputRegister)
+    {
+        *((volatile uint32_t *)inputRegister) = IOMUXC_SELECT_INPUT_DAISY(inputDaisy);
+    }
+}
+
+static inline void IOMUXC_SetPinConfig(uint32_t muxRegister,
+									   uint32_t muxMode,
+									   uint32_t inputRegister,
+									   uint32_t inputDaisy,
+									   uint32_t configRegister,
+									   uint32_t configValue)
+{
+	(void)muxRegister;
+	(void)muxMode;
+	(void)inputRegister;
+	(void)inputDaisy;
+	
+	if (configRegister)
+	{
+		*((volatile uint32_t *)configRegister) = configValue;
+	}
+}
+
+static void i2c_gpio_init(int bus)
+{
+	if (bus == 0)
+	{
+		/*初始化I2C2*/
+		IOMUXC_SetPinMux(IOMUXC_UART5_TX_DATA_I2C2_SCL, 1);
+		IOMUXC_SetPinMux(IOMUXC_UART5_RX_DATA_I2C2_SDA, 1);
+		
+		
+		IOMUXC_SetPinConfig(IOMUXC_UART5_TX_DATA_I2C2_SCL, 0x70B0);
+		IOMUXC_SetPinConfig(IOMUXC_UART5_RX_DATA_I2C2_SDA, 0X70B0);
+	}
+	else
+	{
+		/* no implementations */
+		/*I2C1 复用UART4	SCL-TXD SDA-RXD*/
+		IOMUXC_SetPinMux(IOMUXC_UART4_TX_DATA_I2C1_SCL, 1);
+		IOMUXC_SetPinMux(IOMUXC_UART4_RX_DATA_I2C1_SDA, 1);
+		IOMUXC_SetPinConfig(IOMUXC_UART4_TX_DATA_I2C1_SCL, 0x70B0);
+		IOMUXC_SetPinConfig(IOMUXC_UART4_RX_DATA_I2C1_SDA, 0X70B0);
+	}
+}
+
+static void i2c_init(I2C_REGISTERS *I2C_BASE)
+{
+    /*I2C_I2CR是控制寄存器,
+     * 可以: 使能I2C,使能中断, 选择主从模式.
+     */
+
+    /* 配置I2C控制器步骤: 关闭I2C,配置,打开I2C */
+
+    /* 设置SCL时钟为100K
+     * I2C的时钟源来源于IPG_CLK_ROOT=49.5Mhz
+	 *	PLL2 = 528 MHz
+	 *	PLL2_PFD2 = 528 *18 /24 = 396 MHz
+	 *	IPG_CLK_ROOT = (PLL2_PFD2 / ahb_podf )/ ipg_podf = (396 MHz/4)/2 = 49.5Mhz
+	 *	
+	 *	PER_CLK_ROOT = IPG_CLK_ROOT/perclk_podf = 49.5 MHz/1 = 49.5 MHz
+	 * 设置I2C的波特率为100K， 因此当分频值=49500000/100000=495	
+	 * 参考Table 31-3. I2C_IFDR Register Field Values 表中0x37对应的512最接近
+	 * 即寄存器IFDR的IC位设置为0X37
+	 */	 
+	I2C_BASE->I2CR &= ~(1 << 7);
+	I2C_BASE->IFDR = 0x37;
+	I2C_BASE->I2CR |= (1<<7);
+}
+
+static uint8_t i2c_check(I2C_REGISTERS *I2C_BASE, uint32_t status)
+{
+	/* 检查是否发生仲裁丢失错误(arbitration lost) */
+	if(status & (1<<4))
+	{
+		I2C_BASE->I2SR &= ~(1<<4);	/* 清除仲裁丢失错误位 			*/
+
+		I2C_BASE->I2CR &= ~(1 << 7);	/* 复位I2C: 先关闭I2C 				*/
+		I2C_BASE->I2CR |= (1 << 7);	/* 再打开I2C 				*/
+		return I2C_ARBITRATIONLOST;
+	} 
+	else if(status & (1 << 0))     	/* 检查NAK */
+	{
+		return I2C_NAK;		/* 返回NAK(无应答) */
+	}
+	return I2C_OK;
+
+}
+
+static uint8_t i2c_start(I2C_REGISTERS *I2C_BASE, uint8_t ucSlaveAddr, uint32_t ulOpcode)
+{
+
+	if(I2C_BASE->I2SR & (1 << 5))			/* I2C忙 */
+		return 1;
+
+	/*
+         * 设置控制寄存器I2CR
+         * bit[5]: 1 主模式(master)
+         * bit[4]: 1 发送(transmit)
+	 */
+	I2C_BASE->I2CR |=  (1 << 5) | (1 << 4);
+
+	/*
+         * 设置数据寄存器I2DR
+         * bit[7:0] : 要发送的数据, 
+         * START信号后第一个数据是从设备地址
+	 */ 
+	I2C_BASE->I2DR = ((uint32_t)ucSlaveAddr << 1) | ((I2C_READ == ulOpcode)? 1 : 0);
+	return 0;
+
+}
+
+static uint8_t i2c_stop(I2C_REGISTERS *I2C_BASE)
+{
+
+	uint16_t usTimeout = 0xffff;
+
+	/*
+	 * 清除控制寄存器I2CR[5:3]
+         * 发出STOP信号
+	 */
+	I2C_BASE->I2CR &= ~((1 << 5) | (1 << 4) | (1 << 3));
+
+	/* 等待STOP信号确实发出去了 */
+	while((I2C_BASE->I2SR & (1 << 5)))
+	{
+		usTimeout--;
+		if(usTimeout == 0)	/* 超时跳出 */
+			return I2C_TIMEOUT;
+	}
+	return I2C_OK;
+
+}
+
+static uint8_t i2c_restart(I2C_REGISTERS *I2C_BASE, uint8_t ucSlaveAddr, uint32_t ulOpcode)
+{
+
+	/* I2C忙并且工作在从模式,跳出 */
+	if(I2C_BASE->I2SR & (1 << 5) && (((I2C_BASE->I2CR) & (1 << 5)) == 0))		
+		return 6;
+
+	/*
+         * 设置控制寄存器I2CR
+         * bit[4]: 1 发送(transmit)
+         * bit[2]: 1 产生重新开始信号(Repeat start)
+	 */
+	I2C_BASE->I2CR |=  (1 << 4) | (1 << 2);
+
+	/*
+         * 设置数据寄存器I2DR
+         * bit[7:0] : 要发送的数据, 
+         * START信号后第一个数据是从设备地址
+	 */ 
+	I2C_BASE->I2DR = ((uint32_t)ucSlaveAddr << 1) | ((I2C_READ == ulOpcode)? 1 : 0);
+	
+	return 0;
+
+}
+
+
+static void i2c_write(I2C_REGISTERS *I2C_BASE, const uint8_t *pbuf, uint32_t len)
+{
+	/* 等待数据寄存器就绪,可以再次发送数据 */
+	while(!(I2C_BASE->I2SR & (1 << 7))); 
+	
+	I2C_BASE->I2SR &= ~(1 << 1); 	  /* 清除IICIF */
+	I2C_BASE->I2CR |= 1 << 4;	      /* 发送数据(transmit) */
+	while(len--)
+	{
+		I2C_BASE->I2DR = *pbuf++; 	    /* 将buf中的数据写入到数据寄存器I2DR */
+		
+		while(!(I2C_BASE->I2SR & (1 << 1)));  /* 等待传输完成,完成或失败,中断状态位被置1 */	
+		I2C_BASE->I2SR &= ~(1 << 1);			/* 清除中断状态位 */
+
+		/* 检查有无错误 */
+		if(i2c_check(I2C_BASE, I2C_BASE->I2SR))
+			break;
+	}
+	
+	I2C_BASE->I2SR &= ~(1 << 1);     /* 清除中断状态位 */
+	i2c_stop(I2C_BASE); 	         /* 发送停止信号 */
+
+}
+
+static void i2c_read(I2C_REGISTERS *I2C_BASE, uint8_t *pbuf, uint32_t len)
+{
+	volatile uint8_t dummy = 0;
+	dummy++; 	/* 防止编译警告 */
+
+	/* 等待数据寄存器就绪 */
+	while(!(I2C_BASE->I2SR & (1 << 7))); 
+	
+	I2C_BASE->I2SR &= ~(1 << 1); 			   /* 清除IICIF */
+	I2C_BASE->I2CR &= ~((1 << 4) | (1 << 3));	/* 接收数据: Receive,TXAK */
+	
+	/* 如果只接收一个字节数据的话发送NACK信号 */
+	if(len == 1)
+        I2C_BASE->I2CR |= (1 << 3);
+
+	dummy = I2C_BASE->I2DR; /* 假读 */
+
+
+	while(len--)
+	{
+		while(!(I2C_BASE->I2SR & (1 << 1))); 	/* 等待传输完成 */	
+		I2C_BASE->I2SR &= ~(1 << 1);			/* 清除标志位 */
+
+	 	if(len == 0)
+        {
+        	i2c_stop(I2C_BASE); 			/* 发送停止信号 */
+        }
+
+        if(len == 1)
+        {
+            I2C_BASE->I2CR |= (1 << 3);
+        }
+		*pbuf++ = I2C_BASE->I2DR;
+	}
+
+}
+
+static uint8_t Imx6ullI2cXferOneMsgPolling(I2C_REGISTERS *I2C_BASE, I2C_TRANSFER *transfer)
+{
+	uint32_t ulRet = 0;
+	uint32_t ulOpcode = transfer->ulOpcode;
+
+	/*开始前准备工作，清除标志位
+	 *bit-4 IAL 仲裁位，bit-1 IIF 中断标志位
+	 */
+	I2C_BASE->I2SR &= ~((1 << 1) | (1 << 4));
+	/* 等待传输完成 */
+	while(!((I2C_BASE->I2SR >> 7) & 0X1)){}; 
+
+	/* 如果要读某个寄存器,寄存器地址要先"写"给从设备
+	 * 所以方向要"先写","后读"
+	 */
+    if ((transfer->ulSubAddressLen > 0) && (transfer->ulOpcode == I2C_READ))
+    {
+        ulOpcode = I2C_WRITE;
+    }
+	ulRet = i2c_start(I2C_BASE, transfer->ucSlaveAddress, ulOpcode);
+
+	if (ulRet)
+	{
+		return ulRet;
+	}
+	
+	/* 等待传输完成: 中断状态为会被置1 */
+	while(!(I2C_BASE->I2SR & (1 << 1))){};
+
+	/* 检查是否出错 */
+	ulRet = i2c_check(I2C_BASE, I2C_BASE->I2SR);
+
+	if (ulRet)
+	{
+	    i2c_stop(I2C_BASE); 			/* 发送停止信号 */
+		return ulRet;
+	}
+
+	/*如果ulSubAddressLen不为0，表示要发送寄存器地址*/
+	if (transfer->ulSubAddressLen)
+	{
+		do
+		{
+			/* 清除中断状态位 */
+		    I2C_BASE->I2SR &= ~(1 << 1); 
+			
+			/* 调整长度, 也许寄存器地址有多个字节, 本程序最多支持4字节 */
+			transfer->ulSubAddressLen--;
+
+			I2C_BASE->I2DR = ((transfer->ulSubAddress) >> (8 * transfer->ulSubAddressLen)); 
+  
+			while(!(I2C_BASE->I2SR & (1 << 1))){};  	/* 等待传输完成: 中断状态位被置1 */
+
+            /* 检查是否出错 */
+            ulRet = i2c_check(I2C_BASE, I2C_BASE->I2SR);
+            if(ulRet)
+            {
+             	i2c_stop(I2C_BASE); 				/* 出错:发送停止信号 */
+             	return ulRet;
+            }
+		}
+		while ((transfer->ulSubAddressLen > 0) && (ulRet == I2C_OK));
+
+		if (I2C_READ == transfer->ulOpcode)
+		{
+            I2C_BASE->I2SR &= ~(1 << 1);			/* 清除中断状态位 */
+            i2c_restart(I2C_BASE, transfer->ucSlaveAddress, I2C_READ); /* 发送重复开始信号和从机地址 */
+    		while(!(I2C_BASE->I2SR & (1 << 1))){}; /* 等待传输完成: 中断状态位被置1 */
+
+            /* 检查是否出错 */
+			ulRet = i2c_check(I2C_BASE, I2C_BASE->I2SR);
+			
+            if(ulRet)
+            {
+             	ulRet = I2C_ADDRNAK;
+                i2c_stop(I2C_BASE); 		/* 出错:发送停止信号 */
+                return ulRet;  
+            }
+           	       
+
+		}
+		
+	}
+    /* 发送数据 */
+    if ((I2C_WRITE == transfer->ulOpcode) && (transfer->ulLenth > 0))
+    {
+    	i2c_write(I2C_BASE, transfer->pbuf, transfer->ulLenth);
+	}
+
+    /* 读取数据 */
+    if ((I2C_READ == transfer->ulOpcode) && (transfer->ulLenth > 0))
+    {
+       	i2c_read(I2C_BASE, transfer->pbuf, transfer->ulLenth);
+	}
+	return 0;	
+
+}
+
+
+static int32_t Imx6ullI2cTransfer(struct I2cCntlr *cntlr, struct I2cMsg *msgs, int16_t count)
+{
+    int32_t ret = HDF_SUCCESS;
+    unsigned long irqSave;
+    struct Imx6ullI2cCntlr *imx6ullI2Ccnt = NULL;
+	I2C_TRANSFER transfer;
+	int i;
+
+    if (cntlr == NULL || cntlr->priv == NULL) {
+        HDF_LOGE("Hi35xxI2cTransfer: cntlr lor imx6ullI2Ccntis null!\n");
+        return HDF_ERR_INVALID_OBJECT;
+    }
+    imx6ullI2Ccnt = (struct Imx6ullI2cCntlr *)cntlr;
+
+    if (msgs == NULL || count <= 0) {
+        HDF_LOGE("Hi35xxI2cTransfer: err parms! count:%d\n", count);
+        return HDF_ERR_INVALID_PARAM;
+    }
+
+    irqSave = LOS_IntLock();
+    for (i = 0; i < count; i++) {
+		transfer.ucSlaveAddress = msgs[i].addr;
+		transfer.ulOpcode = (msgs[i].flags & I2C_FLAG_READ) ? I2C_READ : I2C_WRITE;
+		transfer.ulSubAddress = 0;
+		transfer.ulSubAddressLen = 0;
+		transfer.ulLenth = msgs[i].len;
+		transfer.pbuf    = msgs[i].buf;
+	
+        ret = Imx6ullI2cXferOneMsgPolling((I2C_REGISTERS *)imx6ullI2Ccnt->regBase, &transfer);
+        if (ret != 0) {
+            break;
+        }
+    }
+    LOS_IntRestore(irqSave);
+    return (i > 0) ? i : ret;
+}
+
+static struct I2cMethod g_method = {
+    .transfer = Imx6ullI2cTransfer,
+};
+
+static int32_t Imx6ullI2cReadDrs(struct Imx6ullI2cCntlr *imx6ullI2Ccnt, const struct DeviceResourceNode *node)
+{
+    int32_t ret;
+    uint32_t tmp;
+    struct DeviceResourceIface *drsOps = NULL;
+
+    drsOps = DeviceResourceGetIfaceInstance(HDF_CONFIG_SOURCE);
+    if (drsOps == NULL || drsOps->GetUint32 == NULL) {
+        HDF_LOGE("%s: invalid drs ops fail!\n", __func__);
+        return HDF_FAILURE;
+    }
+
+    ret = drsOps->GetUint32(node, "reg_pbase", &imx6ullI2Ccnt->regBasePhy, 0);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: read regBase fail!\n", __func__);
+        return ret;
+    }
+
+    ret = drsOps->GetUint32(node, "reg_size", &tmp, 0);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: read regsize fail!\n", __func__);
+        return ret;
+    }
+    imx6ullI2Ccnt->regSize = (uint16_t)tmp;
+
+    ret = drsOps->GetUint32(node, "freq", &imx6ullI2Ccnt->freq, 0);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: read freq fail!\n", __func__);
+        return ret;
+    }
+
+    ret = drsOps->GetUint32(node, "irq", &imx6ullI2Ccnt->irq, 0);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: read irq fail! \n", __func__);
+        return ret;
+    }
+
+    ret = drsOps->GetUint32(node, "clk", &imx6ullI2Ccnt->clk, 0);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: read clk fail!\n", __func__);
+        return ret;
+    }
+
+    ret = drsOps->GetUint32(node, "bus", &tmp, 0);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: read bus fail!\n", __func__);
+        return ret;
+    }
+    imx6ullI2Ccnt->bus = (uint16_t)tmp;
+
+    return HDF_SUCCESS;
+}
+
+static int32_t Imx6ullI2cBind(struct HdfDeviceObject *device)
+{
+    int32_t ret;
+    struct Imx6ullI2cCntlr *imx6ullI2Ccnt = NULL;
+
+    HDF_LOGI("%s: Enter", __func__);
+    if (device == NULL || device->property == NULL) {
+        HDF_LOGE("%s: device or property is NULL\n", __func__);
+        return HDF_ERR_INVALID_OBJECT;
+    }
+
+    imx6ullI2Ccnt = (struct Imx6ullI2cCntlr *)OsalMemCalloc(sizeof(*imx6ullI2Ccnt));
+    if (imx6ullI2Ccnt == NULL) {
+        HDF_LOGE("%s: malloc imx6ullI2Ccnt fail!", __func__);
+        return HDF_ERR_MALLOC_FAIL;
+    }
+
+    ret = Imx6ullI2cReadDrs(imx6ullI2Ccnt, device->property);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: read drs fail! ret:%d", __func__, ret);
+        goto __ERR__;
+    }
+
+    imx6ullI2Ccnt->regBase = OsalIoRemap(imx6ullI2Ccnt->regBasePhy, imx6ullI2Ccnt->regSize);
+    if (imx6ullI2Ccnt->regBase == NULL) {
+        HDF_LOGE("%s: ioremap regBase fail!\n", __func__);
+        ret = HDF_ERR_IO;
+        goto __ERR__;
+    }
+
+	i2c_gpio_init(imx6ullI2Ccnt->bus);
+    i2c_init((I2C_REGISTERS *)imx6ullI2Ccnt->regBase);
+
+    imx6ullI2Ccnt->cntlr.device = device;
+    imx6ullI2Ccnt->cntlr.priv = (void *)device->property;
+    imx6ullI2Ccnt->cntlr.busId = imx6ullI2Ccnt->bus;
+    imx6ullI2Ccnt->cntlr.ops = &g_method;
+    ret = I2cCntlrAdd(&imx6ullI2Ccnt->cntlr);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: add i2c controller fail:%d!\n", __func__, ret);
+        goto __ERR__;
+    }
+
+#ifdef USER_VFS_SUPPORT
+    (void)I2cAddVfsById(imx6ullI2Ccnt->cntlr.busId);
+#endif
+    return HDF_SUCCESS;
+__ERR__:
+    if (imx6ullI2Ccnt != NULL) {
+        if (imx6ullI2Ccnt->regBase != NULL) {
+            OsalIoUnmap((void *)imx6ullI2Ccnt->regBase);
+            imx6ullI2Ccnt->regBase = NULL;
+        }
+        OsalMemFree(imx6ullI2Ccnt);
+        imx6ullI2Ccnt = NULL;
+    }
+    return ret;
+}
+
+static int32_t Imx6ullI2cInit(struct HdfDeviceObject *device)
+{
+    (void)device;
+    return HDF_SUCCESS;
+}
+
+static void Imx6ullI2cRelease(struct HdfDeviceObject *device)
+{
+    struct I2cCntlr *cntlr = NULL;
+    struct Imx6ullI2cCntlr *imx6ullI2Ccnt = NULL;
+
+    HDF_LOGI("%s: enter\n", __func__);
+
+    if (device == NULL) {
+        HDF_LOGE("%s: device is null!\n", __func__);
+        return;
+    }
+
+    cntlr = I2cCntlrFromDevice(device);
+    if (cntlr == NULL) {
+        HDF_LOGE("%s: no service binded!\n", __func__);
+        return;
+    }
+    I2cCntlrRemove(cntlr);
+
+    imx6ullI2Ccnt = (struct Imx6ullI2cCntlr *)cntlr;
+    OsalIoUnmap((void *)imx6ullI2Ccnt->regBase);
+    OsalMemFree(imx6ullI2Ccnt);
+}
+
+struct HdfDriverEntry g_i2cDriverEntry = {
+    .moduleVersion = 1,
+    .Bind = Imx6ullI2cBind,
+    .Init = Imx6ullI2cInit,
+    .Release = Imx6ullI2cRelease,
+    .moduleName = "HDF_PLATFORM_I2C",
+};
+HDF_INIT(g_i2cDriverEntry);
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/stm32mp157-i2c/Makefile openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-i2c/Makefile
--- openharmony/vendor/st/stm32mp157/driver/stm32mp157-i2c/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-i2c/Makefile	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,19 @@
+include $(LITEOSTOPDIR)/config.mk
+include $(LITEOSTOPDIR)/../../drivers/hdf/lite/lite.mk
+
+MODULE_NAME := $(notdir $(shell pwd))
+
+LOCAL_SRCS :=  i2c_dev.c i2c_stm32mp157.c
+
+LOCAL_FLAGS :=  -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/config \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/core \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/ability/sbuf/include \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/utils/include \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/osal \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/platform \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/lite/include/host/
+
+LOCAL_CFLAGS += -fstack-protector-strong
+
+include $(HDF_DRIVER)
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/stm32mp157-uart/Makefile openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-uart/Makefile
--- openharmony/vendor/st/stm32mp157/driver/stm32mp157-uart/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-uart/Makefile	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,7 @@
+include $(LITEOSTOPDIR)/config.mk
+
+MODULE_NAME := $(notdir $(shell pwd))
+
+LOCAL_SRCS :=  uart_core.c uart_dev.c uart_stm32mp157.c
+
+include $(MODULE)
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/stm32mp157-uart/stm32mp157_uart.h openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-uart/stm32mp157_uart.h
--- openharmony/vendor/st/stm32mp157/driver/stm32mp157-uart/stm32mp157_uart.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-uart/stm32mp157_uart.h	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _AMBA_PL011_UART_H
+#define _AMBA_PL011_UART_H
+
+#include "los_typedef.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+
+/*根据STM32MP157芯片手册<<53.7 Universal synchronous/asynchronous receiver transmitter (USART/UART)>>的2655页，定义USART4的结构体,*/
+typedef struct {
+  volatile unsigned int  USART_CR1;          /**< USART control register 1,                 offset: 0x00 	 串口控制寄存器1，            偏移地址0x00  */
+  volatile unsigned int  USART_CR2;          /**< USART control register 2,                 offset: 0x04 	 串口控制寄存器2，            偏移地址0x04  */
+  volatile unsigned int  USART_CR3;          /**< USART control register 3,                 offset: 0x08 	 串口控制寄存器3，            偏移地址0x08  */
+  volatile unsigned int  USART_BRR;          /**< USART Baud Rate register,                 offset: 0x0C     串口波特率寄存器             偏移地址0x0C  */
+  volatile unsigned int  USART_GTPR;         /**< USART guard time and prescaler register,  offset: 0x10     串口保护时间和预分频器寄存器 偏移地址0x10  */
+  volatile unsigned int  USART_RTOR;         /**< USART receiver timeout register,          offset: 0x14     串口接收超时寄存器           偏移地址0x14  */
+  volatile unsigned int  USART_RQR;          /**< USART request register,                   offset: 0x18     串口请求寄存器               偏移地址0x18  */
+  volatile unsigned int  USART_ISR;          /**< USART interrupt and status register,      offset: 0x1C     串口中断与状态寄存器         偏移地址0x1C  */
+  volatile unsigned int  USART_ICR;          /**< USART interrupt flag clear register ,     offset: 0x20     串口中断状态清除寄存器       偏移地址0x20  */
+  volatile unsigned int  USART_RDR;          /**< USART receive data register,              offset: 0x24     串口接收数据寄存器           偏移地址0x24  */
+  volatile unsigned int  USART_TDR;          /**< USART transmit data register,             offset: 0x28     串口发送数据寄存器           偏移地址0x28  */
+  volatile unsigned int  USART_PRESC;        /**< USART prescaler register,                 offset: 0x2C     串口预分频器寄存器           偏移地址0x2C  */
+} UART_Type;
+
+
+/*UART1的寄存器的基地址*/
+//#define UART1_BASE          (0x2020000u)
+
+#define STM32MP157_UART4      ((UART_Type *)UART4_REG_BASE)
+#define STM32MP157_PHY_UART4  ((UART_Type *)UART4_REG_PBASE)
+
+
+#define CMD_LENGTH  128
+
+extern CHAR g_inputCmd[CMD_LENGTH];
+extern INT32 g_inputIdx;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+#endif
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_core.c openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_core.c
--- openharmony/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_core.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_core.c	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,156 @@
+#include "errno.h"
+#include "string.h"
+#include "uart_dev.h"
+#include "user_copy.h"
+
+int uart_dev_read(struct uart_driver_data *udd, char *buf, size_t count)
+{
+    struct uart_ioc_transfer *transfer = NULL;
+    unsigned int wp, rp;
+    unsigned long data;
+    int ret = 0;
+
+    if (udd == NULL) {
+        uart_error("udd is null");
+        return -EFAULT;
+    }
+
+    transfer = udd->rx_transfer;
+    if (transfer == NULL) {
+        uart_error("transfer is null");
+        return -EFAULT;
+    }
+    if (buf == NULL) {
+        uart_error("buf is nullptr\n");
+        return -EFAULT;
+    }
+
+    wp = transfer->wp;
+    rp = transfer->rp;
+    data = (unsigned long)(uintptr_t)transfer->data;
+
+    if (!(transfer->flags & BUF_CIRCLED)) {
+        if (count >= (wp - rp)) {
+            count = wp - rp;
+        }
+        ret = LOS_CopyFromKernel(buf, BUF_SIZE, (void *)(uintptr_t)(data + rp), count);
+        if (ret){
+            return -EFAULT;
+        }
+        transfer->rp += count;
+        return count;
+    } else {
+        if (count < (BUF_SIZE - rp)) {
+            ret = LOS_CopyFromKernel(buf, BUF_SIZE, (void *)(uintptr_t)(data + rp), count);
+            if (ret) {
+                return -EFAULT;
+            }
+            transfer->rp += count;
+            return count;
+        } else {
+            unsigned int copy_size = BUF_SIZE - rp;
+            unsigned int left_size = count - copy_size;
+            ret = LOS_CopyFromKernel(buf, BUF_SIZE, (void *)(uintptr_t)(data + rp), copy_size);
+            if (ret) {
+                return -EFAULT;
+            }
+            rp = 0;
+            if (left_size > wp) {
+                left_size = wp;
+            }
+            ret = LOS_CopyFromKernel((void *)(buf + copy_size), BUF_SIZE, (void *)(uintptr_t)(data + rp), left_size);
+            if (ret) {
+                return -EFAULT;
+            }
+            transfer->rp = left_size;
+            transfer->flags &= ~BUF_CIRCLED;
+            return (copy_size + left_size);
+        }
+    }
+}
+
+static int notify(struct wait_queue_head *wait)
+{
+    if (wait == NULL) {
+        return -EINVAL;
+    }
+
+    LOS_EventWrite(&wait->stEvent, 0x1);
+    notify_poll(wait);
+    return 0;
+}
+
+int uart_recv_notify(struct uart_driver_data *udd, const char *buf, size_t count)
+{
+    struct uart_ioc_transfer *transfer = NULL;
+    unsigned int wp, rp;
+    unsigned long data;
+    int ret = 0;
+
+    if (udd == NULL) {
+        uart_error("udd is null");
+        return -EFAULT;
+    }
+
+    transfer = udd->rx_transfer;
+    if (transfer == NULL) {
+        uart_error("transfer is null");
+        return -EFAULT;
+    }
+    wp = transfer->wp;
+    rp = transfer->rp;
+    data = (unsigned long)(uintptr_t)transfer->data;
+
+    if (!(transfer->flags & BUF_CIRCLED)) {
+        if (count < (BUF_SIZE - wp)) {
+            ret = LOS_CopyToKernel((void *)(uintptr_t)(data + wp), BUF_SIZE, (void *)(buf), count);
+            if (ret) {
+                return -EFAULT;
+            }
+            transfer->wp += count;
+            notify(&udd->wait);
+            return count;
+        } else {
+            unsigned int copy_size = BUF_SIZE - wp;
+            unsigned int left_size = count - copy_size;
+            ret = LOS_CopyToKernel((void *)(uintptr_t)(data + wp), BUF_SIZE, (void *)(buf), copy_size);
+            if (ret) {
+                return -EFAULT;
+            }
+            wp = 0;
+            if (left_size > rp) {
+                /* overflowed. some new data will be discarded */
+                uart_error("[%d]rx buf overflow", udd->num);
+                left_size = rp;
+            }
+            ret = LOS_CopyToKernel((void *)(uintptr_t)(data + wp), BUF_SIZE, (void *)(buf + copy_size), left_size);
+            if (ret) {
+                return -EFAULT;
+            }
+            transfer->wp = left_size;
+            transfer->flags |= BUF_CIRCLED;
+            notify(&udd->wait);
+            return (copy_size + left_size);
+        }
+    } else {
+        if (count > (rp - wp)) {
+            /* overflowed. some new data will be discarded */
+            uart_error("[%d]rx buf overflow", udd->num);
+            count = rp - wp;
+        }
+        ret = LOS_CopyToKernel((void *)(uintptr_t)(data + wp), BUF_SIZE, (void *)(buf), count);
+        if (ret) {
+                return -EFAULT;
+        }
+        transfer->wp += count;
+        notify(&udd->wait);
+        return count;
+    }
+}
+
+int uart_rx_buf_empty(struct uart_driver_data *udd)
+{
+    struct uart_ioc_transfer *transfer = udd->rx_transfer;
+    return (transfer->wp == transfer->rp);
+}
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_dev.c openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_dev.c
--- openharmony/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_dev.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_dev.c	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,356 @@
+/*
+ * Copyright (c) 2013-2019, Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020, Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "stdio.h"
+#include "stdlib.h"
+#include "string.h"
+#include "errno.h"
+
+#include "fs/fs.h"
+#include "fcntl.h"
+
+#include "asm/platform.h"
+#include "poll.h"
+
+#include "uart_dev.h"
+#include "user_copy.h"
+
+static int uartdev_open(FAR struct file *filep)
+{
+    int ret = 0;
+    struct inode *inode = filep->f_inode;
+    struct wait_queue_head *wait = NULL;
+    struct uart_driver_data *udd = (struct uart_driver_data *)inode->i_private;
+    if (udd == NULL) {
+        uart_error("invalid i_private!");
+        return -EINVAL;
+    }
+    wait = &udd->wait;
+    if (udd->state == UART_STATE_NOT_OPENED) {
+        udd->state = UART_STATE_OPENING;
+        (void)LOS_EventInit(&wait->stEvent);
+        spin_lock_init(&wait->lock);
+        LOS_ListInit(&wait->poll_queue);
+        udd->rx_transfer = (struct uart_ioc_transfer *)LOS_MemAlloc(m_aucSysMem0, sizeof(struct uart_ioc_transfer));
+        if (NULL == udd->rx_transfer) {
+            uart_error("alloc transfer failed!");
+            return -ENOMEM;
+        }
+        memset_s(udd->rx_transfer, sizeof(struct uart_ioc_transfer), 0, sizeof(struct uart_ioc_transfer));
+        if (udd->ops->startup && udd->ops->startup(udd)) {
+            uart_error("startup failed...");
+            ret = -EFAULT;
+            goto free_transfer;
+        }
+    }
+    udd->state = UART_STATE_USEABLE;
+    udd->count++;
+    return 0;
+
+free_transfer:
+    (VOID)LOS_MemFree(m_aucSysMem0, udd->rx_transfer);
+    udd->rx_transfer = NULL;
+    return ret;
+}
+
+static int uartdev_release(FAR struct file *filep)
+{
+    struct inode *inode = filep->f_inode;
+    struct wait_queue_head *wait = NULL;
+    struct uart_driver_data *udd = (struct uart_driver_data *)inode->i_private;
+    if (udd == NULL) {
+        uart_error("uart_driver_data is NULL");
+        return -EINVAL;
+    }
+    if ((--udd->count) != 0) {
+        return 0;
+    }
+
+    wait = &udd->wait;
+
+    if (udd->flags & UART_FLG_DMA_RX) {
+        if (udd->ops->dma_shutdown) {
+            udd->ops->dma_shutdown(udd, UART_DMA_DIR_RX);
+        }
+    }
+    if (udd->flags & UART_FLG_DMA_TX) {
+        if (udd->ops->dma_shutdown) {
+            udd->ops->dma_shutdown(udd, UART_DMA_DIR_TX);
+        }
+    }
+
+    LOS_ListDelete(&wait->poll_queue);
+    LOS_EventDestroy(&wait->stEvent);
+
+    if (udd->ops->shutdown) {
+        udd->ops->shutdown(udd);
+    }
+
+    if (udd->rx_transfer) {
+        (VOID)LOS_MemFree(m_aucSysMem0, udd->rx_transfer);
+    }
+    udd->rx_transfer = NULL;
+    udd->state = UART_STATE_NOT_OPENED;
+
+    return 0;
+}
+
+static ssize_t uartdev_read(FAR struct file *filep, FAR char *buf, size_t count)
+{
+    int ret = 0;
+    struct inode *inode = filep->f_inode;
+
+    struct uart_driver_data *udd = (struct uart_driver_data *)inode->i_private;
+    if (udd == NULL) {
+        uart_error("uart_driver_data is NULL");
+        return -EINVAL;
+    }
+    if (UART_STATE_USEABLE != udd->state) {
+        return -EFAULT;
+    }
+
+    if ((udd->flags & UART_FLG_RD_BLOCK) &&
+        (uart_rx_buf_empty(udd))) {
+        (void)LOS_EventRead(&udd->wait.stEvent,
+                            0x1, LOS_WAITMODE_OR, LOS_WAIT_FOREVER);
+    }
+
+    ret = uart_dev_read(udd, buf, count);
+
+    if ((udd->flags & UART_FLG_RD_BLOCK) &&
+        (uart_rx_buf_empty(udd))) {
+        (void)LOS_EventClear(&udd->wait.stEvent, ~(0x1));
+    }
+    return ret;
+}
+
+static ssize_t uartdev_write(struct file *filep, const char *buf, size_t count)
+{
+    int ret = 0;
+    struct inode *inode = filep->f_inode;
+    struct uart_driver_data *udd = (struct uart_driver_data *)inode->i_private;
+    if (udd == NULL) {
+        uart_error("uart_driver_data is NULL");
+        return -EINVAL;
+    }
+
+    if (UART_STATE_USEABLE != udd->state) {
+        return -EFAULT;
+    }
+
+    if (udd->ops->start_tx) {
+        ret = udd->ops->start_tx(udd, buf, count);
+    }
+
+    return ret;
+}
+
+static int uartcfg_attr(struct uart_driver_data *udd, unsigned long arg)
+{
+    int ret;
+    int len = sizeof(struct __uart_attr);
+
+    if (!LOS_IsUserAddressRange((vaddr_t)arg, len)) {
+        ret = memcpy_s((void *)&udd->attr, len, (void *)arg, len);
+    } else {
+        ret = LOS_ArchCopyFromUser(&udd->attr, (void *)arg, len);
+    }
+
+    if (ret != LOS_OK) {
+        return ret;
+    }
+    if ((udd->ops->config) && (udd->ops->config(udd))) {
+        uart_error("config failed!");
+        ret = -EFAULT;
+    }
+    return ret;
+}
+
+static int uartdev_ioctl(FAR struct file *filep, int cmd, unsigned long arg)
+{
+    int ret = 0;
+    struct inode *inode = filep->f_inode;
+    struct uart_driver_data *udd = (struct uart_driver_data *)inode->i_private;
+
+    if (udd == NULL) {
+        uart_error("uart_driver_data is NULL");
+        return -EINVAL;
+    }
+
+    if (UART_STATE_USEABLE != udd->state) {
+        return -EFAULT;
+    }
+
+    switch (cmd) {
+        case UART_CFG_BAUDRATE:
+            /*
+             * baudrate should be between 0 and CONFIG_MAX_BAUDRATE
+             */
+            if ((arg <= CONFIG_MAX_BAUDRATE) && (arg > 0)) {
+                udd->baudrate = arg;
+                if (udd->ops->config && udd->ops->config(udd)) {
+                    uart_error("invalid  baudrate, which is:%d\n", arg);
+                    ret = -EFAULT;
+                }
+            } else {
+                uart_error("invalid  baudrate, which is:%d\n", arg);
+                ret = -EINVAL;
+            }
+            break;
+
+        case UART_CFG_DMA_RX:
+            if (arg == UART_DMA_RX_EN) {
+                if (!(udd->flags & UART_FLG_DMA_RX)) {
+                    if (udd->ops->dma_startup) {
+                        ret = udd->ops->dma_startup(udd, UART_DMA_DIR_RX);
+                        if (!ret) {
+                            udd->flags |= UART_FLG_DMA_RX;
+                        } else {
+                            uart_error("dma startup failed!");
+                            ret = -EFAULT;
+                        }
+                    } else {
+                        uart_error("dma receive not supported!");
+                        ret = -ENOTSUP;
+                    }
+                }
+            } else if (arg == UART_DMA_RX_DIS) {
+                if (udd->ops->dma_shutdown) {
+                    udd->ops->dma_shutdown(udd, UART_DMA_DIR_RX);
+                    udd->flags &= ~UART_FLG_DMA_RX;
+                } else {
+                    uart_error("dma receive not supported!");
+                    ret = -ENOTSUP;
+                }
+            } else {
+                uart_error("invalid parameter!");
+                ret = -EINVAL;
+            }
+            break;
+
+        case UART_CFG_DMA_TX:
+            if (arg == UART_DMA_TX_EN) {
+                if (!(udd->flags & UART_FLG_DMA_TX)) {
+                    if (udd->ops->dma_startup) {
+                        ret = udd->ops->dma_startup(udd, UART_DMA_DIR_TX);
+                        if (!ret) {
+                            udd->flags |= UART_FLG_DMA_TX;
+                        } else {
+                            uart_error("dma startup failed!");
+                            ret = -EFAULT;
+                        }
+                    } else {
+                        uart_error("dma send not supported!");
+                        ret = -ENOTSUP;
+                    }
+                }
+            } else if (arg == UART_DMA_TX_DIS) {
+                if (udd->ops->dma_shutdown) {
+                    udd->ops->dma_shutdown(udd, UART_DMA_DIR_TX);
+                    udd->flags &= ~UART_FLG_DMA_TX;
+                } else {
+                    uart_error("dma send not supported!");
+                    ret = -ENOTSUP;
+                }
+            } else {
+                uart_error("invalid parameter!");
+                ret = -EINVAL;
+            }
+            break;
+        case UART_CFG_RD_BLOCK:
+            if (arg == UART_RD_BLOCK) {
+                udd->flags |= UART_FLG_RD_BLOCK;
+            } else if (arg == UART_RD_NONBLOCK) {
+                udd->flags &= ~UART_FLG_RD_BLOCK;
+                (void)LOS_EventWrite(&udd->wait.stEvent, 0x1);
+            }
+            break;
+
+        case UART_CFG_ATTR:
+            ret = uartcfg_attr(udd, arg);
+            break;
+        case UART_CFG_PRIVATE:
+            if (udd->ops->priv_operator) {
+                ret = udd->ops->priv_operator(udd, (void *)(uintptr_t)arg);
+            }
+            break;
+        /* add more configs */
+
+        default:
+            uart_error("unknow ioctl cmd:%d\n", cmd);
+            ret = -EINVAL;
+            break;
+    }
+    return ret;
+}
+
+extern void poll_wait(struct file *filp,
+                      wait_queue_head_t *wait_address, poll_table *p);
+static int uartdev_poll(struct file *filep, poll_table *table)
+{
+    struct inode *inode = filep->f_inode;
+    struct uart_driver_data *udd = (struct uart_driver_data *)inode->i_private;
+    if (udd == NULL) {
+        uart_error("uart_driver_data is NULL");
+        return -EINVAL;
+    }
+    if (UART_STATE_USEABLE != udd->state) {
+        return -EFAULT;
+    }
+
+    poll_wait(filep, &udd->wait, table);
+
+    if (!uart_rx_buf_empty(udd)) {
+        return POLLIN | POLLRDNORM;
+    }
+    return 0;
+}
+
+static ssize_t uartdev_map(FAR struct file* filep, FAR LosVmMapRegion *region)
+{
+    PRINTK("%s %d, mmap is not support\n", __FUNCTION__, __LINE__);
+    return 0;
+}
+
+const struct file_operations_vfs uartdev_fops = {
+    .open   = uartdev_open,
+    .close  = uartdev_release,
+    .read   = uartdev_read,
+    .write  = uartdev_write,
+    .seek   = NULL,
+    .ioctl  = uartdev_ioctl,
+    .mmap   = uartdev_map,
+#ifndef CONFIG_DISABLE_POLL
+    .poll   = uartdev_poll,
+#endif
+    .unlink = NULL,
+};
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_dev.h openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_dev.h
--- openharmony/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_dev.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_dev.h	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,245 @@
+#ifndef __UART_USER_H__
+#define __UART_USER_H__
+
+#include "sys/ioctl.h"
+#include "linux/wait.h"
+#include "poll.h"
+#include "console.h"
+
+#define UART_IOC_MAGIC   'u'
+
+/* baudrate config */
+#define UART_CFG_BAUDRATE _IO(UART_IOC_MAGIC, 1)
+
+/* DMA CONFIG: receive */
+#define UART_DMA_RX_EN    1
+#define UART_DMA_RX_DIS    0
+
+#define UART_CFG_DMA_RX    _IO(UART_IOC_MAGIC, 2)
+
+/* DMA CONFIG: send */
+#define UART_DMA_TX_EN    1
+#define UART_DMA_TX_DIS    0
+
+#define UART_CFG_DMA_TX    _IO(UART_IOC_MAGIC, 3)
+
+/* Read Block: */
+#define UART_RD_BLOCK    1
+#define UART_RD_NONBLOCK    0
+
+#define UART_CFG_RD_BLOCK    CONSOLE_CMD_RD_BLOCK_SERIAL
+
+/* ATTRIBUTE CONFIG: data_bits, stop_bits, etc. */
+struct uart_attr {
+    unsigned int data_bits : 4;    /* bit0~3: data bits */
+#define UART_ATTR_DATABIT_8    0
+#define UART_ATTR_DATABIT_7    1
+#define UART_ATTR_DATABIT_6    2
+#define UART_ATTR_DATABIT_5    3
+
+    unsigned int parity : 4;      /* bit4~7: parity */
+#define UART_ATTR_PARITY_NONE    0
+#define UART_ATTR_PARITY_ODD    1
+#define UART_ATTR_PARITY_EVEN    2
+#define UART_ATTR_PARITY_MARK    3
+#define UART_ATTR_PARITY_SPACE    4
+
+    unsigned int stop_bits : 4;   /* bit8~11: stop bits */
+#define UART_ATTR_STOPBIT_1    0
+#define UART_ATTR_STOPBIT_1P5    1
+#define UART_ATTR_STOPBIT_2    2
+
+    unsigned int rts : 1;    /* bit 12: rts */
+#define UART_ATTR_RTS_DIS    0
+#define UART_ATTR_RTS_EN    1
+
+    unsigned int cts : 1;    /* bit 13: cts */
+#define UART_ATTR_CTS_DIS    0
+#define UART_ATTR_CTS_EN    1
+
+    unsigned int fifo_rx_en : 1;    /* bit 14: rx fifo enable */
+#define UART_ATTR_RX_FIFO_DIS    0
+#define UART_ATTR_RX_FIFO_EN    1
+
+    unsigned int fifo_tx_en : 1;    /* bit 15: tx fifo enable */
+#define UART_ATTR_TX_FIFO_DIS    0
+#define UART_ATTR_TX_FIFO_EN    1
+
+    unsigned int reserved : 16;    /* bit16~31: reserved */
+};
+/*
+ * uart attribute config cmd,
+ * parameter should be 'struct uart_init *'
+ * */
+#define UART_CFG_ATTR    _IOW(UART_IOC_MAGIC, 5, int)
+
+#define BUF_SIZE    0x4000    /* receive buf default size: 16K */
+struct uart_driver_data;
+
+struct uart_ops {
+    int (*startup)(struct uart_driver_data *udd);
+    int (*shutdown)(struct uart_driver_data *udd);
+
+    int (*dma_startup)(struct uart_driver_data *udd, int dir);
+    int (*dma_shutdown)(struct uart_driver_data *udd, int dir);
+#define UART_DMA_DIR_RX    0
+#define UART_DMA_DIR_TX    1
+
+    int (*start_tx)(struct uart_driver_data *udd,
+                    const char *buf, size_t count);
+
+    int (*config)(struct uart_driver_data *udd);
+    /* private operation */
+    int (*priv_operator)(struct uart_driver_data *udd, void *data);
+};
+
+struct uart_ioc_transfer {
+    unsigned int rp;
+    unsigned int wp;
+    unsigned int flags;
+#define BUF_CIRCLED    (1 << 0)
+#define BUF_OVERFLOWED    (1 << 1)
+#define BUF_EMPTIED    (1 << 2)
+
+    char data[BUF_SIZE];
+};
+
+struct __uart_attr {
+    unsigned int data_bits : 4;    /* bit0~3: data bits */
+#define UART_ATTR_DATABIT_8    0
+#define UART_ATTR_DATABIT_7    1
+#define UART_ATTR_DATABIT_6    2
+#define UART_ATTR_DATABIT_5    3
+
+    unsigned int parity : 4;      /* bit4~7: parity */
+#define UART_ATTR_PARITY_NONE    0
+#define UART_ATTR_PARITY_ODD    1
+#define UART_ATTR_PARITY_EVEN    2
+#define UART_ATTR_PARITY_MARK    3
+#define UART_ATTR_PARITY_SPACE    4
+
+    unsigned int stop_bits : 4;   /* bit8~11: stop bits */
+#define UART_ATTR_STOPBIT_1    0
+#define UART_ATTR_STOPBIT_1P5    1
+#define UART_ATTR_STOPBIT_2    2
+
+    unsigned int rts : 1;    /* bit 12: rts */
+#define UART_ATTR_RTS_DIS    0
+#define UART_ATTR_RTS_EN    1
+
+    unsigned int cts : 1;    /* bit 13: cts */
+#define UART_ATTR_CTS_DIS    0
+#define UART_ATTR_CTS_EN    1
+
+    unsigned int fifo_rx_en : 1;    /* bit 14: rx fifo enable */
+#define UART_ATTR_RX_FIFO_DIS    0
+#define UART_ATTR_RX_FIFO_EN    1
+
+    unsigned int fifo_tx_en : 1;    /* bit 15: tx fifo enable */
+#define UART_ATTR_TX_FIFO_DIS    0
+#define UART_ATTR_TX_FIFO_EN    1
+
+    unsigned int reserved : 16;    /* bit16~31: reserved */
+};
+
+typedef int (*recv_notify)(struct uart_driver_data *udd,
+                           const char *buf, size_t count);
+
+struct uart_driver_data {
+    unsigned int num;
+    unsigned int baudrate;
+    struct __uart_attr attr;
+    struct uart_ioc_transfer *rx_transfer;
+    wait_queue_head_t wait;
+    int count;
+    int state;
+#define UART_STATE_NOT_OPENED   (0)
+#define UART_STATE_OPENING       (1)
+#define UART_STATE_USEABLE       (2)
+#define UART_STATE_SUSPENED     (3)
+
+    unsigned int flags;
+#define UART_FLG_DMA_RX   (1 << 0)
+#define UART_FLG_DMA_TX   (1 << 1)
+#define UART_FLG_RD_BLOCK   (1 << 2)
+
+    recv_notify recv;
+    struct uart_ops *ops;
+    void *private;
+};
+
+
+#ifndef FALSE
+#define FALSE    (0)
+#endif
+
+#ifndef TRUE
+#define TRUE    (1)
+#endif
+
+
+
+
+#define CONFIG_MAX_BAUDRATE    921600 /* max baud rate */
+
+
+/* trace */
+#define  TRACE_INIT    (1<<0)
+#define  TRACE_DATA    (1<<2)
+#define  TRACE_MSG     (1<<3)
+#define  TRACE_ERR     (1<<4)
+
+#define TRACE_MASK     (0xff)
+/* messages print definitions, for debug ,err e.g. */
+#ifdef LOSCFG_DEBUG_VERSION
+#define uart_trace(mask, msg...) do { \
+        if ((mask) & TRACE_MASK) { \
+            dprintf("<uart>,%s:%d: ", __func__, __LINE__); \
+            dprintf(msg); \
+            dprintf("\n"); \
+        } \
+    } while (0)
+#else
+#define uart_trace(mask, msg...)
+#endif
+
+#define uart_error(msg...) do { \
+    dprintf("<uart,err>:%s,%d: ", __func__, __LINE__); \
+    dprintf(msg); \
+    dprintf("\n"); \
+}while(0)
+
+
+
+/*
+ * uart core functions
+ * */
+/* read some data from rx_data buf in uart_ioc_transfer */
+int uart_dev_read(struct uart_driver_data *udd, char *buf, size_t count);
+/* check the buf is empty */
+int uart_rx_buf_empty(struct uart_driver_data *udd);
+
+int uart_recv_notify(struct uart_driver_data *udd, const char *buf, size_t count);
+
+/*
+ * uart functions which are in uart host driver
+ * uart host driver must define them
+ * */
+/* get uart host numbers */
+int get_uart_num(void);
+/* get uart driver data(udd) which is defined in uart host drivers,
+ * through uart number */
+struct uart_driver_data *get_uart_drv_data(int num);
+/* uart private cmmand for uart host */
+#define UART_CFG_PRIVATE    _IOW(UART_IOC_MAGIC, 6, int)
+
+int uart_dev_init(void);
+int uartdev_de_init(void);
+int uart_suspend(void *data);
+int uart_resume(void *data);
+void uart_early_init(void);
+
+struct uart_softc {
+    struct uart_driver_data *udd;
+};
+#endif /* __UART_USER_H__ */
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_stm32mp157.c openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_stm32mp157.c
--- openharmony/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_stm32mp157.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/stm32mp157-uart/uart_stm32mp157.c	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,431 @@
+#include "linux/delay.h"
+#include "asm/io.h"
+
+#include "los_typedef.h"
+#include "los_task.h"
+#include "los_base.h"
+#include "los_event.h"
+#include "errno.h"
+
+#include "linux/interrupt.h"
+#include "linux/kernel.h"
+#include "linux/spinlock.h"
+#include "stm32mp157_uart.h"
+#include "asm/platform.h"
+#include <sys/bus.h>
+
+#include "uart.h"
+#include "uart_dev.h"
+#include "string.h"
+
+#include "los_magickey.h"
+
+struct stm32mp157_port {
+        int enable;
+        unsigned long phys_base;
+        unsigned int irq_num;
+        struct uart_driver_data *udd;
+};
+
+__attribute__ ((section(".data"))) UINT32 g_uart_fputc_en = 1;
+
+void uart_putc_phy(unsigned char c)
+{
+	UART_Type *uartRegs = (UART_Type *)UART4_REG_PBASE;
+	while ((uartRegs->USART_ISR & (1<<7)) == 0);
+	uartRegs->USART_TDR = c;
+}
+
+void uart_putc_virt(unsigned char c)
+{
+	UART_Type *uartRegs = (UART_Type *)UART_REG_BASE;
+	while ((uartRegs->USART_ISR & (1<<7)) == 0);
+	uartRegs->USART_TDR = c;
+}
+
+LITE_OS_SEC_BSS STATIC SPIN_LOCK_INIT(g_uartOutputSpin);
+
+
+STATIC INLINE UINTPTR uart_to_ptr(UINTPTR n)
+{
+    (VOID)n;
+    return UART_REG_BASE;
+}
+
+STATIC VOID UartPutcReg(UINTPTR base, CHAR c)
+{
+	UART_Type *uartRegs = (UART_Type *)base;
+
+	while ((uartRegs->USART_ISR & (1<<7)) == 0); /*等待上个字节发送完毕*/
+	uartRegs->USART_TDR = c;
+}
+
+int myputs(const char *s)
+{
+	while (*s)
+	{
+		uart_putc_virt(*s);
+		s++;
+	}
+	return 0;
+}
+
+void myputhex(unsigned int val)
+{
+	/* 0x76543210 */
+	int i, j;
+
+	myputs("0x");
+	for (i = 7; i >= 0; i--)
+	{
+		j = (val >> (i*4)) & 0xf;
+		if ((j >= 0) && (j <= 9))
+			uart_putc_virt('0' + j);
+		else
+			uart_putc_virt('A' + j - 0xA);
+	}	
+}
+
+
+STATIC VOID UartPutStr(UINTPTR base, const CHAR *s, UINT32 len)
+{
+    UINT32 i;
+    for (i = 0; i < len; i++) {
+        if (*(s + i) == '\n') {
+			UartPutcReg(base, *"\r");
+        }
+		UartPutcReg(base, *(s + i));
+    }
+}
+
+
+UINT32 UartPutsReg(UINTPTR base, const CHAR *s, UINT32 len, BOOL isLock)
+{
+    UINT32 intSave;
+
+    if (g_uart_fputc_en == 0) {
+        return 0;
+    }
+
+	extern void uart_putc_virt(unsigned char c);
+    if (isLock) {
+        LOS_SpinLockSave(&g_uartOutputSpin, &intSave);
+        UartPutStr(base, s, len);
+        LOS_SpinUnlockRestore(&g_uartOutputSpin, intSave);
+    } else {
+        UartPutStr(base, s, len);
+    }
+
+    return len;
+}
+
+VOID UartPuts(const CHAR *s, UINT32 len, BOOL isLock)
+{
+    UINTPTR base = uart_to_ptr(0);
+    (VOID)UartPutsReg(base, s, len, isLock);
+}
+
+INT32 uart_puts(const CHAR *s, UINTPTR len, VOID *state)
+{
+    (VOID)state;
+    UINTPTR i;
+
+    for (i = 0; i < len; i++) {
+        if (*(s + i) != '\0') {
+            if (*(s + i) == '\n') {
+                (VOID)uart_fputc('\r', NULL);
+            }
+
+            (VOID)uart_fputc(*(s + i), NULL);
+        }
+    }
+
+    return (INT32)len;
+}
+VOID uart_early_init(VOID)
+{
+    /* enable uart transmit */
+}
+
+VOID uart_init(VOID)
+{
+}
+
+#define FIFO_SIZE    128
+
+static irqreturn_t stm32mp157_uart_irq(int irq, void *data)
+{
+	char buf[FIFO_SIZE];
+	unsigned int count = 0;
+	struct stm32mp157_port *port = NULL;
+	struct uart_driver_data *udd = (struct uart_driver_data *)data;
+	UART_Type *uartRegs;
+    uint32_t status;
+	
+	if (udd == NULL) {
+		uart_error("udd is null!\n");
+		return IRQ_HANDLED;
+	}
+	port = (struct stm32mp157_port *)udd->private;
+
+	uartRegs = (UART_Type *)port->phys_base;
+
+    status = uartRegs->USART_ISR;
+    if (status & (1<<5)) {
+        do {
+            buf[count++] = uartRegs->USART_RDR;
+            if (udd->num != CONSOLE_UART) {
+				PRINT_RELEASE("%s %s %d, udd->num = %d, CONSOLE_UART = %d\n", __FILE__, __FUNCTION__, __LINE__, udd->num, CONSOLE_UART);
+                continue;
+            }
+            if (CheckMagicKey(buf[count - 1])) {
+                goto end;
+            }
+
+			if (buf[count-1] == '\r')
+				buf[count-1] = '\n';
+			status = uartRegs->USART_ISR;
+		} while (status & (1<<5));
+		//buf[count] = '\0';
+		//PRINT_RELEASE("%s %s %d, udd->recv %d, %s\n", __FILE__, __FUNCTION__, __LINE__, count, buf);
+        udd->recv(udd, buf, count);
+    }
+	
+end:
+	/* clear all interrupt */
+	return 0;
+}
+
+
+static int stm32mp157_config_in(struct uart_driver_data *udd)
+{
+	return 0;
+}
+
+static int stm32mp157_startup(struct uart_driver_data *udd) 
+{
+	int ret = 0;
+	struct stm32mp157_port *port = NULL;
+	UART_Type *uartRegs;
+
+	if (udd == NULL) {
+		uart_error("udd is null!\n");
+		return -EFAULT;
+	}
+
+	port = (struct stm32mp157_port *)udd->private;
+	if (!port) {
+		uart_error("port is null!");
+		return -EFAULT;
+	}
+	
+	uartRegs = (UART_Type *)port->phys_base;
+	
+	/* enable the clock */
+	LOS_TaskLock();
+	//uart_clk_cfg(udd->num, true); //use for hi3518
+	LOS_TaskUnlock();
+	
+	
+	uartRegs = (UART_Type *)port->phys_base;
+	
+    /* enable the clock */
+    /* uart disable */
+	uartRegs->USART_CR1 &= ~(1<<0);
+	
+    /* clear all interrupt,set mask */
+    /* mask all interrupt */
+
+	/* disable FIFO mode */
+	uartRegs->USART_CR1 &= ~(1<<29);
+
+	/* enable Transmitter and Receiver */
+	uartRegs->USART_CR1 |= (1<<3) | (1<<2);
+
+    /* mask all interrupt */
+	
+
+	ret = request_irq(port->irq_num, (irq_handler_t)stm32mp157_uart_irq,
+							  0, "uart_dw", udd);
+
+	/* enable rx interrupt
+	 * RXFNEIE: RXFIFO not empty interrupt enable
+	 */
+	uartRegs->USART_CR1 |= (1<<5);
+
+	/* enable uart */
+	uartRegs->USART_CR1 |= (1<<0);
+	
+	stm32mp157_config_in(udd);
+
+	return ret;
+}
+
+static int stm32mp157_shutdown(struct uart_driver_data *udd)
+{
+	return 0;
+}
+
+static int stm32mp157_start_tx(struct uart_driver_data *udd, const char *buf, size_t count)
+{
+	unsigned int tx_len = count;
+	struct stm32mp157_port *port = NULL;
+	char value;
+	unsigned int i;
+	int ret = 0;
+
+	if (udd == NULL) {
+		uart_error("udd is null!\n");
+		return -EFAULT;
+	}
+	port = (struct stm32mp157_port *)udd->private;
+	if (!port) {
+		uart_error("port is null!");
+		return -EFAULT;
+	}
+	/* UART_WITH_LOCK: there is a spinlock in the function to write reg in order. */
+	for (i = 0; i < tx_len; i++ ){
+		ret = LOS_CopyToKernel((void *)&value, sizeof(char),(void *)(buf++), sizeof(char));
+		if (ret) {
+			return i;
+		}
+		(void)UartPutsReg(port->phys_base, &value, 1, UART_WITH_LOCK);
+	}
+	return count;
+}
+
+static int stm32mp157_config(struct uart_driver_data *udd)
+{
+	return stm32mp157_config_in(udd);
+}
+
+static struct uart_ops stm32mp157_uops = {
+	.startup        = stm32mp157_startup,
+	.shutdown       = stm32mp157_shutdown,
+	.start_tx       = stm32mp157_start_tx,
+	.config         = stm32mp157_config,
+};
+
+#define MAX_DEV_NAME_SIZE  32
+extern const struct file_operations_vfs uartdev_fops;
+extern struct uart_driver_data *get_udd_by_unit(int unit);
+
+static int stm32mp157_attach(device_t self)
+{
+	struct resource *res = NULL;
+	char dev_name[MAX_DEV_NAME_SIZE];
+	struct stm32mp157_port *port = NULL;
+	int unit = device_get_unit(self);
+	struct uart_softc *sc = device_get_softc(self);
+	struct uart_driver_data *udd = sc->udd;
+
+	if (udd == NULL) {
+		uart_error("stm32mp157_attach get uart driver data err!");
+		return -1;
+	}
+	port = (struct stm32mp157_port *)LOS_MemAlloc(m_aucSysMem0, sizeof(struct stm32mp157_port));
+	if (!port) {
+		return -1;
+	}
+	memset_s(port, sizeof(struct stm32mp157_port), 0, sizeof(struct stm32mp157_port));
+	res = bus_alloc_resource_any(self, SYS_RES_MEMORY, &unit, 0);
+	if (!res) {
+		goto err;
+	}
+	port->phys_base = (unsigned long)(uintptr_t)ioremap(res->start, res->count);
+	if (!port->phys_base) {
+		goto err;
+	}
+	res = bus_alloc_resource_any(self, SYS_RES_IRQ, &unit, 0);
+	if (!res) {
+		goto err;
+	}
+	
+	port->irq_num = res->start;
+	if (port->irq_num == LOS_NOK) {
+		goto err;
+	}
+
+	udd->private = port;
+	udd->ops = &stm32mp157_uops;
+	port->udd = udd;
+	udd->recv = uart_recv_notify;
+	udd->count = 0;
+	memset_s(dev_name, MAX_DEV_NAME_SIZE, 0, MAX_DEV_NAME_SIZE);
+	snprintf_s(dev_name, MAX_DEV_NAME_SIZE, MAX_DEV_NAME_SIZE - 1, "/dev/uartdev-%d", udd->num);
+	if (register_driver(dev_name, &uartdev_fops, 0666, udd)) {
+		uart_error("gen /dev/uartdev-%d fail!\n", udd->num);
+		goto err;
+	}
+
+	return 0;
+err:
+	iounmap((void *)(uintptr_t)port->phys_base);
+	(VOID)LOS_MemFree(m_aucSysMem0, port);
+	port =  NULL;
+	return -1;
+}
+
+static int stm32mp157_probe(device_t self)
+{
+	return (BUS_PROBE_DEFAULT);
+}
+
+static int stm32mp157_detach(device_t self)
+{
+	struct uart_softc *sc = device_get_softc(self);
+	struct uart_driver_data *udd = sc->udd;
+	struct stm32mp157_port *port = NULL;
+	char dev_name[MAX_DEV_NAME_SIZE];
+	if (udd == NULL || (udd->state != UART_STATE_USEABLE)) {
+		uart_error("stm32mp157_detach uart driver data state invalid!");
+		return -1;
+	}
+
+	(void)memset_s(dev_name, MAX_DEV_NAME_SIZE, 0, MAX_DEV_NAME_SIZE);
+	(void)snprintf_s(dev_name, MAX_DEV_NAME_SIZE, MAX_DEV_NAME_SIZE - 1, "/dev/uartdev-%d", udd->num);
+	if (unregister_driver(dev_name)) {
+		uart_error("stm32mp157_detach unregister /dev/uartdev-%d fail!\n", udd->num);
+	}
+	port = udd->private;
+	if (port == NULL) {
+		return -1;
+	}
+	if (port->phys_base) {
+		iounmap((void *)(uintptr_t)port->phys_base);
+		port->phys_base = 0;
+	}
+	(VOID)LOS_MemFree(m_aucSysMem0, port);
+	udd->private = NULL;
+	return 0;
+}
+
+static device_method_t uart_methods[] = 
+{
+	/* Device interface */
+	DEVMETHOD(device_probe, stm32mp157_probe),
+	DEVMETHOD(device_attach, stm32mp157_attach),
+	DEVMETHOD(device_detach, stm32mp157_detach),
+	DEVMETHOD(device_shutdown, bus_generic_shutdown),
+	DEVMETHOD_END
+};
+
+static driver_t uart_driver = 
+{
+	.name = "uart",
+	.methods = uart_methods,
+	.size = sizeof(struct uart_softc),
+};
+
+static devclass_t uart_devclass;
+DRIVER_MODULE(uart, nexus, uart_driver, uart_devclass, 0, 0);
+
+int uart_dev_init(void)
+{
+	return driver_module_handler(NULL, MOD_LOAD, &uart_nexus_driver_mod);
+}
+
+void uart_dev_exit(void)
+{
+	driver_module_handler(NULL, MOD_UNLOAD, &uart_nexus_driver_mod);
+}
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/touch/Makefile openharmony_100ask/vendor/st/stm32mp157/driver/touch/Makefile
--- openharmony/vendor/st/stm32mp157/driver/touch/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/touch/Makefile	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,17 @@
+include $(LITEOSTOPDIR)/config.mk
+include $(LITEOSTOPDIR)/../../drivers/hdf/lite/lite.mk
+
+MODULE_NAME := $(notdir $(shell pwd))
+
+LOCAL_SRCS :=  touch_gt9xx.c
+
+LOCAL_FLAGS :=  -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/osal \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/include/core \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/ability/sbuf/include \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/frameworks/utils/include \
+                -I$(LITEOSTOPDIR)/../../drivers/hdf/lite/include/host
+
+LOCAL_CFLAGS += -fstack-protector-strong
+
+include $(HDF_DRIVER)
+
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/touch/touch_gt9xx.c openharmony_100ask/vendor/st/stm32mp157/driver/touch/touch_gt9xx.c
--- openharmony/vendor/st/stm32mp157/driver/touch/touch_gt9xx.c	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/touch/touch_gt9xx.c	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,666 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: ft6236 touch driver implement.
+ * Author: zhaihaipeng
+ * Create: 2020-07-25
+ */
+
+#include <stdlib.h>
+#include <asm/io.h>
+#include <fs/fs.h>
+#include <fs_poll_pri.h>
+#include <los_queue.h>
+#include <poll.h>
+#include <user_copy.h>
+#include <securec.h>
+#include "gpio_if.h"
+#include "hdf_device_desc.h"
+#include "hdf_log.h"
+#include "osal_irq.h"
+#include "osal_mem.h"
+#include "osal_time.h"
+#include "touch_gt9xx.h"
+
+
+/* device node path and access right */
+#define TOUCH_DEVICE "/dev/input/event1"
+#define TOUCH_DEVICE_MODE 0666
+/* task config */
+#define TASK_PRIO_LEVEL_TWO 2
+#define TASK_SIZE 0x6000
+#define TOUCH_EVENT_DOWN       0
+#define TOUCH_EVENT_UP         1
+#define TOUCH_EVENT_CONTACT    2
+
+/* the macro defines of GT911 */
+#define ONE_BYTE_MASK         0xFF
+#define ONE_BYTE_OFFSET       8
+#define GT_EVENT_UP           0x80
+#define GT_EVENT_INVALID      0
+#define GT_EVENT_SIZE         6
+#define GT_X_LOW              0
+#define GT_X_HIGH             1
+#define GT_Y_LOW              2
+#define GT_Y_HIGH             3
+#define GT_PRESSURE_LOW       4
+#define GT_PRESSURE_HIGH      5
+#define GT_ADDR_LEN           2
+#define GT_BUF_STATE_ADDR     0x814E
+#define GT_X_LOW_BYTE_BASE    0x8150
+#define GT_FINGER_NUM_MASK    0x03
+#define GT_CLEAN_DATA_LEN     3
+#define GT_REG_HIGH_POS       0
+#define GT_REG_LOW_POS        1
+#define GT_CLEAN_POS          2
+#define GT_CLEAN_FLAG         0x0
+/* Config info macro of GT911 */
+#define GT_CFG_INFO_ADDR      0x8140
+#define GT_CFG_INFO_LEN       10
+#define GT_PROD_ID_1ST        0
+#define GT_PROD_ID_2ND        1
+#define GT_PROD_ID_3RD        2
+#define GT_PROD_ID_4TH        3
+#define GT_FW_VER_LOW         4
+#define GT_FW_VER_HIGH        5
+#define GT_SOLU_X_LOW         6
+#define GT_SOLU_X_HIGH        7
+#define GT_SOLU_Y_LOW         8
+#define GT_SOLU_Y_HIGH        9
+
+/* the sleep time for task */
+#define TASK_SLEEP_MS 100
+#define EVENT_SYNC 0x1
+
+static TouchCoreData *g_coreData;
+static InputEventData g_touchEventData;
+static EVENT_CB_S g_touchEventIrq;
+
+uint32_t IrqHandle(uint32_t irqId, void *dev);
+
+
+/* start for imx6ull */
+
+/*
+ * int pin: GPIO1_IO05
+ * rst pin: SNVS_TAMPER2/GPIO5_IO02
+ */
+
+#define GT9XX_INT_NUM  (66 + 32)
+
+/** GPIO - Register Layout Typedef */
+typedef struct {
+  volatile uint32_t DR;                                /**< GPIO data register, offset: 0x0 */
+  volatile uint32_t GDIR;                              /**< GPIO direction register, offset: 0x4 */
+  volatile  uint32_t PSR;                               /**< GPIO pad status register, offset: 0x8 */
+  volatile uint32_t ICR1;                              /**< GPIO interrupt configuration register1, offset: 0xC */
+  volatile uint32_t ICR2;                              /**< GPIO interrupt configuration register2, offset: 0x10 */
+  volatile uint32_t IMR;                               /**< GPIO interrupt mask register, offset: 0x14 */
+  volatile uint32_t ISR;                               /**< GPIO interrupt status register, offset: 0x18 */
+  volatile uint32_t EDGE_SEL;                          /**< GPIO edge select register, offset: 0x1C */
+} GPIO_Type;
+
+
+static volatile unsigned int *CCM_CCGR1                              ;
+static volatile unsigned int *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER2;
+static volatile unsigned int *IOMUXC_GPIO1_IO05_GPIO1_IO05           ;
+static volatile unsigned int *IOMUXC_PAD_CTL_GPIO1_IO05              ;
+static GPIO_Type *gpio1;
+static GPIO_Type *gpio5;
+
+static void gt911_io_init(void)
+{
+	unsigned int val;
+	
+	CCM_CCGR1                               = (volatile unsigned int *)IO_DEVICE_ADDR(0x20C406C);
+	IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER2 = (volatile unsigned int *)IO_DEVICE_ADDR(0x2290010);
+	IOMUXC_GPIO1_IO05_GPIO1_IO05            = (volatile unsigned int *)IO_DEVICE_ADDR(0x20E0070);
+	IOMUXC_PAD_CTL_GPIO1_IO05               = (volatile unsigned int *)IO_DEVICE_ADDR(0x20E02FC);	
+
+	gpio1 = (GPIO_Type *)IO_DEVICE_ADDR(0x0209C000);
+	gpio5 = (GPIO_Type *)IO_DEVICE_ADDR(0x020AC000);
+
+	/* GPIO5和GPIO1都是使用CCM_CCGR1 */
+	/* 使能GPIO5 GPIO1
+	 * set CCM to enable GPIO5 GPIO1
+	 * CCM_CCGR1[CG15] 0x20C406C
+	 * bit[31:30] = 0b11 || bit[27:26] = 0b11 = 0b110011 = 0d51
+	 */
+	*CCM_CCGR1 |= (51<<26);
+	
+	/* 设置GPIO5_IO02用于GPIO 同理设置GPIO1_IO05
+	 * set IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER2
+	 *      to configure GPIO5_IO02 as GPIO
+	 * IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER2  0x2290010
+	 * bit[3:0] = 0b0101 alt5
+	 */
+	val = *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER2;
+	val &= ~(0xf);
+	val |= (5);
+	*IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER2 = val;
+	
+	val = *IOMUXC_GPIO1_IO05_GPIO1_IO05;
+	val &= ~(0xf);
+	val |= (5);
+	*IOMUXC_GPIO1_IO05_GPIO1_IO05 = val;
+
+	gpio5->GDIR |= (1<<2);
+	gpio1->GDIR |= (1<<5);
+}
+
+void gt9xx_irq_init(TouchCoreData *cd)
+{
+	int32_t ret;
+
+	/* if set 0, masked */
+	gpio1->IMR &= ~(1 << 1);
+	
+	/* if set detects any edge on the corresponding input signal*/
+	gpio1->EDGE_SEL &= ~(1 << 5);
+
+	/* falling-edge */
+	gpio1->ICR1 |= (3<<10);
+	
+	/* clear interrupt first to avoid unexpected event */
+	gpio1->ISR |= (1 << 5);
+
+	/* IrqHandle */
+	ret = OsalRegisterIrq(cd->intGpioNum, 0, IrqHandle, "gt9xx_irq", NULL);
+
+	if (ret)
+	{
+		HDF_LOGE("%s %s %d, gt9xx_irq_init err\n", __FILE__, __FUNCTION__, __LINE__);
+	}
+}
+
+static int32_t gt9xx_irq_enable(uint32_t irq)
+{
+	(void)irq;
+	
+	/* if set 1, unmasked, Interrupt n is enabled */
+	gpio1->IMR |= (1 << 5);
+
+	return HDF_SUCCESS;
+}
+
+int32_t gt9xx_irq_disable(uint32_t irq)
+{
+	(void)irq;
+	
+	/* if set 0, masked */
+	gpio1->IMR &= ~(1 << 5);
+
+	return HDF_SUCCESS;
+}
+
+static void gt9xx_irq_clear(uint32_t irq)
+{
+	(void)irq;
+	
+	gpio1->ISR |= (1 << 5);
+}
+
+static void gt9xx_init(void)
+{
+    /*初始化gt911_io*/
+	gt911_io_init();
+	/*初始化两个I0都为低电平*/
+	gpio5->DR &= ~(1<<2);
+	gpio1->DR &= ~(1<<5);
+	/*10ms*/
+	OsalMSleep(RESET_LOW_DELAY);
+	/*reset 输出高，INT转为悬浮输出态*/
+	gpio5->DR |= (1<<2);
+	*IOMUXC_PAD_CTL_GPIO1_IO05 = 0x0088; 
+	gpio1->GDIR &= ~(1<<5);
+	/*100ms*/
+	OsalMSleep(RESET_LOW_DELAY*10);
+}
+
+/* end for imx6ull */
+
+
+TouchCoreData *GetCoreData(void)
+{
+    return g_coreData;
+}
+
+static void TouchWakeupPoll(void)
+{
+    TouchCoreData *cd = GetCoreData();
+    cd->readFinishFlag = true;
+    wake_up_interruptible(&cd->pollWait);
+}
+
+uint32_t IrqHandle(uint32_t irqId, void *dev)
+{
+    (void)dev;
+    int ret = gt9xx_irq_disable(irqId);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: disable irq failed, ret %d", __func__, ret);
+    }
+    (void)LOS_EventWrite(&g_touchEventIrq, EVENT_SYNC);
+
+    return HDF_SUCCESS;
+}
+
+static void TouchConfigInit(TouchCoreData *cd)
+{
+    /* init waitqueue for poll */
+    __init_waitqueue_head(&cd->pollWait);
+
+    /* config i2c and input */
+    cd->i2cClient.i2cCfg.addr = DRIVER_CHIP_I2C_ADDR;
+    cd->i2cClient.i2cCfg.busNum = I2C_BUS_NUM;
+    cd->inputCfg.solutionX = TOUCH_SOLUTION_X;
+    cd->inputCfg.solutionY = TOUCH_SOLUTION_Y;
+
+    /* config device type and module info */
+    cd->inputDevType = INDEV_TYPE_TOUCH;
+    (void)strncpy_s(cd->chipInfo, CHIP_INFO_LEN, "HZ1145130", strlen("HZ1145130"));
+    (void)strncpy_s(cd->vendorName, VENDOR_NAME_LEN, "ZG1695", strlen("TG1695"));
+    (void)strncpy_s(cd->chipName, CHIP_NAME_LEN, "GT9xx", strlen("GT9xx"));
+
+    /* pin num and irq trigger config info */
+    //cd->rstGpioNum = RST_GPIO_GROUP * GPIO_GROUP_SIZE + RST_GPIO_OFFSET;
+    cd->intGpioNum = GT9XX_INT_NUM;
+    cd->irqFlag = OSAL_IRQF_TRIGGER_FALLING;
+    cd->shouldStop = false;
+}
+
+
+static int TouchSetupGpio(const TouchCoreData *cd)
+{
+	gt9xx_init();
+    return HDF_SUCCESS;
+}
+
+static void ReadChipVersion(TouchCoreData *cd)
+{
+    unsigned char buf[GT_CFG_INFO_LEN] = {0};
+    int ret = InputI2cRead(&cd->i2cClient, GT_CFG_INFO_ADDR, GT_ADDR_LEN, buf, GT_CFG_INFO_LEN);
+    if (ret < 0) {
+        HDF_LOGE("%s: read chip version failed", __func__);
+        return;
+    }
+
+    int version = (buf[GT_FW_VER_HIGH] << ONE_BYTE_OFFSET) | buf[GT_FW_VER_LOW];
+    int xSolution = (buf[GT_SOLU_X_HIGH] << ONE_BYTE_OFFSET) | buf[GT_SOLU_X_LOW];
+    int ySolution = (buf[GT_SOLU_Y_HIGH] << ONE_BYTE_OFFSET) | buf[GT_SOLU_Y_LOW];
+    HDF_LOGI("%s: IC FW version is 0x%x", __func__, version);
+    if (buf[GT_FW_VER_HIGH] == 0x0) {
+        HDF_LOGI("Product ID : %c%c%c_%02x%02x, X_Solu = %d, Y_Solu = %d", buf[GT_PROD_ID_1ST], buf[GT_PROD_ID_2ND],
+            buf[GT_PROD_ID_3RD], buf[GT_FW_VER_HIGH], buf[GT_FW_VER_LOW], xSolution, ySolution);
+    } else {
+        HDF_LOGI("Product_ID: %c%c%c%c_%02x%02x, X_Solu = %d, Y_Solu = %d", buf[GT_PROD_ID_1ST], buf[GT_PROD_ID_2ND],
+            buf[GT_PROD_ID_3RD], buf[GT_PROD_ID_4TH], buf[GT_FW_VER_HIGH], buf[GT_FW_VER_LOW], xSolution, ySolution);
+    }
+}
+
+static int TouchSetupI2c(TouchCoreData *cd)
+{
+    /* get i2c handle */
+    cd->i2cClient.i2cHandle = I2cOpen(cd->i2cClient.i2cCfg.busNum);
+    if (cd->i2cClient.i2cHandle == NULL) {
+        HDF_LOGE("%s: open i2c failed", __func__);
+        return HDF_FAILURE;
+    }
+
+    ReadChipVersion(cd);
+    return HDF_SUCCESS;
+}
+
+static int TouchCleanBuffer(void)
+{
+    TouchCoreData *cd = GetCoreData();
+    unsigned char writeBuf[GT_CLEAN_DATA_LEN];
+    writeBuf[GT_REG_HIGH_POS] = (GT_BUF_STATE_ADDR >> ONE_BYTE_OFFSET) & ONE_BYTE_MASK;
+    writeBuf[GT_REG_LOW_POS] = GT_BUF_STATE_ADDR & ONE_BYTE_MASK;
+    writeBuf[GT_CLEAN_POS] = GT_CLEAN_FLAG;
+    int ret = InputI2cWrite(&cd->i2cClient, writeBuf, GT_CLEAN_DATA_LEN);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: InputI2cWrite fail, ret = %d", __func__, ret);
+    }
+    return ret;
+}
+
+static int EventHandler(const TouchCoreData *cd, InputEventData *event)
+{
+	static int bPressed = 0;
+    unsigned char fingerNum = 0;
+    int pointNum;
+    (void)memset_s(event, sizeof(InputEventData), 0, sizeof(InputEventData));
+
+    int ret = InputI2cRead(&cd->i2cClient, GT_BUF_STATE_ADDR, GT_ADDR_LEN, &fingerNum, 1);
+    if (ret < 0) {
+        return HDF_FAILURE;
+    }
+
+	//PRINT_RELEASE("%s %s %d, fingerNum= 0x%x\n", __FILE__, __FUNCTION__, __LINE__, fingerNum);
+	
+    if (fingerNum == GT_EVENT_INVALID) {
+		return HDF_FAILURE;
+		
+    }
+    if (fingerNum == GT_EVENT_UP) {
+        g_touchEventData.pointNum = 0;
+        g_touchEventData.definedEvent = TOUCH_EVENT_UP;
+
+		if (bPressed) {
+			bPressed = 0;
+			//HDF_LOGE("%s: pointNum is invalid, %d", __func__, pointNum);
+			event->pressure = 0;
+			event->pointNum = 0;
+			event->definedEvent = TOUCH_EVENT_DOWN;
+			
+			if (memcpy_s(&g_touchEventData, sizeof(InputEventData), event, sizeof(InputEventData)) != EOK) {
+				HDF_LOGE("%s: memcpy_s fail", __func__);
+				return HDF_FAILURE;
+			}
+		}	
+        goto exit;
+    }
+
+    pointNum = fingerNum & GT_FINGER_NUM_MASK;
+    if (pointNum > 0) {
+        unsigned char eventBuf[GT_EVENT_SIZE] = {0};
+        (void)InputI2cRead(&cd->i2cClient, GT_X_LOW_BYTE_BASE, GT_ADDR_LEN, eventBuf, GT_EVENT_SIZE);
+
+		bPressed = 1;
+		
+        /* parse the i2c data */
+        event->x = (eventBuf[GT_X_LOW] & ONE_BYTE_MASK) | ((eventBuf[GT_X_HIGH] & ONE_BYTE_MASK) << ONE_BYTE_OFFSET);
+        event->y = (eventBuf[GT_Y_LOW] & ONE_BYTE_MASK) | ((eventBuf[GT_Y_HIGH] & ONE_BYTE_MASK) << ONE_BYTE_OFFSET);
+		event->pressure = (eventBuf[GT_PRESSURE_LOW] & ONE_BYTE_MASK) | ((eventBuf[GT_PRESSURE_HIGH] & ONE_BYTE_MASK) << ONE_BYTE_OFFSET);
+        event->pointNum = pointNum;
+        event->definedEvent = TOUCH_EVENT_DOWN;
+	
+        if (memcpy_s(&g_touchEventData, sizeof(InputEventData), event, sizeof(InputEventData)) != EOK) {
+            HDF_LOGE("%s: memcpy_s fail", __func__);
+            return HDF_FAILURE;
+        }
+    } else {
+		return HDF_FAILURE;
+    }
+exit:
+    if (TouchCleanBuffer() != HDF_SUCCESS) {
+        return HDF_FAILURE;
+    }
+    return HDF_SUCCESS;
+}
+
+static void TouchHandleEvent(void)
+{
+    InputEventData event;
+    TouchCoreData *cd = GetCoreData();
+    (void)memset_s(&event, sizeof(InputEventData), 0, sizeof(InputEventData));
+
+    while (true) {
+        int ret = LOS_EventRead(&g_touchEventIrq, EVENT_SYNC, LOS_WAITMODE_AND | LOS_WAITMODE_CLR, LOS_WAIT_FOREVER);
+        if (ret != EVENT_SYNC) {
+            OsalMSleep(TASK_SLEEP_MS);
+        } else {
+            if (EventHandler(cd, &event) == HDF_SUCCESS) {
+                TouchWakeupPoll();
+            }
+        }
+
+		gt9xx_irq_clear(cd->intGpioNum);
+        ret = gt9xx_irq_enable(cd->intGpioNum);
+        if (ret != HDF_SUCCESS) {
+            HDF_LOGE("%s: enable irq failed, ret %d", __func__, ret);
+        }
+
+        if (cd->shouldStop) {
+            HDF_LOGE("%s: the event task should be stoped", __func__);
+            break;
+        }
+    }
+}
+
+static int TouchIrqTaskInit(TouchCoreData *cd)
+{
+    /* init event for irq */
+    int ret = LOS_EventInit(&g_touchEventIrq);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: LOS_EventInit failed, ret %d", __func__, ret);
+        return HDF_FAILURE;
+    }
+
+    /* register irq */
+	gt9xx_irq_init(cd);
+
+    /* enable irq */
+    ret = gt9xx_irq_enable(cd->intGpioNum);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: enable irq failed, ret %d", __func__, ret);
+        return HDF_FAILURE;
+    }
+
+    /* set irq task which to handle point event data */
+    TSK_INIT_PARAM_S handleEventTask = {0};
+    UINT32 handleEventTaskID;
+    handleEventTask.pfnTaskEntry = (TSK_ENTRY_FUNC)TouchHandleEvent;
+    handleEventTask.uwStackSize  = TASK_SIZE;
+    handleEventTask.pcName       = "HdfTouchEventHandler";
+    handleEventTask.usTaskPrio   = TASK_PRIO_LEVEL_TWO;
+    handleEventTask.uwResved     = LOS_TASK_STATUS_DETACHED;
+    ret = LOS_TaskCreate(&handleEventTaskID, &handleEventTask);
+    if (ret != HDF_SUCCESS) {
+        HDF_LOGE("%s: create event handle task failed, ret %d", __func__, ret);
+        return HDF_FAILURE;
+    }
+    return HDF_SUCCESS;
+}
+
+static int IoctlReadInputEvent(unsigned long arg)
+{
+    InputEventData *eventData = (InputEventData *)(uintptr_t)arg;
+
+    if (eventData == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    if (LOS_ArchCopyToUser(eventData, &g_touchEventData, sizeof(g_touchEventData)) != 0) {
+        HDF_LOGE("%s:copy chipInfo failed", __func__);
+        return HDF_FAILURE;
+    }
+    return HDF_SUCCESS;
+}
+
+static int IoctlGetDeviceType(unsigned long arg)
+{
+    unsigned int *devType = (unsigned int *)(uintptr_t)arg;
+    TouchCoreData *cd = GetCoreData();
+
+    if (devType == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+
+    if (LOS_ArchCopyToUser(devType, &cd->inputDevType, sizeof(cd->inputDevType)) != 0) {
+        HDF_LOGE("%s:copy devType failed", __func__);
+        return HDF_FAILURE;
+    }
+
+    HDF_LOGI("%s: devType is %u", __func__, cd->inputDevType);
+    return HDF_SUCCESS;
+}
+
+static int IoctlGetChipInfo(unsigned long arg)
+{
+    TouchCoreData *cd = GetCoreData();
+    char *chipInfo = (char *)(uintptr_t)arg;
+
+    if (chipInfo == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+
+    if (LOS_ArchCopyToUser(chipInfo, cd->chipInfo, CHIP_INFO_LEN) != 0) {
+        HDF_LOGE("%s:copy chipInfo failed", __func__);
+        return HDF_FAILURE;
+    }
+
+    HDF_LOGI("%s: chipInfo is %s", __func__, cd->chipInfo);
+    return HDF_SUCCESS;
+}
+
+static int TouchIoctl(FAR struct file *filep, int cmd, unsigned long arg)
+{
+    int ret;
+    if (filep == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+
+    switch (cmd) {
+        case INPUT_IOCTL_GET_EVENT_DATA:
+            ret = IoctlReadInputEvent(arg);
+            break;
+        case INPUT_IOCTL_GET_DEVICE_TYPE:
+            ret = IoctlGetDeviceType(arg);
+            break;
+        case INPUT_IOCTL_GET_CHIP_INFO:
+            ret = IoctlGetChipInfo(arg);
+            break;
+        default:
+            ret = 0;
+            HDF_LOGE("%s: cmd unknown, cmd = 0x%x", __func__, cmd);
+            break;
+    }
+    return ret;
+}
+
+#ifndef CONFIG_DISABLE_POLL
+static int TouchPoll(FAR struct file *filep, poll_table *wait)
+{
+    unsigned int pollMask = 0;
+    TouchCoreData *cd = GetCoreData();
+
+    if (filep == NULL || wait == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    poll_wait(filep, &cd->pollWait, wait);
+    if (cd->readFinishFlag == true) {
+        pollMask |= POLLIN;
+    }
+    cd->readFinishFlag = false;
+    return pollMask;
+}
+#endif
+
+static int TouchOpen(FAR struct file *filep)
+{
+    HDF_LOGI("%s: called", __func__);
+    if (filep == NULL) {
+        HDF_LOGE("%s: fliep is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    return HDF_SUCCESS;
+}
+
+static int TouchClose(FAR struct file *filep)
+{
+    HDF_LOGI("%s: called", __func__);
+    TouchCoreData *cd = GetCoreData();
+
+    if (filep == NULL) {
+        HDF_LOGE("%s: fliep is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    __init_waitqueue_head(&cd->pollWait);
+    return HDF_SUCCESS;
+}
+
+static const struct file_operations_vfs g_touchDevOps = {
+    .open = TouchOpen,
+    .close = TouchClose,
+    .read = NULL,
+    .write = NULL,
+    .seek = NULL,
+    .ioctl = TouchIoctl,
+    .mmap = NULL,
+#ifndef CONFIG_DISABLE_POLL
+    .poll = TouchPoll,
+#endif
+    .unlink = NULL,
+};
+
+
+int32_t Gt911Dispatch(struct HdfDeviceIoClient *client, int cmdId, struct HdfSBuf *data, struct HdfSBuf *reply)
+{
+    (void)client;
+    (void)cmdId;
+    if (data == NULL || reply == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_FAILURE;
+    }
+    return HDF_SUCCESS;
+}
+
+int32_t Gt9xxTouchDriverOpen(struct HdfDeviceObject *object)
+{
+    if (object == NULL) {
+        HDF_LOGE("%s: param is null", __func__);
+        return HDF_ERR_INVALID_PARAM;
+    }
+    static struct IDeviceIoService service = {
+        .object = {0},
+        .Dispatch = Gt911Dispatch,
+    };
+    object->service = &service;
+    return HDF_SUCCESS;
+}
+
+int Gt9xxTouchDriverInit(struct HdfDeviceObject *object)
+{
+    (void)object;
+    HDF_LOGI("%s: enter", __func__);
+    g_coreData = (TouchCoreData *)OsalMemAlloc(sizeof(TouchCoreData));
+    if (g_coreData == NULL) {
+        HDF_LOGE("%s: malloc failed", __func__);
+        return HDF_ERR_MALLOC_FAIL;
+    }
+    (void)memset_s(g_coreData, sizeof(TouchCoreData), 0, sizeof(TouchCoreData));
+    TouchConfigInit(g_coreData);
+
+    if (TouchSetupGpio(g_coreData)) {
+        goto ERR_EXIT;
+    }
+
+    if (TouchSetupI2c(g_coreData)) {
+        goto ERR_EXIT;
+    }
+
+    if (TouchIrqTaskInit(g_coreData)) {
+        goto ERR_EXIT;
+    }
+
+    (void)mkdir("/dev/input", DEFAULT_DIR_MODE);
+    int ret = register_driver(TOUCH_DEVICE, &g_touchDevOps, TOUCH_DEVICE_MODE, NULL);
+    if (ret != 0) {
+        HDF_LOGE("%s: register touch dev failed, ret %d", __func__, ret);
+        goto ERR_EXIT;
+    }
+    HDF_LOGI("%s: exit succ", __func__);
+    return HDF_SUCCESS;
+
+ERR_EXIT:
+    if (g_coreData->i2cClient.i2cHandle != NULL) {
+        I2cClose(g_coreData->i2cClient.i2cHandle);
+        g_coreData->i2cClient.i2cHandle = NULL;
+    }
+    OsalMemFree(g_coreData);
+    g_coreData = NULL;
+    return HDF_FAILURE;
+}
+
+struct HdfDriverEntry g_gt9xxTouchDevEntry = {
+    .moduleVersion = 1,
+    .moduleName = "HDF_TOUCHSCREEN",
+    .Bind = Gt9xxTouchDriverOpen,
+    .Init = Gt9xxTouchDriverInit,
+};
+
+HDF_INIT(g_gt9xxTouchDevEntry);
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/driver/touch/touch_gt9xx.h openharmony_100ask/vendor/st/stm32mp157/driver/touch/touch_gt9xx.h
--- openharmony/vendor/st/stm32mp157/driver/touch/touch_gt9xx.h	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/driver/touch/touch_gt9xx.h	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
+ * Description: ft6236 touch driver interface.
+ * Author: zhaihaipeng
+ * Create: 2020-07-25
+ */
+
+#ifndef TOUCH_GT911_H
+#define TOUCH_GT911_H
+
+#include <stdint.h>
+#include <sys/time.h>
+#include <sys/wait.h>
+#include "i2c_if.h"
+
+/* screen resolution */
+#define TOUCH_SOLUTION_X 1024
+#define TOUCH_SOLUTION_Y 600
+/* driver chip i2c address */
+#define DRIVER_CHIP_I2C_ADDR 0x5D
+#define I2C_BUS_NUM 0
+/* pin num of reset and irq */
+#define GPIO_GROUP_SIZE 8
+#define RST_GPIO_GROUP 1
+#define RST_GPIO_OFFSET 5
+#define INT_GPIO_GROUP 1
+#define INT_GPIO_OFFSET 4
+/* the config of reset delay */
+#define RESET_LOW_DELAY 10
+#define RESET_HIGH_DELAY 60
+/* IO config for int-pin and I2C-pin */
+#define I2C6_DATA_REG_ADDR 0x114f004c
+#define I2C6_CLK_REG_ADDR 0x114f0048
+#define INR_REG_ADDR 0x10ff002C
+#define RST_REG_ADDR 0x10ff0030
+#define I2C_REG_CFG 0x403
+#define INT_REG_CFG 0x400
+#define RST_REG_CFG 0x400
+/* length of string about device info */
+#define CHIP_INFO_LEN 10
+#define CHIP_NAME_LEN 10
+#define VENDOR_NAME_LEN 10
+#define SELF_TEST_RESULT_LEN 20
+
+typedef enum {
+    EVENT_DOWN,
+    EVENT_UP,
+    EVENT_CONTACT,
+} EventType;
+
+typedef enum {
+    INPUT_SUCCESS,
+    INPUT_EINVAL,
+    INPUT_EFAULT,
+    INPUT_ENOMEM,
+    INPUT_ETIMEOUT,
+    INPUT_EUNSUPPORT,
+    INPUT_EUNKNOWN,
+} RetStatus;
+
+enum InputDevType {
+    INDEV_TYPE_TOUCH,
+    INDEV_TYPE_KEY,
+    INDEV_TYPE_KEYBOARD,
+    INDEV_TYPE_MOUSE,
+    INDEV_TYPE_BUTTON,
+    INDEV_TYPE_CROWN,
+    INDEV_TYPE_ENCODER, /* Encoder with specific function or event */
+    INDEV_TYPE_MAX,
+};
+
+enum PowerStatus {
+    INPUT_RESUME = 0,
+    INPUT_SUSPEND = 1,
+    INPUT_LOW_POWER = 2,
+    INPUT_POWER_STATUS_UNKNOWN,
+};
+
+/** multi touch info */
+typedef struct {
+    int x;    /* x coordinate */
+    int y;    /* y coordinate */
+    int pressure;
+    int definedEvent;    /* touch event: 0-down; 1-up; 2-contact */
+    int fingerID;        /* touch ID */
+    int pointNum;
+    struct timeval timeStamp;
+    bool moreDataFlag;
+} InputEventData;
+
+
+typedef struct {
+    unsigned int testType;
+    char testResult[SELF_TEST_RESULT_LEN + 1];
+} CapacitanceTestInfo;
+
+typedef struct {
+    const char *cmdCode;
+    const char *cmdValue;
+} InputExtraCmd;
+
+struct InputConfig {
+    unsigned int solutionX;
+    unsigned int solutionY;
+};
+
+typedef struct {
+    unsigned int inputDevType;
+    wait_queue_head_t pollWait;
+    bool readFinishFlag;
+    bool shouldStop;
+    struct InputConfig inputCfg;
+    InputI2cClient i2cClient;
+    int intGpioNum;
+    int rstGpioNum;
+    unsigned int irqFlag;
+    unsigned int powerStatus;
+    char chipInfo[CHIP_INFO_LEN];
+    char vendorName[VENDOR_NAME_LEN];
+    char chipName[CHIP_NAME_LEN];
+} TouchCoreData;
+
+enum TouchIoctlCmd {
+    INPUT_IOCTL_GET_EVENT_DATA,
+    INPUT_IOCTL_SET_POWER_STATUS,
+    INPUT_IOCTL_GET_POWER_STATUS,
+    INPUT_IOCTL_GET_DEVICE_TYPE,
+    INPUT_IOCTL_GET_CHIP_INFO,
+    INPUT_IOCTL_GET_VENDOR_NAME,
+    INPUT_IOCTL_GET_CHIP_NAME,
+    INPUT_IOCTL_SET_GESTURE_MODE,
+    INPUT_IOCTL_RUN_CAPACITANCE_TEST,
+    INPUT_IOCTL_RUN_EXTRA_CMD,
+};
+
+#endif
diff -urN -x .git -x .repo openharmony/vendor/st/stm32mp157/stm32mp157.mk openharmony_100ask/vendor/st/stm32mp157/stm32mp157.mk
--- openharmony/vendor/st/stm32mp157/stm32mp157.mk	1970-01-01 08:00:00.000000000 +0800
+++ openharmony_100ask/vendor/st/stm32mp157/stm32mp157.mk	2020-10-31 00:27:40.772667969 +0800
@@ -0,0 +1,24 @@
+
+STM32MP157_BASE_DIR  := $(LITEOSTOPDIR)/../../vendor/st/stm32mp157
+
+LIB_SUBDIRS     += $(STM32MP157_BASE_DIR)/board
+LITEOS_BASELIB  += -lboard
+
+LIB_SUBDIRS     += $(STM32MP157_BASE_DIR)/driver/mtd/common
+LITEOS_BASELIB  += -lmtd_common
+
+LIB_SUBDIRS     += $(STM32MP157_BASE_DIR)/driver/mtd/spi_nor
+LITEOS_BASELIB  += -lspinor_flash
+
+ifeq ($(LOSCFG_DRIVERS_VIDEO), y)
+LIB_SUBDIRS             += $(STM32MP157_BASE_DIR)/driver/stm32mp157-fb
+LITEOS_BASELIB  += -lstm32mp157-fb
+endif
+
+LIB_SUBDIRS             += $(STM32MP157_BASE_DIR)/driver/stm32mp157-uart
+LITEOS_BASELIB  += -lstm32mp157-uart
+
+
+LITEOS_MTD_SPI_NOR_INCLUDE +=   -I$(STM32MP157_BASE_DIR)/driver/mtd/common/include \
+                                                                -I$(STM32MP157_BASE_DIR)/driver/mtd/spi_nor/include
+
