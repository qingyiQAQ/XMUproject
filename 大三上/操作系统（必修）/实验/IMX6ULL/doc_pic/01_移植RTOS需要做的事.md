# 1. 框架

![](pic\001_移植RTOS要做的事\001_harmony_framework.png)

鸿蒙是一套完整的、普通人可以直接使用的操作系统，跟Windows、安卓、IOS类似。
常见的错误观点是把鸿蒙跟Linux放在一起来对比，这不对：

* Linux只是一个内核，普通人无法使用
  * 还需要在Linux之上安装各类程序
  * 比如Ubuntu等发行版，它们在Linux内核之上，还有桌面、各类办公软件

* 鸿蒙支持多种内核：Linux、Liteos(又分为Liteos-a、Liteos-m)
* 在内核之上，鸿蒙还有各种子系统，在子系统之上又有桌面等软件



# 2. 嵌入式软件系统的组成

![](pic\001_移植RTOS要做的事\002_embeded_soft_parts.png)

我们可以把内核之上的软件，简单称为APP(实际上还可以细分，比如各类子系统、桌面等APP)。
启动内核，并不复杂，使用U-boot即可。



# 3. 移植最小系统要做的几件事

* 串口相关
  * 打印(只是打印调试信息)
  * 串口驱动(可发可收，APP执行printf时可以从串口打印，所以需要**驱动**)
* MMU(Memory Management Unit，内存管理单元)的设置：虚拟地址与物理地址
* 完善中断子系统
  * 提供系统tick时钟
  * 为串口驱动实现基于中断的读取字符函数

* 实现存储设备驱动程序
* 在存储设备上烧录文件系统

## 3.1 串口相关

与Linux的串口驱动相比，鸿蒙的串口驱动极大简化了。
对于输出：不使用中断，直接使用查询方式输出。
对于输入：使用中断，我们只需要提供底层硬件相关的代码。
要注意：使用的是虚拟地址。

## 3.2 MMU设置

MMU有2大功能：

### 3.2.1 权限管理
  * 比如可以把进程A、B的地址空间完全隔离开，它们互不影响
  * 写得差的进程、有恶意的进程，不能影响到其他进程
  * 用户程序、内核地址空间完全隔离开：不允许用户直接访问硬件
  * 示例如下
    ![](pic\001_移植RTOS要做的事\004_permission.png)

### 3.2.2 地址映射

  * 使能MMU后，CPU发出的地址被称为"虚拟地址"，它不是直接发送给硬件，而是发给MMU
  * MMU根据页表
    * 进行权限判定
    * 转换为物理地址，发给外设

  运行app1时，CPU发出的addr，通过MMU映射到paddr1；
  运行app2时，CPU发出的同一个addr，通过MMU映射到paddr2；
  虽然app1、app2使用的地址相同，但是对应的内存不同，如下图：

![](pic\001_移植RTOS要做的事\005_addr_map.png)

* 在移植过程中，我们不需要关注“权限”，只需要关注“地址映射”



## 3.3 中断子系统

操作系统跟单片机程序最大的区别，就是多任务，也就是**同时**运行多个程序。
**同时**，对人类来说是这样的，多个程序好像可以同时运行，实际上它们是**轮流**运行。

### 3.3.1 操作系统"同时"运行多个任务

轮流运行：

![](pic\001_移植RTOS要做的事\003_multi_tasks.png)

### 3.3.2 串口接收数据的中断

使用串口接收数据时，如果使用"查询"方式，低效并且费电。
一般都使用中断方式。

## 3.4 存储设备的驱动程序

板子上一般都有EMMC、SD/TF卡、Nor Flash、Nand Flash等存储设备。
Nor Flash、Nand Flash的驱动程序相对简单，但是这些设备比较少见了。
而EMMC、SD/TF卡的驱动程序又太复杂，足够出一个专题了。
我们聚焦在**最小系统**的移植，先把流程走通：用内存来模拟Flash。


## 3.5 根文件系统

光有存储设备还不行，上面需要有文件：这就是根文件系统。
一个程序要能运行，出了你写出的程序本身，还需要其他库，比如`printf`就不是你写的，它在库文件里。
根文件系统里会有这些内容：

* 程序
* 库
* 配置文件
* 用户数据(可选)
* 驱动程序(可选)

# 4. 想做更多

* 为有更好的人机交互可以移植LCD、触摸屏驱动
* 为了方便开发，移植EMMC驱动、网卡驱动
* 要接各类外设，还需要I2C、SPI、GPIO、UART驱动
* 摄像头、声卡驱动